<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Bosnian Survivors: SMALL UPDATE</title>
<style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@500;700&display=swap');
    :root { 
        --bosnia-blue:#002395; 
        --bosnia-yellow:#fecb00; 
        --neon-cyan:#00f3ff; 
        --rare-blue:#4d80ff; 
        --supercharge:#ff2a2a; 
        --legendary:#d000ff; 
        --danger:#ff003c; 
        --dark:#050510; 
    }
    body { margin:0; overflow:hidden; background-color:var(--dark); font-family:'Rajdhani', sans-serif; color:white; user-select:none; }
    
    #crt-overlay {
        position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 9999;
        background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.1) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.03), rgba(0, 255, 0, 0.01), rgba(0, 0, 255, 0.03));
        background-size: 100% 4px, 6px 100%;
    }

    #ui-layer { position:fixed; top:0; left:0; width:100%; height:100%; pointer-events:none; padding:20px; box-sizing:border-box; display:flex; flex-direction:column; z-index:50; }
    .hud-top { display:flex; justify-content:space-between; align-items:flex-start; pointer-events: none; }
    
    .stat-box { 
        background:rgba(0, 10, 30, 0.6); 
        backdrop-filter:blur(4px); 
        border:1px solid rgba(0, 243, 255, 0.2); 
        border-bottom:3px solid var(--bosnia-yellow); 
        padding:8px 25px; 
        transform: skewX(-15deg);
        display:flex; flex-direction:column; align-items:center; 
    }
    .stat-content { transform: skewX(15deg); text-align: center; }

    .label { font-size:10px; color:var(--neon-cyan); text-transform:uppercase; letter-spacing:2px; font-family:'Orbitron'; margin-bottom:2px; opacity: 0.8; }
    .value { font-size:24px; font-weight:700; color:#fff; text-shadow:0 0 5px var(--neon-cyan); }
    
    /* TIMER */
    #timer-box {
        position: absolute; top: 20px; left: 50%; transform: translateX(-50%) skewX(-15deg);
        background:rgba(0, 0, 0, 0.8); border:1px solid var(--bosnia-yellow);
        padding: 5px 30px; 
    }
    #timer-display {
        font-family: 'Orbitron'; font-size: 32px; color: var(--bosnia-yellow); transform: skewX(15deg); letter-spacing: 3px;
    }

    /* BOSS BAR */
    #boss-hud { display:none; position:fixed; top:80px; left:50%; transform:translateX(-50%); width:600px; z-index:60; flex-direction:column; align-items:center; }
    #boss-name { font-family:'Orbitron'; font-size:28px; color:var(--danger); margin-bottom:5px; letter-spacing:8px; font-weight:900; }
    #boss-bar-bg { width:100%; height:12px; background:rgba(0,0,0,0.8); border:1px solid var(--danger); transform: skewX(-20deg); overflow:hidden; }
    #boss-bar-fill { width:100%; height:100%; background:linear-gradient(90deg, #800000, #ff003c); transition:width 0.1s; }

    #pause-btn { pointer-events: auto; background:rgba(0,0,0,0.5); border:1px solid var(--neon-cyan); color:var(--neon-cyan); width:40px; height:40px; border-radius:0; transform: skewX(-10deg); font-family:'Orbitron'; font-weight:bold; cursor:pointer; margin-left:10px; display:flex; align-items:center; justify-content:center; transition:0.2s; }
    #pause-btn:hover { background:var(--neon-cyan); color:black; }

    .xp-container { position:fixed; top:0; left:0; width:100%; height:4px; background:#000; z-index:100; pointer-events: none; }
    #xp-fill { height:100%; width:0%; background:linear-gradient(90deg, var(--bosnia-blue), var(--neon-cyan)); transition:width 0.2s; }
    
    .screen-overlay { display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(5, 5, 10, 0.95); z-index:2000; flex-direction:column; align-items:center; justify-content:center; pointer-events:auto; overflow-y:auto;}
    
    #main-menu { display:flex; background: linear-gradient(rgba(0,0,0,0.5), rgba(0,0,0,0.9)), url('https://img.freepik.com/free-vector/blue-futuristic-networking-technology-background-vector_53876-114068.jpg'); background-size:cover; background-position: center; }
    .title-glitch { font-family:'Orbitron'; font-size:70px; color:white; text-shadow:2px 2px var(--bosnia-blue), -2px -2px var(--danger); text-align:center; }
    
    .menu-btn { 
        background:linear-gradient(90deg, rgba(0,0,0,0.5), rgba(0, 35, 149, 0.4)); 
        border:1px solid var(--bosnia-blue); 
        border-left: 4px solid var(--bosnia-yellow);
        color:white; padding:15px 50px; margin:10px; font-size:20px; font-family:'Orbitron'; 
        cursor:pointer; text-transform:uppercase; letter-spacing:4px; width:320px; 
        transition:0.2s; 
        clip-path: polygon(10px 0, 100% 0, 100% calc(100% - 10px), calc(100% - 10px) 100%, 0 100%, 0 10px);
        position: relative; overflow: hidden;
    }
    .menu-btn:hover { background:var(--bosnia-yellow); color:black; border-color:white; font-weight: 800; }

    #admin-panel { display:none; border:2px solid var(--danger); background:rgba(0,0,0,0.95); box-shadow: 0 0 50px rgba(255,0,0,0.2); }
    .admin-grid { display:grid; grid-template-columns: 1fr 1fr; gap:10px; width:500px; padding:20px; }
    .admin-btn { background:#111; border:1px solid #555; color:white; padding:15px; cursor:pointer; font-family:'Orbitron'; text-transform:uppercase; transition:0.2s; font-size: 14px; }
    .admin-btn:hover { background:var(--danger); color:white; border-color:white; box-shadow: 0 0 10px var(--danger); }
    .admin-header { font-family:'Orbitron'; color:var(--danger); font-size:30px; margin-bottom:20px; text-shadow:0 0 10px red; letter-spacing: 5px; text-align: center; width: 100%; border-bottom: 1px solid #333; padding-bottom: 10px;}

    .info-grid { display:grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap:20px; max-width:1100px; width:90%; padding:20px; }
    .info-card { background:rgba(255,255,255,0.03); border:1px solid rgba(255,255,255,0.1); padding:20px; border-radius:4px; display:flex; align-items:center; gap:15px; position:relative; overflow:hidden;}
    .info-card.rare { border: 1px solid var(--rare-blue); box-shadow: inset 0 0 20px rgba(77, 128, 255, 0.1); }
    .info-card.legendary { border: 1px solid var(--legendary); box-shadow: inset 0 0 20px rgba(208, 0, 255, 0.1); }
    
    .info-icon { font-size:30px; min-width:60px; height: 60px; display: flex; align-items: center; justify-content: center; background: rgba(0,0,0,0.3); border-radius: 50%; border:1px solid rgba(255,255,255,0.1); }
    .info-text h3 { margin:0 0 5px 0; color:var(--bosnia-yellow); font-family:'Orbitron'; font-size:16px; letter-spacing: 1px; }
    .info-text p { margin:0; color:#aaa; font-size:13px; line-height:1.4; }
    .close-btn { position:absolute; top:30px; right:30px; background:none; border:none; color:white; font-size:40px; cursor:pointer; font-family: 'Rajdhani'; line-height: 20px;}
    .close-btn:hover { color:var(--danger); }

    .cards-container { display:flex; gap:25px; margin-top:30px; flex-wrap:wrap; justify-content:center; max-width:1200px;perspective: 1000px; }
    
    .card { 
        background:linear-gradient(170deg, #0a0a15 0%, #101025 100%); 
        border:1px solid #333; 
        width:220px; height:360px; 
        border-radius:2px; padding:20px; 
        cursor:pointer; transition:0.3s; 
        display:flex; flex-direction:column; align-items:center; text-align:center; 
        box-shadow:0 10px 30px rgba(0,0,0,0.8); 
        position:relative; overflow:hidden; 
        clip-path: polygon(20px 0, 100% 0, 100% calc(100% - 20px), calc(100% - 20px) 100%, 0 100%, 0 20px);
    }
    .card:hover { transform:translateY(-10px); border-color:var(--bosnia-yellow); z-index: 10; }
    .card:hover .card-icon { transform: scale(1.1); }

    .card::after { content:''; position: absolute; top:0; left:0; width:100%; height:4px; background: var(--bosnia-yellow); }
    .card.rare { border-color: var(--rare-blue); background:linear-gradient(170deg, #051025 0%, #000 100%); }
    .card.rare::after { background: var(--rare-blue); }
    .card.rare .card-name { color: var(--rare-blue); }
    
    .card.legendary { border-color: var(--legendary); background:linear-gradient(170deg, #1a0025 0%, #000 100%); }
    .card.legendary::after { background: var(--legendary); }
    .card.legendary .card-name { color: var(--legendary); text-shadow: 0 0 5px var(--legendary); }

    .card-icon { font-size:60px; margin: 30px 0; transition: 0.3s; filter: drop-shadow(0 0 5px rgba(255,255,255,0.2)); }
    .card-name { font-family:'Orbitron'; font-weight:900; color:#fff; margin-bottom:10px; font-size:18px; text-transform:uppercase; letter-spacing: 1px;}
    .card-desc { font-size:13px; color:#99a; line-height:1.5; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 10px; width: 100%; }
    .card-level { position:absolute; top:10px; right:10px; font-size:10px; color:#555; font-family:'Orbitron'; font-weight: bold; }

    .restart-btn { background: var(--danger); color:white; border:none; padding:20px 60px; font-size:24px; font-weight:900; cursor:pointer; font-family:'Orbitron'; clip-path:polygon(10px 0, 100% 0, 100% calc(100% - 10px), calc(100% - 10px) 100%, 0 100%, 0 10px); transition:0.2s; box-shadow:0 0 15px var(--danger); margin-top:30px; text-transform:uppercase; letter-spacing: 2px; }
    .restart-btn:hover { transform:scale(1.05); background: white; color: var(--danger); }
    
    canvas { display:block; position:absolute; top:0; left:0; z-index:1; }
</style>
</head>
<body>

<div id="crt-overlay"></div>
<div class="xp-container"><div id="xp-fill"></div></div>

<!-- BOSS HUD -->
<div id="boss-hud">
    <div id="boss-name">TURBO FOLK WARLORD</div>
    <div id="boss-bar-bg"><div id="boss-bar-fill"></div></div>
</div>

<!-- MAIN MENU -->
<div id="main-menu" class="screen-overlay" style="display:flex;">
    <h1 class="title-glitch">BOSNIAN<br><span style="color:var(--bosnia-yellow)">SURVIVORS</span></h1>
    <h3 style="font-family:'Rajdhani'; letter-spacing:5px; color:var(--neon-cyan); margin-top:-20px;">SMALL UPDATE</h3>
    <div style="height:40px;"></div>
    <button class="menu-btn" onclick="startGame()">DEPLOY</button>
    <button class="menu-btn" onclick="openInfo('armory')">ARMORY</button>
    <button class="menu-btn" onclick="openInfo('intel')">INTEL</button>
</div>

<!-- INFO MODAL -->
<div id="info-modal" class="screen-overlay">
    <button class="close-btn" onclick="closeInfo()">Ã—</button>
    <h1 id="info-title" style="font-family:'Orbitron'; color:var(--bosnia-yellow); margin-top:50px; font-size: 40px; text-shadow: 0 0 10px var(--bosnia-yellow);">DATA</h1>
    <div id="info-content" class="info-grid"></div>
</div>

<!-- ADMIN PANEL -->
<div id="admin-panel" class="screen-overlay">
    <div class="admin-header">/// DEBUG CONTROL ///</div>
    <div class="admin-grid">
        <button class="admin-btn" onclick="toggleGodMode()">Toggle God Mode</button>
        <button class="admin-btn" onclick="adminLevelUp()">+1 Level</button>
        <button class="admin-btn" onclick="adminKillAll()">Kill All Enemies</button>
        <button class="admin-btn" onclick="spawnBoss()">Force Boss Spawn</button>
        <button class="admin-btn" onclick="adminMaxWeapons()">Max All Weapons</button>
        <button class="admin-btn" onclick="adminHeal()">Full Heal</button>
    </div>
    <button class="menu-btn" style="width:200px; margin-top:20px;" onclick="closeAdmin()">RESUME</button>
</div>

<!-- PAUSE MENU -->
<div id="pause-screen" class="screen-overlay">
    <h1 style="font-family:'Orbitron'; font-size:60px; color:var(--neon-cyan);">PAUSED</h1>
    <button class="menu-btn" onclick="togglePause()">RESUME</button>
    <button class="menu-btn" onclick="quitGame()">MAIN MENU</button>
</div>

<!-- GAME UI -->
<div id="ui-layer" style="display:none;">
    <div id="timer-box">
        <div id="timer-display">00:00</div>
    </div>
    
    <div class="hud-top">
        <div class="stat-box">
            <div class="stat-content">
                <div class="label">Threat Level</div>
                <div class="value" style="color:var(--bosnia-yellow)" id="lvl-display">1</div>
            </div>
        </div>
        <div style="width:400px; text-align:center;">
             <div style="width:100%; height:12px; background:rgba(0,0,0,0.5); margin-top:10px; transform: skewX(-20deg); border:1px solid #555; overflow: hidden;">
                 <div id="hp-fill" style="width:100%; height:100%; background:linear-gradient(90deg, #ff003c, #ff5e00);"></div>
             </div>
             <div style="font-size: 10px; color: #888; margin-top: 5px; font-family: 'Orbitron'; letter-spacing: 2px;">VITAL SYSTEMS</div>
        </div>
        <div style="display:flex;">
            <div class="stat-box">
                <div class="stat-content">
                    <div class="label">Kills</div>
                    <div class="value" style="color:#fff" id="score-display">0</div>
                </div>
            </div>
            <button id="pause-btn" onclick="togglePause()">||</button>
        </div>
    </div>
    <div id="god-mode-indicator" style="display:none; position:fixed; bottom:20px; left:20px; color:var(--danger); font-family:'Orbitron'; font-size:20px; text-shadow:0 0 10px red;">GOD MODE ACTIVE</div>
</div>

<div id="levelup-screen" class="screen-overlay">
    <h1 style="font-family:'Orbitron'; font-size:50px; color:var(--bosnia-yellow); margin-bottom:5px; text-shadow:0 0 15px var(--bosnia-yellow); letter-spacing: 5px;">SYSTEM UPGRADE</h1>
    <p style="color:var(--neon-cyan); margin-bottom:30px; font-size:18px; font-family: 'Rajdhani'; letter-spacing: 2px;">SELECT AUGMENTATION</p>
    <div class="cards-container" id="cards-box"></div>
</div>

<div id="game-over" class="screen-overlay">
    <h1 style="color:var(--danger); font-family:'Orbitron'; font-size:100px; margin:0; text-shadow:0 0 20px red; letter-spacing:10px;">MIA</h1>
    <p style="font-size:24px; color:white; font-family: 'Rajdhani'; letter-spacing: 2px;">FINAL SCORE: <span id="final-score" style="color:var(--bosnia-yellow); font-weight:bold;">0</span></p>
    <button class="restart-btn" onclick="resetGame()">RESPAWN</button>
    <button class="menu-btn" style="margin-top:20px; font-size:16px;" onclick="quitGame()">EXIT TO MENU</button>
</div>

<canvas id="game"></canvas>

<script>
    const canvas = document.getElementById('game'), ctx = canvas.getContext('2d', { alpha: false });
    let W, H;
    
    // ADMIN VARS
    const CHEAT_CODE = "Roblox13_isme";
    let inputBuffer = "";
    let godMode = false;

    // ASSETS
    const UPGRADES=[
        {id:'burek',name:'Golden Burek',icon:'ðŸ¥',desc:'Spawns rotating golden pastry shields that damage enemies.'},
        {id:'cevapi',name:'Rapid Cevapi',icon:'ðŸŒ­',desc:'Fires delicious grilled meat missiles at nearest targets.'},
        {id:'ajvar',name:'Nuclear Ajvar',icon:'ðŸŒ¶ï¸',desc:'Throws explosive jars of pepper paste dealing AoE damage.'},
        {id:'rakija',name:'Holy Rakija',icon:'ðŸ¾',desc:'Smashes bottles creating purifying fire zones on the ground.'},
        {id:'pyramid',name:'Visoko Beam',icon:'â›°ï¸',desc:'Fires a high-energy piercing triangle beam.'},
        {id:'harmonika',name:'Harmonika',icon:'ðŸŽ¹',desc:'Emits a sonic shockwave that pushes enemies back.', rare:true},
        {id:'serbian',name:'Serbian Attacker',icon:'âš”ï¸',desc:'Summons a Legendary Warrior to distract and crush enemies. 30s Respawn.', legendary:true},
        {id:'speed',name:'Turbo Folk Speed',icon:'âš¡',desc:'Increases Movement Speed by 20%.'},
        {id:'magnet',name:'Super Magnet',icon:'ðŸ§²',desc:'Increases Item Pickup Range by 50%.'},
        {id:'armor',name:'Kevlar Vest',icon:'ðŸ›¡ï¸',desc:'Reduces incoming damage.'},
        {id:'heal',name:'Grandma Soup',icon:'ðŸ²',desc:'Instantly restores 50 HP.'},
        {id:'coffee',name:'Bosnian Coffee',icon:'â˜•',desc:'Reduces all weapon cooldowns by 10%.'},
        {id:'lily',name:'Golden Lily',icon:'âšœï¸',desc:'Increases Critical Hit Chance by 10%.'},
        {id:'vrelo',name:'Vrelo Bosne',icon:'ðŸžï¸',desc:'Regenerates 2 HP per second.'},
        {id:'xp_boost',name:'Big Brain',icon:'ðŸ§ ',desc:'+100% EXP Gain (Stacks)', rare:true}
    ];

    const EVOLUTIONS = [
        {id:'burek_evo',base:'burek',name:'TESLA ORBS',icon:'ðŸ’ ',desc:'EVOLUTION: Rotating explosive energy orbs. High Damage. 5s Cooldown.',legendary:true},
        {id:'pyramid_evo',base:'pyramid',name:'SOLAR FLARE',icon:'â˜€ï¸',desc:'EVOLUTION: Instantly blasts enemies with a massive laser beam.',legendary:true}
    ];

    const ENEMY_INFO = [
        {name:'Promaja', icon:'ðŸ’¨', desc:'The silent killer. A swirling vortex of cold air.'},
        {name:'Yugo 45', icon:'ðŸš—', desc:'Tanky unit. Hard to destroy, hits like a truck.'},
        {name:'Hornet', icon:'ðŸ', desc:'Swarm unit. Fast, aggressive, attacks in groups.'},
        {name:'WARLORD', icon:'ðŸ‘¹', desc:'The Final Boss. Immune to Nuke/Freeze. 5000 HP.'}
    ];

    // GAME VARIABLES
    let gameActive = false;
    let isPaused = false;
    
    let state = { 
        frames:0, gameTime:0, score:0, level:1, xp:0, nextLevelXp:20, xpMult:1, shake:0, 
        enemies:[], particles:[], projectiles:[], beams:[], zones:[], texts:[], gems:[], perks:[], backgroundStars:[], 
        bossActive:false, bossSpawnedOnce:false, flashAlpha:0,
        friendlyUnit: null, serbianCooldown: 0
    };
    let player = { x:0, y:0, hp:100, maxHp:100, speed:6, radius:20, magnetRadius:140, armor:0, regen:0, critChance:0.05, cdr:1.0, facing:0, weapons:{} };

    function resize(){ W=canvas.width=window.innerWidth; H=canvas.height=window.innerHeight; }
    window.addEventListener('resize', resize); resize();

    const keys = {};
    window.addEventListener('keydown', e=>{
        keys[e.key.toLowerCase()]=true;
        if(e.key === "Escape" && gameActive) togglePause();
        
        if(e.key.length === 1) {
            inputBuffer += e.key;
            if(inputBuffer.length > CHEAT_CODE.length) inputBuffer = inputBuffer.slice(-CHEAT_CODE.length);
            if(inputBuffer === CHEAT_CODE){
                openAdmin();
            }
        }
    }); 
    window.addEventListener('keyup', e=>keys[e.key.toLowerCase()]=false);
    
    // REMOVED MOUSE LISTENER FOR ROTATION

    // --- ADMIN FUNCTIONS ---
    function openAdmin(){
        if(!gameActive) return;
        document.getElementById('admin-panel').style.display='flex';
        if(!isPaused) togglePause();
    }
    function closeAdmin(){
        document.getElementById('admin-panel').style.display='none';
        if(isPaused) togglePause();
    }
    function toggleGodMode(){
        godMode = !godMode;
        document.getElementById('god-mode-indicator').style.display = godMode ? 'block' : 'none';
        spawnDamageText(player.x, player.y-60, godMode ? "GOD MODE ON" : "GOD MODE OFF", true);
        closeAdmin();
    }
    function adminLevelUp(){
        state.xp = state.nextLevelXp;
        checkLevelUp();
        closeAdmin();
    }
    function adminKillAll(){
        state.enemies.forEach(e => {
            if(e.type !== 'BOSS') e.takeDamage(99999, true);
        });
        closeAdmin();
    }
    function adminHeal(){
        player.hp = player.maxHp;
        updateHud();
        closeAdmin();
    }
    function adminMaxWeapons(){
        applyUpgrade('burek_evo');
        applyUpgrade('pyramid_evo');
        player.weapons.cevapi.level = 10; player.weapons.cevapi.damage=200;
        player.weapons.ajvar.level = 10; player.weapons.ajvar.damage=500;
        player.weapons.rakija.level = 10; player.weapons.rakija.damage=50;
        player.weapons.harmonika.level = 10; player.weapons.harmonika.range=800;
        player.speed = 10;
        player.magnetRadius = 500;
        closeAdmin();
    }

    // --- MENU SYSTEM ---

    function openInfo(type){
        document.getElementById('info-modal').style.display='flex';
        const content = document.getElementById('info-content');
        const title = document.getElementById('info-title');
        content.innerHTML = '';
        
        if(type === 'armory'){
            title.innerText = "ARMORY PROTOCOLS";
            const allItems = [...UPGRADES, ...EVOLUTIONS];
            allItems.forEach(u => {
                let extraClass = '';
                if(u.rare) extraClass = 'rare';
                if(u.legendary) extraClass = 'legendary';
                content.innerHTML += `
                <div class="info-card ${extraClass}">
                    <div class="info-icon">${u.icon}</div>
                    <div class="info-text"><h3>${u.name}</h3><p>${u.desc}</p></div>
                </div>`;
            });
        } else {
            title.innerText = "THREAT INTEL";
            ENEMY_INFO.forEach(e => {
                content.innerHTML += `
                <div class="info-card">
                    <div class="info-icon">${e.icon}</div>
                    <div class="info-text"><h3>${e.name}</h3><p>${e.desc}</p></div>
                </div>`;
            });
        }
    }

    function closeInfo(){ document.getElementById('info-modal').style.display='none'; }
    
    function startGame(){
        document.getElementById('main-menu').style.display='none';
        resetGame();
    }
    
    function quitGame(){
        gameActive = false;
        document.getElementById('game-over').style.display='none';
        document.getElementById('pause-screen').style.display='none';
        document.getElementById('ui-layer').style.display='none';
        document.getElementById('boss-hud').style.display='none';
        document.getElementById('admin-panel').style.display='none';
        document.getElementById('main-menu').style.display='flex';
    }

    function togglePause(){
        if(!gameActive) return;
        if(document.getElementById('levelup-screen').style.display === 'flex') return;
        isPaused = !isPaused;
        document.getElementById('pause-screen').style.display = isPaused ? 'flex' : 'none';
    }

    function initBackground() {
        state.backgroundStars = [];
        for(let i=0; i<60; i++) { 
            state.backgroundStars.push({
                x: Math.random() * W,
                y: Math.random() * H,
                size: Math.random() * 2 + 1,
                alpha: Math.random() * 0.5 + 0.1
            });
        }
    }

    function resetGame(){
        gameActive = true;
        isPaused = false;
        godMode = false;
        document.getElementById('god-mode-indicator').style.display='none';
        state = { 
            frames:0, gameTime:0, score:0, level:1, xp:0, nextLevelXp:20, xpMult:1, shake:0, 
            enemies:[], particles:[], projectiles:[], beams:[], zones:[], texts:[], gems:[], perks:[], backgroundStars:[],
            bossActive:false, bossSpawnedOnce:false, flashAlpha:0,
            friendlyUnit: null, serbianCooldown: 0
        };
        initBackground();
        
        player = { 
            x:W/2, y:H/2, hp:100, maxHp:100, speed:6, radius:20, magnetRadius:140, armor:0, regen:0, critChance:0.05, cdr:1.0, facing:0, 
            weapons:{
                burek: { level:1, count:1, damage:10, dist:100, speed:0.04, evolved:false, orbs:[] },
                cevapi: { level:1, cooldown:30, baseCool:30, timer:0, damage:15 }, 
                ajvar: { level:0, cooldown:140, baseCool:140, timer:0, damage:80 },
                rakija: { level:0, cooldown:190, baseCool:190, timer:0, damage:4, duration:300 }, 
                pyramid: { level:0, cooldown:110, baseCool:110, timer:0, damage:50, evolved:false },
                harmonika: { level:0, cooldown:186, baseCool:186, timer:0, damage:60, range:500 },
                serbian: { level:0 }
            }
        };

        document.getElementById('game-over').style.display='none';
        document.getElementById('levelup-screen').style.display='none';
        document.getElementById('pause-screen').style.display='none';
        document.getElementById('boss-hud').style.display='none';
        document.getElementById('admin-panel').style.display='none';
        document.getElementById('ui-layer').style.display='flex';
        updateHud();
    }

    // --- GAME ENGINE ---

    function createParticle(x,y,color,type,speedM=1) {
        if(state.particles.length>250) return; 
        const p={x:x,y:y,vx:(Math.random()-0.5)*8*speedM,vy:(Math.random()-0.5)*8*speedM,life:1,decay:0.015+Math.random()*0.03,color:color,size:Math.random()*6+2,type:type};
        if(type==='fire'){p.vy-=2;p.decay=0.04;p.size*=1.5;} 
        if(type==='spark'){p.decay=0.06;p.size=2;p.life=0.8;} 
        if(type==='smoke'){p.vx*=0.3;p.vy*=0.3;p.size=12;p.decay=0.01;p.color='#555';} 
        if(type==='plasma'){p.decay=0.08;p.size=Math.random()*12+4;}
        if(type==='note'){p.decay=0.02;p.size=10;p.vx*=0.5;p.vy=-2;p.char='ðŸŽµ';}
        if(type==='blood'){p.decay=0.03;p.size=Math.random()*5+2;p.color='#aa0000';}
        state.particles.push(p);
    }
    
    function spawnDamageText(x,y,dmg,isCrit){ 
        let v = (typeof dmg === 'string') ? dmg : Math.floor(dmg);
        state.texts.push({x:x+(Math.random()-0.5)*30,y:y,val:v,life:1,color:isCrit?'#00f3ff':'#fff',scale:isCrit?2:1.2, vy:-2}); 
    }
    
    function addShake(amt){ state.shake=Math.min(state.shake+amt,30); }
    
    function calcDamage(base){ 
        let levelBonus = Math.max(0, state.level - 1); 
        let totalBase = base + (levelBonus * 0.5);
        let isCrit = Math.random() < player.critChance; 
        let dmg = totalBase * (isCrit ? 2.0 : 1.0); 
        return {d:dmg, c:isCrit}; 
    }

    class FriendlyUnit {
        constructor() {
            this.x = player.x; this.y = player.y;
            this.durability = 10; 
            this.maxDurability = 10;
            this.radius = 25; this.range = 100;
            this.attackTimer = 0;
            this.dead = false;
            this.immuneTimer = 0; // Cooldown after being hit
        }
        update() {
            if(this.dead) return;
            if(this.immuneTimer > 0) this.immuneTimer--;

            // Movement: Follow player but move towards close enemies
            let target = null; let minDist = 400;
            state.enemies.forEach(e => {
                let d = Math.hypot(e.x - this.x, e.y - this.y);
                if(d < minDist) { minDist = d; target = e; }
            });

            let moveX = 0, moveY = 0;
            if (target && minDist > 40) {
                 let ang = Math.atan2(target.y - this.y, target.x - this.x);
                 moveX = Math.cos(ang); moveY = Math.sin(ang);
            } else {
                 let distToP = Math.hypot(player.x - this.x, player.y - this.y);
                 if(distToP > 100) {
                     let ang = Math.atan2(player.y - this.y, player.x - this.x);
                     moveX = Math.cos(ang); moveY = Math.sin(ang);
                 }
            }
            this.x += moveX * 4; this.y += moveY * 4;

            // Attack Logic (Valk Swing)
            this.attackTimer++;
            if(this.attackTimer > 180) { // 3 seconds
                this.attackTimer = 0;
                addShake(5);
                state.zones.push(new Zone(this.x, this.y, 'valk_swing', 15));
                let dmg = 50 + (5 * state.level);
                state.enemies.forEach(e => {
                    if(Math.hypot(e.x - this.x, e.y - this.y) < 160) {
                        e.takeDamage(dmg, true, 'friendly');
                    }
                });
            }
        }
        draw(cX, cY) {
            if(this.dead) return;
            ctx.save(); ctx.translate(this.x - cX, this.y - cY);
            
            // Draw Blue Shield if immune
            if(this.immuneTimer > 0) {
                 ctx.save();
                 ctx.globalAlpha = 0.4 + Math.sin(state.frames*0.5)*0.2;
                 ctx.fillStyle = '#00f3ff';
                 ctx.beginPath(); ctx.arc(0,0, 35, 0, 6.28); ctx.fill();
                 ctx.strokeStyle = '#fff'; ctx.lineWidth=2; ctx.stroke();
                 ctx.restore();
            }

            // Draw Knight
            ctx.shadowBlur=10; ctx.shadowColor='rgba(0,100,255,0.8)';
            ctx.fillStyle = '#eee'; ctx.beginPath(); ctx.arc(0,0,15,0,6.28); ctx.fill();
            ctx.fillStyle = '#00f'; ctx.fillRect(-10, 5, 20, 15); // Armor
            ctx.fillStyle = '#aaa'; ctx.beginPath(); ctx.arc(0,-5,8,0,6.28); ctx.fill(); // Helm

            // Durability bar
            ctx.fillStyle = 'red'; ctx.fillRect(-20, -35, 40, 6);
            ctx.fillStyle = '#0f0'; ctx.fillRect(-20, -35, 40 * (this.durability/this.maxDurability), 6);
            
            // Durability Text
            ctx.fillStyle = '#fff'; ctx.font='bold 10px Arial'; ctx.textAlign='center';
            ctx.fillText(this.durability + " / " + this.maxDurability, 0, -40);

            ctx.restore();
        }
        takeDamage(amt) {
            // IGNORE damage amount, check timer
            if(this.immuneTimer > 0) {
                // Optional: Show "SHIELDED" occasionally, not every frame to avoid spam
                if(state.frames % 30 === 0) spawnDamageText(this.x, this.y - 40, "SHIELDED", false);
                return; 
            }

            this.durability--;
            this.immuneTimer = 300; // 5 Seconds (60 FPS * 5)
            spawnDamageText(this.x, this.y - 30, "-1 DURABILITY", true);
            createParticle(this.x, this.y, '#00f3ff', 'plasma', 3);

            if(this.durability <= 0) {
                this.dead = true;
                state.serbianCooldown = 1800; // 30s * 60fps
                spawnDamageText(this.x, this.y-50, "UNIT LOST", true);
            }
        }
    }

    class Perk {
        constructor(x,y,type){
            this.x=x; this.y=y; this.type=type; this.bob=0;
            if(type==='health') this.icon='â¤ï¸';
            else if(type==='magnet') this.icon='ðŸ§²';
            else if(type==='nuke') this.icon='â˜¢ï¸';
            else if(type==='freeze') this.icon='â„ï¸';
        }
        update(){
            this.bob+=0.1; 
            const dx=player.x-this.x, dy=player.y-this.y, dist=Math.sqrt(dx*dx+dy*dy);
            if(dist < player.radius + 30){
                if(this.type==='health'){ player.hp = Math.min(player.maxHp, player.hp+50); spawnDamageText(player.x,player.y-50,"HEALED",true); for(let i=0;i<10;i++)createParticle(this.x,this.y,'#f00','spark');}
                if(this.type==='magnet'){ state.gems.forEach(g=>g.vacuum=true); spawnDamageText(player.x,player.y-50,"MAGNETIC",true);}
                if(this.type==='nuke'){ 
                    addShake(30); state.flashAlpha=0.8;
                    state.enemies.forEach(e=>{ 
                        if(!e.dead && e.type !== 'BOSS' && e.type !== 'MINI_BOSS'){ e.takeDamage(9999, true); } 
                        else if(e.type === 'BOSS') { spawnDamageText(e.x, e.y-50, "IMMUNE", false); }
                    }); 
                    spawnDamageText(player.x,player.y-50,"NUKE",true); for(let i=0;i<50;i++)createParticle(player.x,player.y,'#ffaa00','fire',5); 
                }
                if(this.type==='freeze'){ 
                    state.enemies.forEach(e=>{ 
                        if(e.type !== 'BOSS') e.frozen=300; 
                        else spawnDamageText(e.x, e.y-50, "IMMUNE", false);
                    }); 
                    spawnDamageText(player.x,player.y-50,"FROZEN",true); for(let i=0;i<20;i++)createParticle(player.x,player.y,'#00ffff','spark',2); 
                }
                updateHud();
                return true; 
            }
            return false;
        }
        draw(cX,cY){
            let yOff = Math.sin(this.bob)*5;
            ctx.font="30px Arial"; ctx.textAlign="center"; ctx.textBaseline="middle"; 
            ctx.fillText(this.icon, this.x-cX, this.y-cY + yOff);
            ctx.beginPath(); ctx.arc(this.x-cX, this.y-cY+yOff, 20, 0, 6.28);
            ctx.strokeStyle=`rgba(255,255,255,${0.5+Math.sin(this.bob)*0.3})`; ctx.lineWidth=2; ctx.stroke();
        }
    }

    class Gem {
        constructor(x,y, val=0){this.x=x;this.y=y;this.value=val>0?val:(5+(state.level*0.8));this.wobble=Math.random()*6.28;this.vacuum=false;this.size=val>100?10:4;this.color=val>100?'#00f3ff':'#fecb00';}
        update(){
            this.wobble+=0.1; const dx=player.x-this.x, dy=player.y-this.y, dist=Math.sqrt(dx*dx+dy*dy);
            if(this.vacuum || dist<player.magnetRadius){
                let speed = this.vacuum ? 25 : 18;
                this.x+=(dx/dist)*speed;this.y+=(dy/dist)*speed;
            }
            if(dist<player.radius+20){state.xp+=this.value * state.xpMult; checkLevelUp();updateHud();return true;} return false;
        }
        draw(cX,cY){
            ctx.fillStyle=this.color; 
            ctx.beginPath();
            ctx.translate(this.x-cX, this.y-cY);
            ctx.rotate(this.wobble);
            ctx.rect(-this.size/2, -this.size/2, this.size, this.size);
            ctx.fill(); 
            ctx.rotate(-this.wobble); ctx.translate(-(this.x-cX), -(this.y-cY));
        }
    }

    class Beam {
        constructor(x, y, angle) {
            this.x = x; this.y = y; this.angle = angle;
            this.life = 15; this.maxLife = 15; this.length = 1200;
        }
        update() { this.life--; return this.life > 0; }
        draw(cX, cY) {
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            const opacity = this.life / this.maxLife;
            ctx.strokeStyle = `rgba(255, 255, 255, ${opacity})`;
            ctx.lineWidth = 40 * opacity;
            ctx.beginPath();
            ctx.moveTo(this.x - cX, this.y - cY);
            ctx.lineTo((this.x - cX) + Math.cos(this.angle) * this.length, (this.y - cY) + Math.sin(this.angle) * this.length);
            ctx.stroke();
            ctx.strokeStyle = `rgba(255, 100, 0, ${opacity*0.5})`;
            ctx.lineWidth = 120 * opacity;
            ctx.stroke();
            ctx.restore();
        }
    }

    class Projectile {
        constructor(x,y,target,type){
            this.x=x;this.y=y;this.type=type;this.life=150;this.rotation=0;
            this.pierceHitList = [];

            if(type === 'boss_missile') {
                let a = Math.atan2(target.y-y, target.x-x);
                this.speed = 12; // Fast
                this.radius = 15;
                this.vx = Math.cos(a)*this.speed;
                this.vy = Math.sin(a)*this.speed;
                return;
            }

            let a=target?Math.atan2(target.y-y,target.x-x):Math.random()*6.28;
            if(type==='cevapi'){this.speed=14;this.radius=8;} 
            else if(type==='ajvar'){this.speed=8;this.radius=10;}
            else if(type==='rakija'){this.speed=10;this.radius=8;} 
            else if(type==='pyramid'){this.speed=7;this.radius=25;this.life=300;this.pierce=true;}
            this.vx=Math.cos(a)*this.speed; this.vy=Math.sin(a)*this.speed;
        }
        update(){
            this.x+=this.vx;this.y+=this.vy;this.life--;this.rotation+=0.15;
            
            if(this.type === 'boss_missile') {
                 createParticle(this.x, this.y, '#ff003c', 'spark', 0.5);
                 return;
            }

            if(state.frames%2===0){ 
                if(this.type==='pyramid')createParticle(this.x,this.y,'#2ecc71','spark',0.1); 
                if(this.type==='cevapi')createParticle(this.x,this.y,'#8b4513','smoke',0.2); 
            }
            if(this.type==='ajvar'||this.type==='rakija'){ this.vx*=0.96;this.vy*=0.96;this.rotation=this.vx*0.2; if(this.life<100 && Math.abs(this.vx)<1)this.explode(); }
        }
        explode(){
            this.life=0; 
            if(this.type==='ajvar'){ 
                addShake(15); 
                let dmg=calcDamage(player.weapons.ajvar.damage); 
                state.enemies.forEach(e=>{if(Math.hypot(e.x-this.x,e.y-this.y)<150)e.takeDamage(dmg.d, dmg.c)}); 
                for(let i=0;i<40;i++)createParticle(this.x,this.y,'#ff4500','fire',2.5); 
                state.zones.push(new Zone(this.x, this.y, 'blast', 20));
            }
            if(this.type==='rakija'){ state.zones.push(new Zone(this.x,this.y,'fire',player.weapons.rakija.duration)); for(let i=0;i<20;i++)createParticle(this.x,this.y,'#00ffff','fire',1.5); }
        }
        draw(cX,cY){
            ctx.save(); ctx.translate(this.x-cX,this.y-cY); ctx.rotate(this.rotation);
            if(this.type==='boss_missile'){
                 ctx.fillStyle='#000'; ctx.beginPath(); ctx.arc(0,0,8,0,6.28); ctx.fill();
                 ctx.strokeStyle='#ff003c'; ctx.lineWidth=4; ctx.beginPath(); ctx.arc(0,0,8,0,6.28); ctx.stroke();
            }
            else if(this.type==='cevapi'){ 
                for(let i=-1;i<=1;i++) {
                    ctx.fillStyle='#6d4c41'; ctx.beginPath(); ctx.roundRect(-8, i*5-2, 16, 4, 2); ctx.fill();
                    ctx.fillStyle='#3e2723'; ctx.fillRect(-4, i*5-2, 2, 4); ctx.fillRect(2, i*5-2, 2, 4);
                }
            }
            else if(this.type==='ajvar'){ 
                ctx.fillStyle='#c0392b';ctx.beginPath();ctx.arc(0,0,10,0,6.28);ctx.fill();
                ctx.fillStyle='#f1c40f';ctx.beginPath();ctx.arc(0,-6,6,0,6.28);ctx.fill();
                ctx.fillStyle='white';ctx.font="10px Arial";ctx.textAlign="center";ctx.textBaseline="middle";ctx.fillText("HOT",0,2);
            }
            else if(this.type==='rakija'){ 
                ctx.rotate(-this.rotation); ctx.rotate(Math.sin(state.frames*0.2)*0.5); // Bottle swing
                ctx.fillStyle='rgba(200,240,255,0.6)'; ctx.beginPath(); ctx.rect(-5,-10,10,20); ctx.fill();
                ctx.fillStyle='#002395'; ctx.fillRect(-5, -5, 10, 8); // Label
                ctx.fillStyle='#aaa'; ctx.fillRect(-3, -14, 6, 4); // Neck
            }
            else if(this.type==='pyramid'){ 
                ctx.fillStyle='#00ff00';
                ctx.beginPath();ctx.moveTo(0,-20);ctx.lineTo(15,15);ctx.lineTo(-15,15);ctx.fill();
                ctx.fillStyle='#fff';ctx.globalCompositeOperation='lighter';
                ctx.beginPath();ctx.arc(0,0,5,0,6.28);ctx.fill();
            }
            ctx.restore();
        }
    }
    class Zone {
        constructor(x,y,type,dur){this.x=x;this.y=y;this.life=dur;this.maxLife=dur;this.radius=90;this.type=type;if(type==='harmonika')this.radius=150; if(type==='blast') this.radius=120; if(type==='valk_swing') this.radius=160;}
        update(){ 
            this.life--; 
            if(this.type==='blast' || this.type==='valk_swing') return this.life<=0;

            if(this.type==='harmonika') { 
                this.radius+=25; 
                if(this.life%5===0)createParticle(this.x+(Math.random()-0.5)*100, this.y+(Math.random()-0.5)*100, '#fff', 'note'); 
            }
            else if(state.frames%10===0) state.enemies.forEach(e=>{if(Math.hypot(e.x-this.x,e.y-this.y)<this.radius){
                let dmg = calcDamage(player.weapons.rakija.damage);
                e.takeDamage(dmg.d, false, 'zone');
                createParticle(e.x,e.y,'#00ffff','fire',0.5);
            }}); 
            return this.life<=0;
        }
        draw(cX,cY){ 
            if(this.type === 'valk_swing') {
                 // SWORD SPIN ANIMATION
                 ctx.save(); 
                 ctx.translate(this.x-cX, this.y-cY);
                 
                 // Spin calculations
                 let progress = 1 - (this.life / this.maxLife); // 0 to 1
                 let angle = progress * Math.PI * 2; // 360 degrees
                 
                 // Trail effect
                 ctx.beginPath();
                 ctx.arc(0, 0, this.radius, angle - 1, angle, false);
                 ctx.lineWidth = 40;
                 ctx.strokeStyle = `rgba(255, 255, 255, ${0.5 * (1-progress)})`;
                 ctx.stroke();

                 // Draw Sword
                 ctx.rotate(angle);
                 ctx.translate(20, 0); // Offset from center
                 
                 // Blade
                 let grad = ctx.createLinearGradient(0,0, 100, 0);
                 grad.addColorStop(0, '#aaa'); grad.addColorStop(1, '#fff');
                 ctx.fillStyle = grad;
                 ctx.beginPath(); ctx.moveTo(0, -5); ctx.lineTo(120, 0); ctx.lineTo(0, 5); ctx.fill();
                 
                 // Crossguard
                 ctx.fillStyle = '#444'; ctx.fillRect(-5, -15, 10, 30);
                 
                 // Hilt
                 ctx.fillStyle = '#654321'; ctx.fillRect(-25, -4, 20, 8);

                 ctx.restore();
                 return;
            }
            if(this.type === 'blast') {
                 ctx.save(); ctx.translate(this.x-cX, this.y-cY);
                 ctx.globalCompositeOperation = 'lighter';
                 ctx.fillStyle = `rgba(255, 100, 0, ${this.life/20})`;
                 ctx.beginPath(); ctx.arc(0,0,this.radius*(1-this.life/20), 0, 6.28); ctx.fill();
                 ctx.restore();
                 return;
            }
            ctx.save();ctx.translate(this.x-cX,this.y-cY); let p=1+Math.sin(state.frames*0.1)*0.1; ctx.scale(p,p); 
            let g=ctx.createRadialGradient(0,0,10,0,0,this.radius);
            g.addColorStop(0,'rgba(0,255,255,0.4)');g.addColorStop(1,'rgba(0,50,255,0)');
            ctx.globalCompositeOperation='lighter';ctx.fillStyle=g;ctx.beginPath();ctx.arc(0,0,this.radius,0,6.28);ctx.fill();ctx.restore();
        }
    }
    
    class Enemy {
        constructor(overrideType=null, x=null, y=null){
            if(overrideType === 'BOSS' || overrideType === 'MINI_BOSS') {
                 this.type = overrideType;
                 let a=Math.random()*6.28, d=(Math.max(W,H)/2)+200; 
                 if(x!==null && y!==null) { this.x=x; this.y=y; }
                 else { this.x=player.x+Math.cos(a)*d; this.y=player.y+Math.sin(a)*d; }
            } else {
                 if(x !== null && y !== null) {
                     this.x = x; this.y = y;
                 } else {
                     let a=Math.random()*6.28, d=(Math.max(W,H)/2)+150; 
                     this.x=player.x+Math.cos(a)*d; this.y=player.y+Math.sin(a)*d;
                 }
                 this.type = overrideType || 'promaja';
            }
            
            if(this.type==='BOSS') {
                this.hp=5000; this.maxHp=5000; // BUFFED HP
                this.speed=2.5; this.radius=60; 
                this.frozen=0; this.hitFlash=0; this.pushX=0; this.pushY=0;
                this.attackTimer = 150; this.damageCooldown = 0;
            } 
            else if(this.type==='MINI_BOSS') {
                this.hp=800; this.maxHp=800;
                this.speed=2.2; this.radius=45;
                this.frozen=0; this.hitFlash=0; this.pushX=0; this.pushY=0;
                this.attackTimer = 200; this.damageCooldown = 0;
            }
            else {
                if(this.type==='promaja'){this.hp=40+state.level*6;this.speed=2+Math.random();this.radius=22;} 
                else if(this.type==='yugo'){this.hp=200+state.level*20;this.speed=1.5;this.radius=35;this.angle=0;} 
                else if(this.type==='hornet'){this.hp=25+state.level*3;this.speed=4.5;this.radius=15;}
                this.maxHp=this.hp; this.hitFlash=0; this.pushX=0; this.pushY=0; this.frozen=0;
            }
        }
        update(){
            if(this.type === 'BOSS') {
                document.getElementById('boss-bar-fill').style.width = (this.hp/this.maxHp*100)+'%';
            }
            
            if((this.type === 'BOSS' || this.type === 'MINI_BOSS')) {
                if(this.damageCooldown > 0) this.damageCooldown--;
                this.attackTimer--;
                if(this.attackTimer === 30) {
                     spawnDamageText(this.x, this.y - 80, "!!!", false);
                     createParticle(this.x, this.y, '#f00', 'plasma', 5);
                }
                if(this.attackTimer <= 0) {
                    this.attackTimer = this.type==='BOSS' ? 150 : 200; 
                    state.projectiles.push(new Projectile(this.x, this.y, player, 'boss_missile'));
                }
            }

            if(this.frozen > 0) { 
                this.frozen--; 
                if(state.frames%20===0) createParticle(this.x,this.y,'#0ff','spark');
                return;
            }
            
            // TARGETING LOGIC
            let targetX = player.x, targetY = player.y;
            if(state.friendlyUnit && !state.friendlyUnit.dead) {
                let dPlayer = Math.hypot(player.x - this.x, player.y - this.y);
                let dFriendly = Math.hypot(state.friendlyUnit.x - this.x, state.friendlyUnit.y - this.y);
                // Attack friendly if friendly is closer AND player is somewhat far away
                if(dFriendly < dPlayer && dPlayer > 120) {
                    targetX = state.friendlyUnit.x; targetY = state.friendlyUnit.y;
                }

                // --- WALL COLLISION LOGIC ---
                // If this enemy hits the Friendly Unit, STOP moving (Push back)
                let distToFriendly = Math.hypot(state.friendlyUnit.x - this.x, state.friendlyUnit.y - this.y);
                let collisionDist = state.friendlyUnit.radius + this.radius;
                
                if(distToFriendly < collisionDist) {
                    // Calculate push angle
                    let ang = Math.atan2(this.y - state.friendlyUnit.y, this.x - state.friendlyUnit.x);
                    // Push out to edge
                    this.x = state.friendlyUnit.x + Math.cos(ang) * collisionDist;
                    this.y = state.friendlyUnit.y + Math.sin(ang) * collisionDist;
                }
            }

            let dx=targetX-this.x, dy=targetY-this.y, dist=Math.sqrt(dx*dx+dy*dy); this.angle=Math.atan2(dy,dx);
            
            let px=0,py=0; 
            if(this.type !== 'BOSS' && this.type !== 'MINI_BOSS') {
                state.enemies.forEach(o=>{if(o!==this){let ox=this.x-o.x,oy=this.y-o.y,od=Math.sqrt(ox*ox+oy*oy);if(od<this.radius+o.radius){px+=ox/od;py+=oy/od;}}});
            }

            this.x+=(Math.cos(this.angle)*this.speed+px*0.5)+this.pushX; this.y+=(Math.sin(this.angle)*this.speed+py*0.5)+this.pushY; 
            this.pushX*=0.9; this.pushY*=0.9; if(this.hitFlash>0)this.hitFlash--;
            if(this.type==='yugo'&&state.frames%5===0)createParticle(this.x-Math.cos(this.angle)*35,this.y-Math.sin(this.angle)*35,'#333','smoke', 0.5);
        }
        
        takeDamage(a, crit, source){
            if(this.type === 'BOSS' || this.type === 'MINI_BOSS') {
                if(this.damageCooldown > 0) return; 
                this.damageCooldown = 5; 
            }

            this.hp-=a; this.hitFlash=5; spawnDamageText(this.x,this.y-30,a,crit); 
            let c=(this.type==='yugo')?'#000':(this.type==='hornet'?'#bfff00':'#880000'); 
            if(this.type==='BOSS' || this.type==='MINI_BOSS') c='#ff00ff';
            for(let i=0;i<3;i++)createParticle(this.x,this.y,c,'spark');
            
            if(this.hp<=0){ 
                this.dead=true; state.score++; 
                if(this.type==='BOSS'){
                     state.bossActive = false;
                     document.getElementById('boss-hud').style.display='none';
                     addShake(50); state.flashAlpha=1;
                     spawnDamageText(this.x, this.y-100, "WARLORD DEFEATED", true);
                     for(let i=0; i<30; i++) state.gems.push(new Gem(this.x + (Math.random()-0.5)*200, this.y + (Math.random()-0.5)*200, 150));
                } 
                else if(this.type==='MINI_BOSS') {
                     spawnDamageText(this.x, this.y-80, "MINI BOSS DOWN", true);
                     for(let i=0; i<10; i++) state.gems.push(new Gem(this.x + (Math.random()-0.5)*100, this.y + (Math.random()-0.5)*100, 100));
                }
                else {
                     state.gems.push(new Gem(this.x,this.y)); 
                }
                for(let i=0;i<8;i++)createParticle(this.x,this.y,c,'blood',1.5); 
                if(this.type==='yugo' || this.type==='BOSS'){addShake(5);for(let i=0;i<15;i++)createParticle(this.x,this.y,'#f39c12','fire',2);} 
            }
        }
        draw(cX,cY){
            ctx.save(); ctx.translate(this.x-cX,this.y-cY);
            
            if(this.hitFlash>0){ 
                ctx.globalCompositeOperation='lighter'; ctx.fillStyle='#fff';
                ctx.beginPath();ctx.arc(0,0,this.radius,0,6.28);ctx.fill();
            } else {
                if(this.type==='BOSS' || this.type==='MINI_BOSS'){
                    ctx.rotate(state.frames*0.02);
                    let scale = this.type==='BOSS' ? 1 : 0.6;
                    ctx.scale(scale, scale);
                    ctx.strokeStyle='#ff003c'; ctx.lineWidth=4;
                    ctx.beginPath(); ctx.moveTo(-30,-30); ctx.lineTo(30,-30); ctx.lineTo(0,30); ctx.closePath(); ctx.stroke();
                    ctx.fillStyle='#300'; ctx.fill();
                    ctx.fillStyle='#f00'; ctx.beginPath(); ctx.arc(0,0,10,0,6.28); ctx.fill();
                }
                else if(this.type==='promaja'){ 
                    ctx.rotate(state.frames*0.2); // Fast spin
                    ctx.shadowBlur = 10; ctx.shadowColor = 'rgba(200, 255, 255, 0.5)';
                    
                    // Draw visual "wind" spirals
                    ctx.strokeStyle = 'rgba(220, 240, 255, 0.8)';
                    ctx.lineWidth = 2;
                    
                    // Inner spiral
                    ctx.beginPath();
                    ctx.arc(0, 0, 8, 0, 5); // Incomplete circle
                    ctx.stroke();
                    
                    // Middle spiral
                    ctx.rotate(2);
                    ctx.beginPath();
                    ctx.arc(0, 0, 16, 0, 4.5);
                    ctx.stroke();
                    
                    // Outer wisps
                    ctx.rotate(2);
                    ctx.strokeStyle = 'rgba(220, 240, 255, 0.4)';
                    ctx.beginPath();
                    ctx.arc(0, 0, 24, 0, 3);
                    ctx.stroke();
                    
                    // Center "Eye"
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.beginPath(); ctx.arc(0,0,4,0,6.28); ctx.fill();
                }
                else if(this.type==='yugo'){ 
                    ctx.rotate(this.angle);
                    ctx.fillStyle='#800000';
                    ctx.fillRect(-20,-15,40,30);
                    ctx.fillStyle='#300000'; ctx.fillRect(-5,-13,20,26);
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.fillStyle='rgba(255, 255, 200, 0.4)';
                    ctx.beginPath(); ctx.moveTo(20,-10); ctx.lineTo(120,-30); ctx.lineTo(120,30); ctx.lineTo(20,10); ctx.fill();
                    ctx.fillStyle='#ff0'; ctx.fillRect(18,-12,4,6); ctx.fillRect(18,6,4,6);
                }
                else{ 
                    ctx.rotate(this.angle+1.57);
                    ctx.fillStyle='rgba(255,255,255,0.6)'; 
                    let flap = Math.sin(state.frames*0.8)*5;
                    ctx.beginPath(); ctx.ellipse(8+flap, -5, 5, 12, 0.5, 0, 6.28); ctx.fill();
                    ctx.beginPath(); ctx.ellipse(-8-flap, -5, 5, 12, -0.5, 0, 6.28); ctx.fill();
                    ctx.fillStyle='#f1c40f';
                    ctx.beginPath(); ctx.ellipse(0, 0, 8, 14, 0, 0, 6.28); ctx.fill();
                    ctx.fillStyle='#000';
                    ctx.fillRect(-6, -2, 12, 2); ctx.fillRect(-6, 4, 12, 2);
                    ctx.fillStyle='#f00'; ctx.beginPath(); ctx.moveTo(0,14); ctx.lineTo(2,20); ctx.lineTo(-2,20); ctx.fill();
                }
            } 
            if(this.frozen>0){ ctx.fillStyle='rgba(0,255,255,0.4)';ctx.beginPath();ctx.arc(0,0,this.radius+5,0,6.28);ctx.fill();}
            ctx.restore();
        }
    }

    function checkLevelUp(){ 
        if(state.xp>=state.nextLevelXp){
            state.xp-=state.nextLevelXp;
            state.level++;
            player.maxHp += 10; player.hp += 10;
            spawnDamageText(player.x, player.y-60, "+10 HP", true);
            state.nextLevelXp=Math.floor(state.nextLevelXp*1.5);
            isPaused = true;
            generateCards();
        } 
    }
    
    function spawnBoss(){
        if(state.bossActive) return;
        state.bossActive = true;
        state.enemies = state.enemies.filter(e => e.type === 'MINI_BOSS'); // Clear weak mobs but keep mini bosses
        state.flashAlpha = 1.0;
        addShake(50);
        document.getElementById('boss-hud').style.display = 'flex';
        state.enemies.push(new Enemy('BOSS'));
    }

    function updateHud(){ 
        document.getElementById('lvl-display').innerText=state.level; 
        document.getElementById('score-display').innerText=state.score; 
        document.getElementById('xp-fill').style.width=Math.min(100,(state.xp/state.nextLevelXp*100))+'%'; 
        document.getElementById('hp-fill').style.width=Math.max(0,(player.hp/player.maxHp*100))+'%'; 
        
        let m = Math.floor(state.gameTime / 60);
        let s = Math.floor(state.gameTime % 60);
        document.getElementById('timer-display').innerText = 
            (m < 10 ? "0"+m : m) + ":" + (s < 10 ? "0"+s : s);
    }
    
    function gameLoop(){ 
        if(gameActive && !isPaused){ update(); draw(); } 
        else if(!gameActive) {
            ctx.fillStyle='#050510'; ctx.fillRect(0,0,W,H);
            state.backgroundStars.forEach(s => {
                s.x -= 0.2; if(s.x < 0) s.x = W;
                ctx.fillStyle = `rgba(255,255,255,${s.alpha})`; ctx.fillRect(s.x, s.y, s.size, s.size);
            });
        }
        requestAnimationFrame(gameLoop); 
    }
    
    function getClosestEnemy(){ let c=null,m=800; state.enemies.forEach(e=>{let d=Math.hypot(e.x-player.x,e.y-player.y);if(d<m){m=d;c=e;}}); return c; }

    function spawnPerk() {
        let attempts = 0; let valid = false; let px, py;
        while(!valid && attempts < 15) {
            const dist = 300 + Math.random() * 400; 
            const angle = Math.random() * 6.28;
            px = player.x + Math.cos(angle) * dist; py = player.y + Math.sin(angle) * dist;
            let safe = true;
            for(let e of state.enemies) { if(Math.hypot(e.x - px, e.y - py) < e.radius + 40) { safe = false; break; } }
            if(safe) valid = true;
            attempts++;
        }
        if(valid) {
            const types = ['health', 'magnet', 'nuke', 'freeze'];
            state.perks.push(new Perk(px, py, types[Math.floor(Math.random() * types.length)]));
        }
    }

    function lineCircleCollide(px,py, ax,ay, bx,by, r) {
        const vX = bx-ax, vY = by-ay; const wX = px-ax, wY = py-ay;
        const c1 = wX*vX + wY*vY;
        if(c1 <= 0) return Math.hypot(px-ax, py-ay) < r;
        const c2 = vX*vX + vY*vY;
        if(c2 <= c1) return Math.hypot(px-bx, py-by) < r;
        const b = c1/c2; const projX = ax + b*vX, projY = ay + b*vY;
        return Math.hypot(px-projX, py-projY) < r;
    }

    function spawnCircle(type, count) {
        for(let i=0; i<count; i++){
            let angle = (i / count) * 6.28;
            let dist = 800;
            let ex = player.x + Math.cos(angle) * dist;
            let ey = player.y + Math.sin(angle) * dist;
            state.enemies.push(new Enemy(type, ex, ey));
        }
        spawnDamageText(player.x, player.y-100, "âš ï¸ SWARM DETECTED âš ï¸", false);
    }

    function handleWaves() {
        let t = state.gameTime;
        
        // --- PRE 5 MINUTES ---
        if(t < 300) {
            if(t < 60) { // 0-1 min: Promaja (Easy)
                if(state.frames % 50 === 0) state.enemies.push(new Enemy('promaja'));
            } 
            else if(t < 120) { // 1-2 min: Promaja + Hornets
                if(state.frames % 40 === 0) state.enemies.push(new Enemy('promaja'));
                if(state.frames % 90 === 0) state.enemies.push(new Enemy('hornet'));
            }
            else if(t < 180) { // 2-3 min: Yugos start
                if(t === 120 && state.frames % 60 === 0) spawnCircle('promaja', 30); // EVENT
                
                if(state.frames % 30 === 0) state.enemies.push(new Enemy('promaja'));
                if(state.frames % 60 === 0) state.enemies.push(new Enemy('hornet'));
                if(state.frames % 120 === 0) state.enemies.push(new Enemy('yugo'));
            }
            else if(t < 240) { // 3-4 min: High Density
                if(state.frames % 20 === 0) state.enemies.push(new Enemy('promaja'));
                if(state.frames % 40 === 0) state.enemies.push(new Enemy('hornet'));
                if(state.frames % 90 === 0) state.enemies.push(new Enemy('yugo'));
            }
            else if(t < 300) { // 4-5 min: Chaos
                if(t === 240 && state.frames % 60 === 0) spawnCircle('yugo', 20); // EVENT
                if(state.frames % 10 === 0) state.enemies.push(new Enemy(Math.random()<0.5?'promaja':'hornet'));
                if(state.frames % 60 === 0) state.enemies.push(new Enemy('yugo'));
            }
        } 
        // --- 5 MINUTES MARK ---
        else if (t >= 300) {
            if(!state.bossSpawnedOnce) {
                spawnBoss();
                state.bossSpawnedOnce = true;
            }

            // If Boss is alive, reduce spawn rate slightly to focus on Boss, but keep some pressure
            if(state.bossActive) {
                if(state.frames % 100 === 0) state.enemies.push(new Enemy('promaja'));
                if(state.frames % 200 === 0) state.enemies.push(new Enemy('hornet'));
            } 
            // If Boss is DEAD (Endless Mode)
            else {
                // High density spawning returns
                if(state.frames % 15 === 0) state.enemies.push(new Enemy(Math.random()<0.5?'promaja':'hornet'));
                if(state.frames % 50 === 0) state.enemies.push(new Enemy('yugo'));

                // 5% Chance every 10 seconds (600 frames) to spawn Mini Boss
                if(state.frames % 600 === 0) {
                    if(Math.random() < 0.05) {
                        spawnDamageText(player.x, player.y-100, "âš ï¸ ELITE DETECTED âš ï¸", false);
                        addShake(15);
                        state.enemies.push(new Enemy('MINI_BOSS'));
                    }
                }
            }
        }
    }

    function update(){
        if(state.flashAlpha > 0) state.flashAlpha -= 0.02;

        let mx=0,my=0; if(keys['w']||keys['arrowup'])my=-1; if(keys['s']||keys['arrowdown'])my=1; if(keys['a']||keys['arrowleft'])mx=-1; if(keys['d']||keys['arrowright'])mx=1;
        if(mx!==0||my!==0){ 
            let l=Math.sqrt(mx*mx+my*my); 
            player.x+=(mx/l)*player.speed; 
            player.y+=(my/l)*player.speed; 
            player.facing = Math.atan2(my, mx); // AUTO FACE DIRECTION
        }
        // Removed explicit facing update based on mouse here.

        if(player.regen>0 && state.frames%60===0 && player.hp<player.maxHp){ player.hp=Math.min(player.maxHp, player.hp+player.regen); updateHud(); spawnDamageText(player.x,player.y-50,player.regen,true); }

        // UPDATE TIME
        if(state.frames % 60 === 0) {
            state.gameTime++;
            updateHud();
        }

        // SPAWNING
        handleWaves();
        
        if(Math.random() < 0.0008) spawnPerk();

        // SERBIAN ATTACKER LOGIC
        if(player.weapons.serbian.level > 0) {
            if(state.friendlyUnit && !state.friendlyUnit.dead) {
                state.friendlyUnit.update();
            } else {
                if(state.serbianCooldown > 0) {
                    state.serbianCooldown--;
                } else {
                    // Spawn
                    state.friendlyUnit = new FriendlyUnit();
                    createParticle(player.x, player.y, '#fff', 'plasma', 5);
                    spawnDamageText(player.x, player.y-60, "REINFORCEMENTS", true);
                }
            }
        }

        const wc=player.weapons.cevapi; if(wc.level>0){ wc.timer++; if(wc.timer>wc.cooldown){let t=getClosestEnemy();if(t){state.projectiles.push(new Projectile(player.x,player.y,t,'cevapi'));wc.timer=0;}} }
        const wa=player.weapons.ajvar; if(wa.level>0){ wa.timer++; if(wa.timer>wa.cooldown&&state.enemies.length>0){let ts=state.enemies.filter(e=>Math.hypot(e.x-player.x,e.y-player.y)<700);if(ts.length){state.projectiles.push(new Projectile(player.x,player.y,ts[Math.floor(Math.random()*ts.length)],'ajvar'));wa.timer=0;}} }
        const wr=player.weapons.rakija; if(wr.level>0){ wr.timer++; if(wr.timer>wr.cooldown){let t=getClosestEnemy();if(t){state.projectiles.push(new Projectile(player.x,player.y,t,'rakija'));wr.timer=0;}} }
        
        const wp=player.weapons.pyramid; 
        if(wp.level>0){ 
            wp.timer++; 
            if(wp.timer>wp.cooldown){
                let t=getClosestEnemy();
                if(t) {
                    if(wp.evolved) {
                        addShake(15);
                        const angle = Math.atan2(t.y - player.y, t.x - player.x);
                        state.beams.push(new Beam(player.x, player.y, angle));
                        const endX = player.x + Math.cos(angle) * 1200;
                        const endY = player.y + Math.sin(angle) * 1200;
                        state.enemies.forEach(e => {
                            if(lineCircleCollide(e.x, e.y, player.x, player.y, endX, endY, e.radius + 100)) {
                                let dmg = calcDamage(wp.damage); 
                                e.takeDamage(dmg.d, dmg.c, 'beam');
                                createParticle(e.x, e.y, '#fecb00', 'spark', 1.5);
                            }
                        });
                        wp.timer = 0;
                    } else {
                        state.projectiles.push(new Projectile(player.x,player.y,t,'pyramid'));
                        wp.timer=0;
                    }
                }
            } 
        }

        const wh=player.weapons.harmonika; if(wh.level>0){ wh.timer++; if(wh.timer>wh.cooldown){
            addShake(15); state.zones.push(new Zone(player.x,player.y,'harmonika',20));
            state.enemies.forEach(e=>{ 
                let dist=Math.hypot(e.x-player.x,e.y-player.y); 
                if(dist<wh.range){ 
                    let pushP = (e.type === 'BOSS' || e.type === 'MINI_BOSS') ? 0 : 45;
                    let pushA=Math.atan2(e.y-player.y,e.x-player.x); e.pushX=Math.cos(pushA)*pushP; e.pushY=Math.sin(pushA)*pushP; let dmg = calcDamage(wh.damage); e.takeDamage(dmg.d, dmg.c, 'zone'); 
                } 
            });
            wh.timer=0;
        }}

        state.gems=state.gems.filter(g=>!g.update()); state.zones=state.zones.filter(z=>!z.update()); state.perks=state.perks.filter(p=>p.update());
        state.beams=state.beams.filter(b=>b.update());
        
        // PROJECTILES
        state.projectiles.forEach(p=>p.update()); 
        state.projectiles=state.projectiles.filter(p=>{
            if(p.type === 'boss_missile') {
                if(Math.hypot(p.x-player.x, p.y-player.y) < player.radius + 10) {
                    if(!godMode) player.hp -= 40; 
                    addShake(20);
                    spawnDamageText(player.x, player.y-50, godMode ? "BLOCKED" : "40", true);
                    updateHud();
                    return false; 
                }
                // Check collision with Friendly Unit
                if(state.friendlyUnit && !state.friendlyUnit.dead && Math.hypot(p.x - state.friendlyUnit.x, p.y - state.friendlyUnit.y) < state.friendlyUnit.radius + 10) {
                     state.friendlyUnit.takeDamage(40); // Amount ignored, hits counted
                     return false;
                }
                return p.life > 0;
            }

            if(p.type==='pyramid'&&p.life>0){
                state.enemies.forEach(e=>{
                    if(Math.hypot(e.x-p.x,e.y-p.y)<e.radius+p.radius){
                        if(!p.pierceHitList.includes(e)) {
                             let dmg=calcDamage(player.weapons.pyramid.damage); 
                             e.takeDamage(dmg.d, dmg.c, 'projectile');
                             createParticle(e.x,e.y,'#0f0','spark');
                             p.pierceHitList.push(e); 
                        }
                    }
                });
                return true;
            } 
            return p.life>0;
        });

        state.enemies.forEach(e=>{
            e.update();
            let safeDist = player.radius + e.radius - 5;
            
            // Player Collision
            if(!e.frozen && Math.hypot(e.x-player.x,e.y-player.y)<safeDist){ 
                let dmgAmt = (e.type==='BOSS' || e.type==='MINI_BOSS') ? 2 : (Math.max(0.1,((e.type==='yugo'?1:0.4)-(player.armor*0.05))));
                if(!godMode) player.hp-=dmgAmt; 
                addShake(2); updateHud(); if(player.hp<=0){document.getElementById('final-score').innerText=state.score;document.getElementById('game-over').style.display='flex';gameActive=false;} 
            }

            // Friendly Unit Collision (Attack / Damage Logic)
            if(state.friendlyUnit && !state.friendlyUnit.dead && !e.frozen) {
                if(Math.hypot(e.x - state.friendlyUnit.x, e.y - state.friendlyUnit.y) < state.friendlyUnit.radius + e.radius) {
                    // Call takeDamage, amount is irrelevant
                    state.friendlyUnit.takeDamage(1);
                }
            }
            
            const bur=player.weapons.burek; while(bur.orbs.length<bur.count)bur.orbs.push({timer:0});
            for(let b=0;b<bur.count;b++){
                if(bur.orbs[b].timer>0){ bur.orbs[b].timer--; continue; }
                const ang=(state.frames*bur.speed)+(b*6.28/bur.count), bx=player.x+Math.cos(ang)*bur.dist, by=player.y+Math.sin(ang)*bur.dist;
                if(Math.hypot(e.x-bx,e.y-by)<(bur.evolved?60:45)){
                    if(bur.evolved){ let mainDmg = calcDamage(100); let splashDmg = calcDamage(50); e.takeDamage(mainDmg.d, true, 'burek'); createParticle(bx,by,'#00f3ff','plasma',2); addShake(10); state.enemies.forEach(s=>{if(Math.hypot(s.x-bx,s.y-by)<150)s.takeDamage(splashDmg.d, false, 'burek')}); bur.orbs[b].timer=300; }
                    else if(state.frames%6===0){ let dmg=calcDamage(bur.damage); e.takeDamage(dmg.d, dmg.c, 'burek'); createParticle(e.x,e.y,'#e67e22','spark'); }
                }
            }
            state.projectiles.forEach(p=>{if(p.type==='cevapi'&&Math.hypot(e.x-p.x,e.y-p.y)<e.radius+15){let dmg=calcDamage(player.weapons.cevapi.damage); e.takeDamage(dmg.d, dmg.c, 'projectile');p.life=0;}});
        });
        state.enemies=state.enemies.filter(e=>!e.dead && Math.hypot(e.x-player.x,e.y-player.y)<2000);
        state.particles.forEach(p=>{p.x+=p.vx;p.y+=p.vy;p.life-=p.decay;p.vx*=0.95;p.vy*=0.95;}); state.particles=state.particles.filter(p=>p.life>0);
        state.texts.forEach(t=>{t.y+=t.vy; t.vy*=0.9; t.life-=0.02;}); state.texts=state.texts.filter(t=>t.life>0);
        if(state.shake>0)state.shake*=0.9; state.frames++;
    }

    function draw(){
        let cX=player.x-W/2, cY=player.y-H/2; 
        if(state.shake>0.5){cX+=(Math.random()-0.5)*state.shake;cY+=(Math.random()-0.5)*state.shake;}
        
        ctx.fillStyle='#050510'; ctx.fillRect(0,0,W,H); 
        
        state.backgroundStars.forEach(s => {
            let px = (s.x - cX * 0.1) % W; if(px<0) px+=W;
            let py = (s.y - cY * 0.1) % H; if(py<0) py+=H;
            ctx.fillStyle = `rgba(255,255,255,${s.alpha})`;
            ctx.fillRect(px, py, s.size, s.size);
        });

        ctx.strokeStyle='#1a1a2e'; ctx.lineWidth=1; ctx.beginPath();
        let ox=-cX%150, oy=-cY%150; 
        for(let i=ox;i<W;i+=150){ctx.moveTo(i,0);ctx.lineTo(i,H);} 
        for(let i=oy;i<H;i+=150){ctx.moveTo(0,i);ctx.lineTo(W,i);} 
        ctx.stroke();

        state.zones.forEach(z=>z.draw(cX,cY)); 
        state.gems.forEach(g=>g.draw(cX,cY)); 
        state.perks.forEach(p=>p.draw(cX,cY));
        if(state.friendlyUnit) state.friendlyUnit.draw(cX, cY);
        state.enemies.forEach(e=>e.draw(cX,cY)); 
        state.projectiles.forEach(p=>p.draw(cX,cY));
        state.beams.forEach(b=>b.draw(cX,cY));
        
        let pX=player.x-cX, pY=player.y-cY; 
        ctx.save(); ctx.translate(pX,pY); ctx.rotate(player.facing+1.57);
        
        ctx.globalCompositeOperation = 'overlay';
        let grad = ctx.createLinearGradient(0,0,0,-400);
        grad.addColorStop(0, 'rgba(255, 255, 200, 0.2)');
        grad.addColorStop(1, 'rgba(255, 255, 200, 0)');
        ctx.fillStyle = grad;
        ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(-60, -400); ctx.lineTo(60, -400); ctx.fill();
        ctx.globalCompositeOperation = 'source-over';

        ctx.shadowBlur=15; ctx.shadowColor='rgba(254,203,0,0.5)'; 
        ctx.fillStyle='#c0392b'; 
        ctx.beginPath(); ctx.moveTo(-10,0); ctx.lineTo(10,0); ctx.lineTo(15,35); ctx.lineTo(-15,35); ctx.fill();
        ctx.fillStyle='#fecb00';ctx.beginPath();ctx.ellipse(0,0,12,8,0,0,6.28);ctx.fill();
        ctx.fillStyle='#111'; ctx.beginPath(); ctx.arc(0,-2,10,0,6.28); ctx.fill(); 
        ctx.fillStyle='#555'; ctx.fillRect(-4,-2,8,3); 
        ctx.fillStyle='#333'; ctx.fillRect(8, -5, 6, 25);
        ctx.fillStyle='#111'; ctx.fillRect(10, -15, 4, 30);
        
        if(state.frames%5===0 && state.enemies.length>0) {
            ctx.fillStyle='#ffaa00'; ctx.beginPath(); ctx.arc(12, -18, 5, 0, 6.28); ctx.fill();
        }
        ctx.restore();

        const bur=player.weapons.burek;
        for(let i=0;i<bur.count;i++){
            if(!bur.orbs[i] || bur.orbs[i].timer>0) continue;
            let ang=(state.frames*bur.speed)+(i*6.28/bur.count), bx=pX+Math.cos(ang)*bur.dist, by=pY+Math.sin(ang)*bur.dist;
            ctx.save(); ctx.translate(bx,by);
            if(bur.evolved){ 
                ctx.globalCompositeOperation = 'lighter';
                ctx.strokeStyle='#00f3ff';ctx.lineWidth=3;
                ctx.beginPath();ctx.arc(0,0,15,0,6.28);ctx.stroke();
                ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(0,0,8,0,6.28); ctx.fill();
            } else { 
                ctx.rotate(ang*4);
                ctx.strokeStyle='#e67e22';ctx.lineWidth=4;
                ctx.beginPath();
                for(let j=0; j<20; j++) {
                    let r = j; let angle = j * 0.5;
                    ctx.lineTo(Math.cos(angle)*r, Math.sin(angle)*r);
                }
                ctx.stroke();
            } ctx.restore();
        }

        ctx.globalCompositeOperation='lighter'; 
        state.particles.forEach(p=>{
            ctx.globalAlpha=p.life;
            ctx.fillStyle=p.color;
            if(p.type==='note') { ctx.font="15px Arial"; ctx.fillText(p.char, p.x-cX, p.y-cY); }
            else { ctx.beginPath();ctx.arc(p.x-cX,p.y-cY,p.size,0,6.28);ctx.fill(); }
        });
        
        if(state.frames%20===0 && player.weapons.harmonika.level>0){ 
            ctx.strokeStyle='rgba(255,255,255,0.1)';ctx.lineWidth=2;
            ctx.beginPath();ctx.arc(pX,pY,player.weapons.harmonika.range,0,6.28);ctx.stroke(); 
        }
        
        ctx.globalCompositeOperation='source-over'; ctx.globalAlpha=1; ctx.shadowBlur=0;
        
        let lg=ctx.createRadialGradient(W/2,H/2,100,W/2,H/2,Math.max(W,H));
        lg.addColorStop(0,'rgba(0,0,0,0)');
        lg.addColorStop(0.6,'rgba(0,5,20,0.3)');
        lg.addColorStop(1,'rgba(0,0,0,0.9)');
        ctx.fillStyle=lg;ctx.fillRect(0,0,W,H);
        
        if(state.flashAlpha > 0){
            ctx.fillStyle=`rgba(255,255,255,${state.flashAlpha})`;
            ctx.fillRect(0,0,W,H);
        }

        state.texts.forEach(t=>{
            ctx.fillStyle=t.color;
            ctx.font=`bold ${18*t.scale}px Orbitron`;
            ctx.fillText(t.val,t.x-cX,t.y-cY);
        });
    }

    function generateCards(){
        const c=document.getElementById('cards-box'); c.innerHTML=''; document.getElementById('levelup-screen').style.display='flex';
        let pool=UPGRADES.slice(); 
        
        pool = pool.filter(u => !['xp_boost', 'harmonika', 'serbian'].includes(u.id) || Math.random() < 0.30);

        if(player.weapons.burek.evolved || player.weapons.burek.level >= 8) { pool = pool.filter(u => u.id !== 'burek'); }
        if(player.weapons.pyramid.evolved || player.weapons.pyramid.level >= 6) { pool = pool.filter(u => u.id !== 'pyramid'); }
        if(player.weapons.serbian.level > 0) { pool = pool.filter(u => u.id !== 'serbian'); } // One time purchase

        if(player.weapons.burek.level>=8 && !player.weapons.burek.evolved) pool.unshift(EVOLUTIONS.find(e=>e.id==='burek_evo'));
        if(player.weapons.pyramid.level>=6 && !player.weapons.pyramid.evolved) pool.unshift(EVOLUTIONS.find(e=>e.id==='pyramid_evo'));

        if(player.weapons.burek.evolved) pool.push({id:'supercharge_burek', name:'SUPERCHARGE: TESLA', icon:'âš¡', desc:'+20% Damage for Tesla Orbs.', supercharge:true});
        if(player.weapons.pyramid.evolved) pool.push({id:'supercharge_pyramid', name:'SUPERCHARGE: SOLAR', icon:'ðŸ”¥', desc:'+20% Damage for Solar Flare.', supercharge:true});

        // Add Serbian Attacker with 1% chance
        if(Math.random() < 0.01 && player.weapons.serbian.level === 0) {
            pool.unshift(UPGRADES.find(u => u.id === 'serbian'));
        }

        let opts=(pool.length>3 && !pool[0].legendary) ? pool.sort(()=>0.5-Math.random()).slice(0,3) : pool.slice(0,3);
        
        opts.forEach(o=>{
            const el=document.createElement('div'); el.className='card'; 
            if(o.legendary) el.classList.add('legendary');
            if(o.rare) el.classList.add('rare');
            if(o.supercharge) { el.classList.add('legendary'); el.style.borderColor='var(--danger)'; }
            
            el.innerHTML=`<div class="card-level">${['burek','cevapi','ajvar','rakija','pyramid','harmonika'].includes(o.id)?'Lvl '+(player.weapons[o.id].level+1):''}</div><div class="card-icon">${o.icon}</div><div class="card-name">${o.name}</div><div class="card-desc">${o.desc}</div>`;
            el.onclick=()=>{applyUpgrade(o.id);}; c.appendChild(el);
        });
    }

    function applyUpgrade(id){
        if(id==='burek_evo'){player.weapons.burek.evolved=true;player.weapons.burek.speed=0.06;player.weapons.burek.dist=140;player.weapons.burek.count+=1;}
        if(id==='pyramid_evo'){player.weapons.pyramid.evolved=true;player.weapons.pyramid.damage=400;player.weapons.pyramid.baseCool=180;player.weapons.pyramid.timer=0;}
        
        if(id==='supercharge_burek'){ player.weapons.burek.damage *= 1.2; spawnDamageText(player.x, player.y-50, "POWER UP!", true); }
        if(id==='supercharge_pyramid'){ player.weapons.pyramid.damage *= 1.2; spawnDamageText(player.x, player.y-50, "POWER UP!", true); }

        if(id==='burek'){player.weapons.burek.count++;player.weapons.burek.level++;player.weapons.burek.speed+=0.01;}
        
        if(id==='cevapi'){
            player.weapons.cevapi.level++;
            if(player.weapons.cevapi.level === 2) { player.weapons.cevapi.damage = 25; player.weapons.cevapi.baseCool *= 0.85; } else { player.weapons.cevapi.damage += 10; player.weapons.cevapi.baseCool *= 0.85; }
        }

        if(id==='ajvar'){
            player.weapons.ajvar.level++;
            if(player.weapons.ajvar.level>1){player.weapons.ajvar.baseCool*=0.85;player.weapons.ajvar.damage+=20;}
        }
        if(id==='rakija'){
            player.weapons.rakija.level++;
            if(player.weapons.rakija.level>1){player.weapons.rakija.baseCool*=0.85;player.weapons.rakija.damage+=2;}
        }
        if(id==='pyramid'){
            player.weapons.pyramid.level++; 
            if(player.weapons.pyramid.level>1){player.weapons.pyramid.baseCool*=0.85;player.weapons.pyramid.damage+=15;}
        }
        if(id==='harmonika'){
            player.weapons.harmonika.level++;
            if(player.weapons.harmonika.level>1){player.weapons.harmonika.baseCool*=0.80;player.weapons.harmonika.range+=40;player.weapons.harmonika.damage+=20;}
        }

        if(id==='serbian'){
            player.weapons.serbian.level = 1;
            state.friendlyUnit = new FriendlyUnit();
        }
        
        if(id==='speed')player.speed*=1.15; if(id==='magnet')player.magnetRadius+=50; if(id==='armor')player.armor+=1.5; if(id==='heal')player.hp=Math.min(player.maxHp,player.hp+50);
        if(id==='coffee')player.cdr*=0.9; if(id==='lily')player.critChance+=0.10; if(id==='vrelo')player.regen+=2;
        
        if(id==='xp_boost') state.xpMult += 1; 

        ['cevapi','ajvar','rakija','pyramid','harmonika'].forEach(w=>{ player.weapons[w].cooldown = player.weapons[w].baseCool * player.cdr; });

        if(document.getElementById('levelup-screen').style.display === 'flex'){
             document.getElementById('levelup-screen').style.display='none'; 
             updateHud(); 
             isPaused=false;
        }
    }
    gameLoop();
</script>
</body>
</html>
