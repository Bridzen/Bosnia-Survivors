<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bosnian Survivors: ROSTILJ UPDATE - PLATINUM FIX</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@500;700&display=swap');

        :root {
            --bosnia-blue: #002395;
            --bosnia-yellow: #fecb00;
            --neon-cyan: #00f3ff;
            --rare-blue: #4d80ff;
            --platinum: #e5e4e2;
            --legendary: #d000ff;
            --danger: #ff003c;
            --dark: #050510;
            --fire-orange: #ff5e00;
            --medic-green: #00ff41;
            --blood-red: #8a0303;
            --holy-white: #ffffff;
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--dark);
            font-family: 'Rajdhani', sans-serif;
            color: white;
            user-select: none;
        }

        #crt-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 9999;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.1) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.03), rgba(0, 255, 0, 0.01), rgba(0, 0, 255, 0.03));
            background-size: 100% 4px, 6px 100%;
        }

        #ui-layer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            padding: 20px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            z-index: 50;
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            pointer-events: none;
            width: 100%;
        }

        .stat-box {
            background: rgba(0, 10, 30, 0.6);
            backdrop-filter: blur(4px);
            border: 1px solid rgba(0, 243, 255, 0.2);
            border-bottom: 3px solid var(--bosnia-yellow);
            padding: 8px 25px;
            transform: skewX(-15deg);
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .stat-content {
            transform: skewX(15deg);
            text-align: center;
        }

        .label {
            font-size: 10px;
            color: var(--neon-cyan);
            text-transform: uppercase;
            letter-spacing: 2px;
            font-family: 'Orbitron';
            margin-bottom: 2px;
            opacity: 0.8;
        }

        .value {
            font-size: 24px;
            font-weight: 700;
            color: #fff;
            text-shadow: 0 0 5px var(--neon-cyan);
        }

        /* TIMER */
        #timer-box {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%) skewX(-15deg);
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid var(--bosnia-yellow);
            padding: 5px 30px;
            z-index: 60;
        }

        #timer-display {
            font-family: 'Orbitron';
            font-size: 32px;
            color: var(--bosnia-yellow);
            transform: skewX(15deg);
            letter-spacing: 3px;
        }

        /* HP BAR */
        #hp-container {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: 500px;
            text-align: center;
            pointer-events: none;
        }

        #hp-bar-frame {
            width: 100%;
            height: 16px;
            background: rgba(0, 0, 0, 0.8);
            transform: skewX(-20deg);
            border: 1px solid #555;
            overflow: hidden;
            position: relative;
        }

        #hp-fill {
            height: 100%;
            width: 100%;
            background: linear-gradient(90deg, #ff003c, #ff5e00);
            transition: width 0.1s linear;
        }

        /* BOSS HUD */
        #boss-hud {
            display: none;
            position: fixed;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            width: 600px;
            z-index: 60;
            flex-direction: column;
            align-items: center;
        }

        #boss-name {
            font-family: 'Orbitron';
            font-size: 28px;
            color: var(--danger);
            margin-bottom: 5px;
            letter-spacing: 8px;
            font-weight: 900;
            text-shadow: 0 0 10px black;
        }

        #boss-bar-bg {
            width: 100%;
            height: 12px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid var(--danger);
            transform: skewX(-20deg);
            overflow: hidden;
        }

        #boss-bar-fill {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #800000, #ff003c);
            transition: width 0.1s;
        }

        /* BOSS CAPTION (BOTTOM) */
        #boss-caption {
            position: fixed;
            bottom: 100px;
            width: 100%;
            text-align: center;
            pointer-events: none;
            font-family: 'Orbitron';
            font-size: 30px;
            color: var(--neon-cyan);
            text-shadow: 0 0 10px var(--neon-cyan);
            letter-spacing: 5px;
            opacity: 0;
            transition: opacity 0.5s;
            z-index: 999;
        }

        #pause-btn {
            pointer-events: auto;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid var(--neon-cyan);
            color: var(--neon-cyan);
            width: 40px;
            height: 40px;
            border-radius: 0;
            transform: skewX(-10deg);
            font-family: 'Orbitron';
            font-weight: bold;
            cursor: pointer;
            margin-left: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: 0.2s;
        }

        #pause-btn:hover {
            background: var(--neon-cyan);
            color: black;
        }

        .xp-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background: #000;
            z-index: 100;
            pointer-events: none;
        }

        #xp-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, var(--bosnia-blue), var(--neon-cyan));
            transition: width 0.2s;
        }

        .screen-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(5, 5, 10, 0.95);
            z-index: 2000;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            overflow-y: auto;
        }

        /* MUSICAL OVERLAY */
        #musical-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 9100;
            pointer-events: none;
        }

        .note-anim {
            position: absolute;
            font-size: 80px;
            animation: noteFloat 2s ease-out forwards;
            opacity: 0;
            color: var(--neon-cyan);
            text-shadow: 0 0 20px blue;
        }

        @keyframes noteFloat {
            0% {
                transform: translate(0, 0) rotate(0deg);
                opacity: 0;
            }

            20% {
                opacity: 1;
            }

            100% {
                transform: translate(var(--tx), var(--ty)) rotate(var(--rot));
                opacity: 0;
            }
        }

        /* MAIN MENU */
        #main-menu {
            display: flex;
            background: radial-gradient(circle at center, rgba(10, 20, 40, 0.9), #000), url('https://img.freepik.com/free-vector/blue-futuristic-networking-technology-background-vector_53876-114068.jpg');
            background-size: cover;
            background-position: center;
        }

        .title-container {
            position: relative;
            text-align: center;
            animation: floatTitle 3s ease-in-out infinite;
            z-index: 10;
        }

        .title-glitch {
            font-family: 'Orbitron';
            font-weight: 900;
            font-size: 90px;
            color: white;
            text-shadow: 0 0 10px var(--bosnia-blue), 4px 4px 0px #000, -2px -2px 0 var(--bosnia-yellow);
            letter-spacing: 5px;
            margin: 0;
            line-height: 0.9;
        }

        .subtitle {
            font-family: 'Rajdhani';
            font-weight: 700;
            letter-spacing: 15px;
            color: var(--neon-cyan);
            margin-top: 10px;
            font-size: 32px;
            text-shadow: 0 0 20px var(--bosnia-blue);
            animation: pulseText 2s infinite alternate;
        }

        #balance-scale-bg {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 400px;
            opacity: 0.15;
            color: var(--bosnia-yellow);
            animation: balanceRock 5s ease-in-out infinite;
            pointer-events: none;
            z-index: 1;
            filter: drop-shadow(0 0 20px var(--bosnia-yellow));
        }

        @keyframes balanceRock {
            0% {
                transform: translate(-50%, -50%) rotate(-10deg);
            }

            50% {
                transform: translate(-50%, -50%) rotate(10deg);
            }

            100% {
                transform: translate(-50%, -50%) rotate(-10deg);
            }
        }

        @keyframes floatTitle {

            0%,
            100% {
                transform: translateY(0);
            }

            50% {
                transform: translateY(-10px);
            }
        }

        @keyframes pulseText {
            0% {
                opacity: 0.7;
                text-shadow: 0 0 10px var(--neon-cyan);
            }

            100% {
                opacity: 1;
                text-shadow: 0 0 30px var(--bosnia-blue);
            }
        }

        .menu-btn {
            background: linear-gradient(90deg, rgba(0, 0, 0, 0.8), rgba(0, 35, 149, 0.6));
            border: 1px solid var(--bosnia-blue);
            border-left: 4px solid var(--bosnia-yellow);
            color: white;
            padding: 20px 60px;
            margin: 15px;
            font-size: 24px;
            font-family: 'Orbitron';
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 4px;
            width: 350px;
            transition: 0.3s;
            z-index: 10;
            clip-path: polygon(15px 0, 100% 0, 100% calc(100% - 15px), calc(100% - 15px) 100%, 0 100%, 0 15px);
            position: relative;
            overflow: hidden;
        }

        .menu-btn:hover {
            background: var(--bosnia-yellow);
            color: black;
            border-color: white;
            font-weight: 900;
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(254, 203, 0, 0.4);
        }

        /* ADMIN */
        #admin-panel {
            display: none;
            border: 2px solid var(--danger);
            background: rgba(0, 0, 0, 0.95);
            box-shadow: 0 0 50px rgba(255, 0, 0, 0.2);
            flex-direction: column;
            align-items: center;
        }

        .admin-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            width: 600px;
            padding: 20px;
        }

        .admin-btn {
            background: #111;
            border: 1px solid #555;
            color: white;
            padding: 15px;
            cursor: pointer;
            font-family: 'Orbitron';
            text-transform: uppercase;
            transition: 0.2s;
            font-size: 14px;
        }

        .admin-btn:hover {
            background: var(--danger);
            color: white;
            border-color: white;
            box-shadow: 0 0 10px var(--danger);
        }

        .admin-header {
            font-family: 'Orbitron';
            color: var(--danger);
            font-size: 30px;
            margin: 20px 0;
            text-shadow: 0 0 10px red;
            letter-spacing: 5px;
            text-align: center;
            width: 100%;
            border-bottom: 1px solid #333;
            padding-bottom: 10px;
        }

        #admin-augment-select {
            background: #000;
            color: var(--neon-cyan);
            border: 1px solid var(--neon-cyan);
            padding: 10px;
            width: 100%;
            font-family: 'Rajdhani';
            font-size: 16px;
            margin-bottom: 10px;
        }

        .spawn-control {
            display: flex;
            gap: 5px;
            grid-column: span 2;
        }

        .spawn-select {
            flex-grow: 1;
            background: #000;
            color: #fff;
            padding: 10px;
            font-family: Orbitron;
            border: 1px solid #555;
        }

        /* BRAXTON CUTSCENE */
        #braxton-cutscene {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 9000;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        #taco-anim {
            font-size: 200px;
            animation: tacoDrop 2s ease-out forwards;
        }

        @keyframes tacoDrop {
            0% {
                transform: translateY(-100vh) rotate(0deg);
                opacity: 0;
            }

            70% {
                transform: translateY(0) rotate(360deg);
                opacity: 1;
            }

            85% {
                transform: translateY(-20px) rotate(360deg);
            }

            100% {
                transform: translateY(0) rotate(360deg);
            }
        }

        .dialogue-box {
            margin-top: 50px;
            background: #000;
            border: 4px solid #2ecc71;
            padding: 20px;
            width: 60%;
            color: #2ecc71;
            font-family: 'Orbitron';
            font-size: 24px;
            text-align: center;
            display: none;
            box-shadow: 0 0 20px #2ecc71;
        }

        /* CLOCK INTRO */
        #clock-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 9200;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .clock-face {
            width: 300px;
            height: 300px;
            border: 10px solid var(--bosnia-yellow);
            border-radius: 50%;
            position: relative;
            box-shadow: 0 0 50px var(--bosnia-yellow);
            background: #000;
        }

        .clock-center {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            background: var(--danger);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            z-index: 5;
        }

        .clock-hand {
            position: absolute;
            bottom: 50%;
            left: 50%;
            transform-origin: bottom center;
            background: white;
            border-radius: 5px;
            transition: transform 3s cubic-bezier(0.1, 0.7, 1.0, 0.1);
        }

        .hand-hour {
            width: 8px;
            height: 80px;
            margin-left: -4px;
            z-index: 3;
            background: #fff;
            transform: rotate(0deg);
        }

        .hand-minute {
            width: 4px;
            height: 120px;
            margin-left: -2px;
            z-index: 4;
            background: var(--neon-cyan);
            transform: rotate(0deg);
        }

        .clock-text {
            margin-top: 50px;
            font-family: 'Orbitron';
            font-size: 50px;
            color: var(--danger);
            letter-spacing: 10px;
            opacity: 0;
            transition: opacity 2s;
            text-shadow: 0 0 20px red;
        }

        #pause-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            width: 80%;
            max-width: 600px;
            margin-bottom: 20px;
            max-height: 400px;
            overflow-y: auto;
        }

        .pause-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 10px;
            border: 1px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .pause-item span {
            font-family: 'Rajdhani';
            font-size: 18px;
            color: var(--bosnia-yellow);
        }

        /* SCROLL FIXES APPLIED HERE */
        .cards-container {
            display: flex;
            gap: 25px;
            margin-top: 30px;
            flex-wrap: wrap;
            justify-content: center;
            max-width: 1200px;
            perspective: 1000px;
            max-height: 65vh;
            /* Prevents overflow off screen */
            overflow-y: auto;
            /* Enables scrollbar */
            padding: 10px;
            /* Space for scrollbar */
        }

        .card {
            background: linear-gradient(170deg, #0a0a15 0%, #101025 100%);
            border: 1px solid #333;
            width: 220px;
            min-height: 380px;
            border-radius: 2px;
            padding: 20px;
            cursor: pointer;
            transition: 0.3s;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.8);
            position: relative;
            overflow: hidden;
            clip-path: polygon(20px 0, 100% 0, 100% calc(100% - 20px), calc(100% - 20px) 100%, 0 100%, 0 20px);
            opacity: 0;
            animation: cardFadeIn 0.5s forwards;
            margin-bottom: 20px;
        }

        @keyframes cardFadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .card:hover {
            transform: translateY(-10px);
            border-color: var(--bosnia-yellow);
            z-index: 10;
        }

        .card:hover .card-icon {
            transform: scale(1.1);
        }

        .card::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background: var(--bosnia-yellow);
        }

        .card.rare {
            border-color: var(--rare-blue);
            background: linear-gradient(170deg, #051025 0%, #001530 100%);
        }

        .card.rare::after {
            background: var(--rare-blue);
        }

        .card.rare .card-name {
            color: var(--rare-blue);
        }

        .card.legendary {
            border-color: var(--legendary);
            background: linear-gradient(170deg, #1a0025 0%, #100020 100%);
        }

        .card.legendary::after {
            background: var(--legendary);
        }

        .card.legendary .card-name {
            color: var(--legendary);
            text-shadow: 0 0 5px var(--legendary);
        }

        .card.platinum {
            border-color: var(--platinum);
            background: linear-gradient(170deg, #202020 0%, #101010 100%);
            box-shadow: 0 0 20px rgba(229, 228, 226, 0.2);
        }

        .card.platinum::after {
            background: var(--platinum);
        }

        .card.platinum .card-name {
            color: var(--platinum);
            text-shadow: 0 0 5px white;
        }

        .card-icon {
            font-size: 60px;
            margin: 30px 0;
            transition: 0.3s;
            filter: drop-shadow(0 0 5px rgba(255, 255, 255, 0.2));
        }

        .card-name {
            font-family: 'Orbitron';
            font-weight: 900;
            color: #fff;
            margin-bottom: 10px;
            font-size: 18px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .card-desc {
            font-size: 13px;
            color: #99a;
            line-height: 1.5;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            padding-top: 10px;
            width: 100%;
        }

        .card-level {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 10px;
            color: #555;
            font-family: 'Orbitron';
            font-weight: bold;
        }

        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            max-width: 1100px;
            width: 90%;
            padding: 20px;
        }

        .info-card {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            gap: 15px;
            position: relative;
            overflow: hidden;
        }

        .info-card.rare {
            border: 1px solid var(--rare-blue);
            box-shadow: inset 0 0 20px rgba(77, 128, 255, 0.1);
        }

        .info-card.legendary {
            border: 1px solid var(--legendary);
            box-shadow: inset 0 0 20px rgba(208, 0, 255, 0.1);
        }

        .info-icon {
            font-size: 30px;
            min-width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 50%;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .info-text h3 {
            margin: 0 0 5px 0;
            color: var(--bosnia-yellow);
            font-family: 'Orbitron';
            font-size: 16px;
            letter-spacing: 1px;
        }

        .info-text p {
            margin: 0;
            color: #aaa;
            font-size: 13px;
            line-height: 1.4;
        }

        .close-btn {
            position: absolute;
            top: 30px;
            right: 30px;
            background: none;
            border: none;
            color: white;
            font-size: 40px;
            cursor: pointer;
            font-family: 'Rajdhani';
            line-height: 20px;
        }

        .close-btn:hover {
            color: var(--danger);
        }

        .restart-btn {
            background: var(--danger);
            color: white;
            border: none;
            padding: 20px 60px;
            font-size: 24px;
            font-weight: 900;
            cursor: pointer;
            font-family: 'Orbitron';
            clip-path: polygon(10px 0, 100% 0, 100% calc(100% - 10px), calc(100% - 10px) 100%, 0 100%, 0 10px);
            transition: 0.2s;
            box-shadow: 0 0 15px var(--danger);
            margin-top: 30px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .restart-btn:hover {
            transform: scale(1.05);
            background: white;
            color: var(--danger);
        }

        /* CRATE SCREEN */
        #crate-screen {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(5, 5, 10, 0.98);
            z-index: 3000;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            overflow-y: auto;
        }

        #crate-anim {
            font-size: 150px;
            margin-bottom: 20px;
            transition: transform 0.1s;
        }

        /* Crate Animation Classes */
        .crate-drop {
            animation: crateDropIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
        }

        @keyframes crateDropIn {
            0% {
                transform: translateY(-500px) scale(0.1);
                opacity: 0;
            }

            100% {
                transform: translateY(0) scale(1);
                opacity: 1;
            }
        }

        .crate-shake {
            animation: crateShakeViolent 0.5s linear infinite;
        }

        @keyframes crateShakeViolent {
            0% {
                transform: translate(0, 0) rotate(0deg);
            }

            25% {
                transform: translate(-10px, 10px) rotate(-10deg);
            }

            50% {
                transform: translate(10px, -10px) rotate(10deg);
            }

            75% {
                transform: translate(-10px, -10px) rotate(-10deg);
            }

            100% {
                transform: translate(0, 0) rotate(0deg);
            }
        }

        #white-flash {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: white;
            opacity: 0;
            pointer-events: none;
            z-index: 3001;
            transition: opacity 0.5s;
        }

        .claim-btn {
            background: var(--bosnia-yellow);
            color: black;
            border: none;
            padding: 15px 40px;
            font-family: 'Orbitron';
            font-weight: 900;
            font-size: 24px;
            cursor: pointer;
            margin-top: 30px;
            box-shadow: 0 0 20px var(--bosnia-yellow);
            animation: pulseBtn 1s infinite alternate;
            opacity: 0;
            transition: opacity 0.5s;
            margin-bottom: 50px;
        }

        @keyframes pulseBtn {
            0% {
                transform: scale(1);
            }

            100% {
                transform: scale(1.1);
            }
        }

        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }
    </style>
</head>

<body>

    <div id="crt-overlay"></div>
    <div class="xp-container">
        <div id="xp-fill"></div>
    </div>
    <div id="musical-overlay"></div>

    <!-- BOSS HUD -->
    <div id="boss-hud">
        <div id="boss-name">TURBO FOLK WARLORD</div>
        <div id="boss-bar-bg">
            <div id="boss-bar-fill"></div>
        </div>
    </div>

    <div id="boss-caption"></div>

    <!-- BRAXTON CUTSCENE -->
    <div id="braxton-cutscene">
        <div id="taco-anim">üåÆ</div>
        <div class="dialogue-box" id="braxton-dialogue"></div>
    </div>

    <!-- CLOCK INTRO -->
    <div id="clock-overlay">
        <div class="clock-face">
            <div class="clock-center"></div>
            <div class="clock-hand hand-hour" id="hand-hour"></div>
            <div class="clock-hand hand-minute" id="hand-minute"></div>
        </div>
        <div class="clock-text" id="clock-text">TE≈ΩINA PRESUDE</div>
    </div>

    <!-- CRATE LOOT SCREEN -->
    <div id="crate-screen">
        <div id="white-flash"></div>
        <div id="crate-anim">üì¶</div>
        <h1 id="crate-title"
            style="font-family:'Orbitron'; color:var(--bosnia-yellow); text-shadow:0 0 20px var(--bosnia-yellow); opacity:0; transition:opacity 0.5s;">
            SUPPLY DROP</h1>
        <div class="cards-container" id="crate-cards"></div>
        <button class="claim-btn" id="crate-claim-btn" onclick="claimCrateRewards()">CLAIM ALL</button>
    </div>

    <!-- MAIN MENU -->
    <div id="main-menu" class="screen-overlay" style="display:flex;">
        <div id="balance-scale-bg">‚öñÔ∏è</div>
        <div class="title-container">
            <h1 class="title-glitch">BOSNIAN<br><span style="color:var(--bosnia-yellow)">SURVIVORS</span></h1>
            <div class="subtitle">ROSTILJ UPDATE</div>
        </div>
        <div style="height:60px;"></div>
        <button class="menu-btn" onclick="startGame()">DEPLOY</button>
        <button class="menu-btn" onclick="openInfo('armory')">ARMORY</button>
        <button class="menu-btn" onclick="openInfo('intel')">INTEL</button>
    </div>

    <!-- INFO MODAL -->
    <div id="info-modal" class="screen-overlay">
        <button class="close-btn" onclick="closeInfo()">√ó</button>
        <h1 id="info-title"
            style="font-family:'Orbitron'; color:var(--bosnia-yellow); margin-top:50px; font-size: 40px; text-shadow: 0 0 10px var(--bosnia-yellow);">
            DATA</h1>
        <div id="info-content" class="info-grid"></div>
    </div>

    <!-- ADMIN PANEL -->
    <div id="admin-panel" class="screen-overlay">
        <div class="admin-header">/// DEBUG CONTROL ///</div>
        <div class="admin-grid" style="grid-template-columns: 1fr 1fr; width: 400px; margin-bottom: 20px;">
            <label style="color:white; font-family:'Orbitron'; font-size:12px;">FORCE AUGMENTATION</label>
            <div style="display:flex; gap:10px;">
                <select id="admin-augment-select"></select>
                <button class="admin-btn" style="padding:10px;" onclick="adminForceUpgrade()">ADD</button>
            </div>
        </div>
        <div class="admin-grid">
            <button class="admin-btn" onclick="toggleGodMode()">Toggle God Mode</button>
            <button class="admin-btn" onclick="adminLevelUp()">+1 Level</button>
            <button class="admin-btn" onclick="adminKillAll()">Kill All Enemies</button>
            <button class="admin-btn" onclick="adminToggleSpawns()">Toggle Spawns</button>
            <button class="admin-btn" onclick="adminCycleLuck()">CYCLE LUCK: <span
                    id="admin-luck-val">1x</span></button>
            <button class="admin-btn" onclick="adminHeal()">Full Heal</button>

            <div class="spawn-control">
                <select id="spawn-enemy-select" class="spawn-select">
                    <option value="promaja">Promaja</option>
                    <option value="yugo">Yugo</option>
                    <option value="hornet">Hornet</option>
                    <option value="snajper">Snajper</option>
                    <option value="medic">Medic</option>
                    <option value="lovac">Krvavi Lovac</option>
                    <option value="jurisnik">Svjetlosni Juri≈°nik</option>
                    <option value="NOLAN">Nolan-ite</option>
                    <option value="MINI_BOSS">Mini Boss</option>
                    <option value="BOSS">Warlord</option>
                    <option value="BRAXTON">Braxton-inite</option>
                    <option value="POLYRHYTHM">The Polyrhythm</option>
                    <option value="TEZINA">Te≈æina Presude</option>
                </select>
                <button class="admin-btn" style="padding:10px; width:100px;" onclick="adminSpawnEnemy()">SPAWN</button>
            </div>
        </div>
        <button class="menu-btn" style="width:200px; margin-top:20px;" onclick="closeAdmin()">RESUME</button>
    </div>

    <!-- PAUSE MENU -->
    <div id="pause-screen" class="screen-overlay">
        <h1 style="font-family:'Orbitron'; font-size:60px; color:var(--neon-cyan);">PAUSED</h1>
        <div id="pause-stats"></div>
        <button class="menu-btn" onclick="togglePause()">RESUME</button>
        <button class="menu-btn" onclick="quitGame()">MAIN MENU</button>
    </div>

    <!-- EVOLUTION OVERLAY -->
    <div id="evolution-overlay" class="screen-overlay"></div>

    <!-- GAME UI -->
    <div id="ui-layer" style="display:none;">
        <div id="timer-box">
            <div id="timer-display">00:00</div>
        </div>

        <div class="hud-top">
            <div class="stat-box">
                <div class="stat-content">
                    <div class="label">Threat Level</div>
                    <div class="value" style="color:var(--bosnia-yellow)" id="lvl-display">1</div>
                </div>
            </div>
            <div style="display:flex;">
                <div class="stat-box">
                    <div class="stat-content">
                        <div class="label">Kills</div>
                        <div class="value" style="color:#fff" id="score-display">0</div>
                    </div>
                </div>
                <button id="pause-btn" onclick="togglePause()">||</button>
            </div>
        </div>

        <div id="hp-container">
            <div id="hp-bar-frame">
                <div id="hp-fill"></div>
            </div>
            <div style="font-size: 10px; color: #888; margin-top: 5px; font-family: 'Orbitron'; letter-spacing: 2px;">
                VITAL SYSTEMS</div>
        </div>

        <div id="god-mode-indicator"
            style="display:none; position:fixed; bottom:20px; left:20px; color:var(--danger); font-family:'Orbitron'; font-size:20px; text-shadow:0 0 10px red;">
            GOD MODE ACTIVE</div>
    </div>

    <div id="levelup-screen" class="screen-overlay">
        <h1
            style="font-family:'Orbitron'; font-size:50px; color:var(--bosnia-yellow); margin-bottom:5px; text-shadow:0 0 15px var(--bosnia-yellow); letter-spacing: 5px;">
            SYSTEM UPGRADE</h1>
        <p
            style="color:var(--neon-cyan); margin-bottom:30px; font-size:18px; font-family: 'Rajdhani'; letter-spacing: 2px;">
            SELECT AUGMENTATION</p>
        <div class="cards-container" id="cards-box"></div>
    </div>

    <div id="game-over" class="screen-overlay">
        <h1
            style="color:var(--danger); font-family:'Orbitron'; font-size:100px; margin:0; text-shadow:0 0 20px red; letter-spacing:10px;">
            MIA</h1>
        <p style="font-size:24px; color:white; font-family: 'Rajdhani'; letter-spacing: 2px;">FINAL SCORE: <span
                id="final-score" style="color:var(--bosnia-yellow); font-weight:bold;">0</span></p>
        <button class="restart-btn" onclick="resetGame()">RESPAWN</button>
        <button class="menu-btn" style="margin-top:20px; font-size:16px;" onclick="quitGame()">EXIT TO MENU</button>
    </div>

    <canvas id="game"></canvas>

    <script>
        const canvas = document.getElementById('game'), ctx = canvas.getContext('2d', { alpha: false });
        let W, H;

        // ADMIN VARS
        const CHEAT_CODE = "Roblox13_isme";
        let inputBuffer = "";
        let godMode = false;
        let spawningEnabled = true;

        // ASSETS
        // MODIFIED: Heal (Grandma Soup) is now infinite (max: 9999) to prevent softlocks
        const UPGRADES = [
            { id: 'burek', name: 'Golden Burek', icon: 'ü•ê', desc: 'Spawns rotating pastry shields that damage enemies.', tier: 'common', max: 8 },
            { id: 'cevapi', name: 'Rapid Cevapi', icon: 'üå≠', desc: 'Fires delicious grilled meat missiles. Rate increases with level.', tier: 'common', max: 10 },
            { id: 'ajvar', name: 'Nuclear Ajvar', icon: 'üå∂Ô∏è', desc: 'Throws explosive jars of pepper paste.', tier: 'common', max: 10 },
            { id: 'rakija', name: 'Holy Rakija', icon: 'üçæ', desc: 'Smashes bottles creating purifying fire zones.', tier: 'common', max: 10 },
            { id: 'pyramid', name: 'Visoko Beam', icon: '‚õ∞Ô∏è', desc: 'Fires a high-energy piercing triangle beam.', tier: 'common', max: 6 },

            { id: 'spike', name: 'Impaler Spikes', icon: 'üî©', desc: 'Summons spikes under the 3 strongest enemies. (Dmg scales with Player Level)', tier: 'common', max: 10 },
            { id: 'flag', name: 'Bosnian Flag', icon: 'üáßüá¶', desc: 'Throws a flag into the air that falls and pierces enemies. (+1 Flag per Card Level).', tier: 'rare', max: 6 },
            { id: 'sword', name: 'Dull Bosnian Sword', icon: 'üó°Ô∏è', desc: '+10% Damage for ALL attacks. (Additive Stack)', tier: 'common', max: 10 },

            { id: 'harmonika', name: 'Harmonika Aura', icon: 'üéπ', desc: 'Slows all enemies within range. (30% Base, +10% per level, Max 80%)', tier: 'rare', max: 8 },
            { id: 'xp_boost', name: 'Poor Jewelry', icon: 'üíç', desc: '+50% EXP Gain (Stacks)', tier: 'rare', max: 10 },
            { id: 'cracked_jewelry', name: 'Cracked Jewelry', icon: 'üìø', desc: '+25% EXP Gain (Stacks with Poor Jewelry).', tier: 'common', max: 10 },

            { id: 'serbian', name: 'Serbian Warrior', icon: '‚öîÔ∏è', desc: 'Summons a Friendly Unit. Targets Hordes. 30s Respawn.', tier: 'legendary', max: 1 },

            { id: 'speed', name: 'Turbo Folk Speed', icon: '‚ö°', desc: 'Increases Movement Speed by 20%.', tier: 'common', max: 10 },
            { id: 'magnet', name: 'Super Magnet', icon: 'üß≤', desc: 'Increases Item Pickup Range by 50%.', tier: 'common', max: 10 },
            { id: 'armor', name: 'Kevlar Vest', icon: 'üõ°Ô∏è', desc: 'Reduces incoming damage.', tier: 'common', max: 10 },
            { id: 'heal', name: 'Grandma Soup', icon: 'üç≤', desc: 'Instantly restores 50 HP.', tier: 'common', max: 9999 }, /* INFINITE FIX */
            { id: 'coffee', name: 'Bosnian Coffee', icon: '‚òï', desc: 'Reduces all weapon cooldowns by 10%.', tier: 'common', max: 10 },
            { id: 'lily', name: 'Golden Lily', icon: '‚öúÔ∏è', desc: 'Increases Critical Hit Chance by 10%.', tier: 'common', max: 10 },
            { id: 'vrelo', name: 'Vrelo Bosne', icon: 'üèûÔ∏è', desc: 'Regenerates 2 HP per second.', tier: 'common', max: 10 }
        ];

        const EVOLUTIONS = [
            { id: 'burek_evo', base: 'burek', name: 'RING OF FIRE', icon: 'üî•', desc: 'EVOLUTION: Massive permanent fire zone. 2x Radius. Burns ALL enemies constantly.', tier: 'rare' },
            { id: 'pyramid_evo', base: 'pyramid', name: 'SOLAR FLARE', icon: '‚òÄÔ∏è', desc: 'EVOLUTION: Instantly blasts enemies with a massive laser beam.', tier: 'rare' },
            { id: 'cevapi_evo', base: 'cevapi', name: 'ROSTILJ MASTER', icon: 'üçñ', desc: 'EVO: Adds an orbiting grill. You continue to fire your own rounds. Overheats every 100 kills.', tier: 'rare' },
            { id: 'serbian_p1', base: 'serbian', name: 'PATH 1: TITAN SWORD', icon: 'üó°Ô∏è', desc: 'LVL 2: Bigger Sword. Higher Damage. Same AI.', tier: 'legendary', req: 'serbian' },
            { id: 'serbian_p2', base: 'serbian', name: 'PATH 2: TACTICAL SQUAD', icon: 'üë•', desc: 'LVL 2: Splits into 3 Units: Soldier, Defender, Mage.', tier: 'legendary', req: 'serbian' },
            { id: 'serbian_p3', base: 'serbian', name: 'PATH 3: VANGUARD', icon: 'üõ°Ô∏è', desc: 'LVL 2: Sword & Shield Unit. 20 Durability. Tanky.', tier: 'legendary', req: 'serbian' },
            { id: 'serbian_p1_evo', base: 'serbian_p1', name: 'BERSERKER', icon: 'üå™Ô∏è', desc: 'LVL 3: 1.5x Size/Dmg. Spin Attack (3 hits). 4s Cooldown.', tier: 'legendary', req: 'serbian_p1' },
            { id: 'serbian_p2_evo', base: 'serbian_p2', name: 'ELITE SQUAD', icon: '‚ú®', desc: 'LVL 3: Shield gets Pushback. Mage gets Visoko Beam.', tier: 'legendary', req: 'serbian_p2' },
            { id: 'serbian_p3_evo', base: 'serbian_p3', name: 'WARLORD TANK', icon: 'üí¢', desc: 'LVL 3: 30 Durability. Taunts enemies every 20s.', tier: 'legendary', req: 'serbian_p3' }
        ];

        const SUPERCHARGES = [
            { id: 'supercharge_burek', name: 'SUPERCHARGE: MAGMA', icon: 'üåã', desc: 'Increases Burn Damage.', tier: 'legendary' },
            { id: 'supercharge_pyramid', name: 'SUPERCHARGE: SOLAR', icon: 'üî•', desc: '+20% Damage for Solar Flare.', tier: 'legendary' },
            { id: 'supercharge_cevapi', name: 'SUPERCHARGE: COAL', icon: 'ü•©', desc: '+1 Burn Tick Duration for Overheat Cevapis.', tier: 'legendary' }
        ];

        const SPECIAL_REWARDS = [
            { id: 'musical_beat', name: 'MUSICAL BEAT', icon: 'üéµ', desc: 'XP Gain Multiplied by 1.5x.', tier: 'legendary' },
            { id: 'rhythmic_buff', name: 'RHYTHMIC BUFF', icon: 'ü•Å', desc: 'Every 18s, gain +40% Size and Damage for 2s.', tier: 'legendary' },
            { id: 'piano_smash', name: 'PIANO SMASH', icon: 'üéπ', desc: 'Calls down a piano to smash enemies near you. (100 Base Dmg + Level).', tier: 'legendary' }
        ];

        const ENEMY_INFO = [
            { name: 'Promaja', icon: 'üí®', desc: 'The silent killer. A swirling vortex of cold air.' },
            { name: 'Yugo 45', icon: 'üöó', desc: 'Tanky unit. Hard to destroy, hits like a truck.' },
            { name: 'Hornet', icon: 'üêù', desc: 'Swarm unit. Fast, aggressive, attacks in groups.' },
            { name: 'Snajper', icon: 'üü•', desc: 'Long-range sniper. Punishment for standing still.' },
            { name: 'Medic', icon: 'üöë', desc: 'Healer unit. Sustains the horde. Priority target.' },
            { name: 'Krvavi Lovac', icon: 'üî™', desc: 'Phase Shifter. Turns 90% invisible (still hittable). Spawns after 7 mins.' },
            { name: 'Svjetlosni Juri≈°nik', icon: '‚ö°', desc: 'Light Charger. Fast gap-closer with a stunning Light Dash. Spawns after 17 mins.' },
            { name: 'Nolan-ite', icon: 'üáµüá±', desc: 'Summoned by Braxton. Fast, shoots Warsaw blasts.' },
            { name: 'WARLORD', icon: 'üëπ', desc: 'The Final Boss. Immune to Nuke/Freeze. 5000 HP.' },
            { name: 'BRAXTON-inite', icon: 'üåÆ', desc: '15,000 HP. Kills everything. Summons Nolans. Lasers.' },
            { name: 'The Polyrhythm', icon: 'üé∂', desc: '15 Min Boss. Fast, Dodges, Heals. Don\'t move during waves.' },
            { name: 'Te≈æina Presude', icon: '‚öñÔ∏è', desc: '20 Min Boss. Judgment. Stores damage then reflects it. Instakills summons.' }
        ];

        let gameActive = false;
        let isPaused = false;
        let isCutscene = false;
        let crateRewards = [];

        let state = {
            frames: 0, gameTime: 0, score: 0, level: 1, xp: 0, nextLevelXp: 20, xpMult: 1, shake: 0,
            enemies: [], particles: [], projectiles: [], beams: [], zones: [], gems: [], perks: [], backgroundStars: [],
            bossActive: false, bossSpawnedOnce: false, braxtonSpawned: false, braxtonActive: false, flashAlpha: 0,
            friendlyUnits: [], crates: [], texts: [],
            polyrhythmSpawned: false, polyrhythmActive: false, rhythmicBuffTimer: 0,
            tezinaSpawned: false, tezinaActive: false
        };
        let player = {
            x: 0, y: 0, hp: 100, maxHp: 100, speed: 6, radius: 20, magnetRadius: 140, armor: 0, regen: 0, critChance: 0.05, cdr: 1.0, facing: 0,
            luck: 1.0, visible: true, invincible: 0,
            weapons: {},
            items: {},
            moving: false /* ADDED MOVING FLAG */
        };

        function resize() { W = canvas.width = window.innerWidth; H = canvas.height = window.innerHeight; }
        window.addEventListener('resize', resize); resize();

        const keys = {};
        window.addEventListener('keydown', e => {
            keys[e.key.toLowerCase()] = true;
            if (e.key === "Escape" && gameActive) togglePause();

            if (e.key.length === 1) {
                inputBuffer += e.key;
                if (inputBuffer.length > CHEAT_CODE.length) inputBuffer = inputBuffer.slice(-CHEAT_CODE.length);
                if (inputBuffer === CHEAT_CODE) {
                    openAdmin();
                }
            }
        });
        window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

        function triggerDeath() {
            document.getElementById('final-score').innerText = state.score;
            document.getElementById('game-over').style.display = 'flex';
            gameActive = false;
        }

        function openAdmin() {
            if (!gameActive) return;
            populateAdminSelect();
            document.getElementById('admin-panel').style.display = 'flex';
            if (!isPaused) togglePause();
        }

        function populateAdminSelect() {
            const sel = document.getElementById('admin-augment-select');
            sel.innerHTML = "";
            const all = [...UPGRADES, ...EVOLUTIONS, ...SUPERCHARGES, ...SPECIAL_REWARDS];
            all.forEach(u => {
                let opt = document.createElement('option');
                opt.value = u.id;
                opt.innerText = u.name;
                sel.appendChild(opt);
            });
        }

        function adminForceUpgrade() {
            const val = document.getElementById('admin-augment-select').value;
            applyUpgrade(val);
            spawnDamageText(player.x, player.y - 80, "ADMIN UPGRADE", true);
            closeAdmin();
        }

        function adminCycleLuck() {
            if (player.luck === 1.0) player.luck = 2.0;
            else if (player.luck === 2.0) player.luck = 5.0;
            else if (player.luck === 5.0) player.luck = 10.0;
            else player.luck = 1.0;
            document.getElementById('admin-luck-val').innerText = player.luck + "x";
        }

        function adminToggleSpawns() {
            spawningEnabled = !spawningEnabled;
            spawnDamageText(player.x, player.y - 60, spawningEnabled ? "SPAWNS ON" : "SPAWNS OFF", 'normal');
        }

        function adminSpawnEnemy() {
            const type = document.getElementById('spawn-enemy-select').value;
            let e = new Enemy(type);
            if (type === 'BRAXTON') {
                triggerBraxtonCutscene();
                closeAdmin();
                return;
            }
            if (type === 'POLYRHYTHM') {
                triggerMusicalIntro();
                closeAdmin();
                return;
            }
            if (type === 'TEZINA') {
                triggerClockIntro();
                closeAdmin();
                return;
            }
            state.enemies.push(e);
            spawnDamageText(player.x, player.y - 80, "SPAWNED " + type, 'normal');
        }

        function closeAdmin() {
            document.getElementById('admin-panel').style.display = 'none';
            if (isPaused) togglePause();
        }
        function toggleGodMode() {
            godMode = !godMode;
            document.getElementById('god-mode-indicator').style.display = godMode ? 'block' : 'none';
            spawnDamageText(player.x, player.y - 60, godMode ? "GOD MODE ON" : "GOD MODE OFF", 'normal');
        }
        function adminLevelUp() {
            state.xp = state.nextLevelXp;
            checkLevelUp();
        }
        function adminKillAll() {
            state.enemies.forEach(e => {
                if (e.type !== 'BRAXTON' && e.type !== 'POLYRHYTHM' && e.type !== 'TEZINA') e.takeDamage(99999, true);
            });
        }
        function adminHeal() {
            player.hp = player.maxHp;
            updateHud();
        }

        function openInfo(type) {
            document.getElementById('info-modal').style.display = 'flex';
            const content = document.getElementById('info-content');
            const title = document.getElementById('info-title');
            content.innerHTML = '';

            if (type === 'armory') {
                title.innerText = "ARMORY PROTOCOLS";
                const allItems = [...UPGRADES, ...EVOLUTIONS, ...SPECIAL_REWARDS].filter(u => !u.id.includes('serbian_p'));

                allItems.forEach(u => {
                    let extraClass = '';
                    if (u.tier === 'rare') extraClass = 'rare';
                    if (u.tier === 'legendary') extraClass = 'legendary';
                    content.innerHTML += `
                <div class="info-card ${extraClass}">
                    <div class="info-icon">${u.icon}</div>
                    <div class="info-text"><h3>${u.name}</h3><p>${u.desc}</p></div>
                </div>`;
                });
            } else {
                title.innerText = "THREAT INTEL";
                ENEMY_INFO.forEach(e => {
                    content.innerHTML += `
                <div class="info-card">
                    <div class="info-icon">${e.icon}</div>
                    <div class="info-text"><h3>${e.name}</h3><p>${e.desc}</p></div>
                </div>`;
                });
            }
        }

        function closeInfo() { document.getElementById('info-modal').style.display = 'none'; }

        function startGame() {
            document.getElementById('main-menu').style.display = 'none';
            resetGame();
        }

        function quitGame() {
            gameActive = false;
            document.getElementById('game-over').style.display = 'none';
            document.getElementById('pause-screen').style.display = 'none';
            document.getElementById('ui-layer').style.display = 'none';
            document.getElementById('boss-hud').style.display = 'none';
            document.getElementById('admin-panel').style.display = 'none';
            document.getElementById('evolution-overlay').style.display = 'none';
            document.getElementById('braxton-cutscene').style.display = 'none';
            document.getElementById('crate-screen').style.display = 'none';
            document.getElementById('clock-overlay').style.display = 'none';
            document.getElementById('boss-caption').style.opacity = '0';
            document.getElementById('main-menu').style.display = 'flex';
        }

        function togglePause() {
            if (!gameActive) return;
            if (isCutscene) return;
            if (document.getElementById('levelup-screen').style.display === 'flex') return;
            if (document.getElementById('evolution-overlay').style.display === 'flex') return;
            if (document.getElementById('crate-screen').style.display === 'flex') return;
            isPaused = !isPaused;
            document.getElementById('pause-screen').style.display = isPaused ? 'flex' : 'none';

            if (isPaused) {
                const statsBox = document.getElementById('pause-stats');
                statsBox.innerHTML = '';

                let allAbilities = [];
                for (const [key, val] of Object.entries(player.weapons)) {
                    if (val.level > 0) {
                        let info = UPGRADES.find(u => u.id === key) || SPECIAL_REWARDS.find(u => u.id === key);
                        let name = info ? info.name : key;
                        if (key === 'serbian') name = "Serbian Warrior";
                        let displayLvl = val.evolved ? "EVOLVED" : val.level;
                        allAbilities.push({ name: name, lvl: displayLvl });
                    }
                }
                for (const [key, val] of Object.entries(player.items)) {
                    if (val > 0) {
                        let info = UPGRADES.find(u => u.id === key) || SPECIAL_REWARDS.find(u => u.id === key);
                        let name = info ? info.name : key;
                        allAbilities.push({ name: name, lvl: val });
                    }
                }
                if (allAbilities.length === 0) statsBox.innerHTML = '<div style="color:#777; font-family:Rajdhani">No Augmentations</div>';

                allAbilities.forEach(ab => {
                    let row = document.createElement('div');
                    row.className = 'pause-item';
                    row.innerHTML = `<span>${ab.name}</span><span style="color:var(--neon-cyan)">${ab.lvl}</span>`;
                    statsBox.appendChild(row);
                });
            }
        }

        function initBackground() {
            state.backgroundStars = [];
            for (let i = 0; i < 60; i++) {
                state.backgroundStars.push({
                    x: Math.random() * W,
                    y: Math.random() * H,
                    size: Math.random() * 2 + 1,
                    alpha: Math.random() * 0.5 + 0.1
                });
            }
        }

        function resetGame() {
            gameActive = true;
            isPaused = false;
            isCutscene = false;
            godMode = false;
            spawningEnabled = true;
            document.getElementById('god-mode-indicator').style.display = 'none';
            document.getElementById('boss-caption').style.opacity = '0';
            state = {
                frames: 0, gameTime: 0, score: 0, level: 1, xp: 0, nextLevelXp: 20, xpMult: 1, shake: 0,
                enemies: [], particles: [], projectiles: [], beams: [], zones: [], gems: [], perks: [], backgroundStars: [],
                bossActive: false, bossSpawnedOnce: false, braxtonSpawned: false, braxtonActive: false, flashAlpha: 0,
                friendlyUnits: [], crates: [], texts: [],
                polyrhythmSpawned: false, polyrhythmActive: false, rhythmicBuffTimer: 0,
                tezinaSpawned: false, tezinaActive: false
            };
            initBackground();

            player = {
                x: W / 2, y: H / 2, hp: 100, maxHp: 100, speed: 6, radius: 20, magnetRadius: 140, armor: 0, regen: 0, critChance: 0.05, cdr: 1.0, facing: 0,
                luck: 1.0, visible: true, invincible: 0,
                weapons: {
                    burek: { level: 1, count: 1, damage: 10, dist: 100, speed: 0.02, evolved: false, orbs: [], trailTimer: 0 },
                    cevapi: { level: 1, cooldown: 60, baseCool: 60, timer: 0, damage: 15, evolved: false, grillAngle: 0, lastBurstScore: 0, burnCount: 25 },
                    ajvar: { level: 0, cooldown: 140, baseCool: 140, timer: 0, damage: 80 },
                    rakija: { level: 0, cooldown: 190, baseCool: 190, timer: 0, damage: 4, duration: 300 },
                    pyramid: { level: 0, cooldown: 110, baseCool: 110, timer: 0, damage: 50, evolved: false },
                    spike: { level: 0, cooldown: 180, baseCool: 180, timer: 0, damage: 60 },
                    flag: { level: 0, cooldown: 240, baseCool: 240, count: 1, timer: 0 },
                    harmonika: { level: 0, range: 240, slow: 0.30 },
                    serbian: { level: 0, path: 0, evolved: false },
                    piano_smash: { level: 0, cooldown: 300, timer: 0 }
                },
                items: {
                    speed: 0, magnet: 0, armor: 0, heal: 0, coffee: 0, lily: 0, vrelo: 0, xp_boost: 0,
                    sword: 0, cracked_jewelry: 0, musical_beat: 0, rhythmic_buff: 0
                },
                moving: false
            };

            document.getElementById('game-over').style.display = 'none';
            document.getElementById('levelup-screen').style.display = 'none';
            document.getElementById('pause-screen').style.display = 'none';
            document.getElementById('boss-hud').style.display = 'none';
            document.getElementById('admin-panel').style.display = 'none';
            document.getElementById('evolution-overlay').style.display = 'none';
            document.getElementById('braxton-cutscene').style.display = 'none';
            document.getElementById('crate-screen').style.display = 'none';
            document.getElementById('clock-overlay').style.display = 'none';
            document.getElementById('ui-layer').style.display = 'flex';
            updateHud();
        }

        function createParticle(x, y, color, type, speedM = 1) {
            if (state.particles.length > 250) return;
            const p = { x: x, y: y, vx: (Math.random() - 0.5) * 8 * speedM, vy: (Math.random() - 0.5) * 8 * speedM, life: 1, decay: 0.015 + Math.random() * 0.03, color: color, size: Math.random() * 6 + 2, type: type };
            if (type === 'fire') { p.vy -= 2; p.decay = 0.04; p.size *= 1.5; }
            if (type === 'spark') { p.decay = 0.06; p.size = 2; p.life = 0.8; }
            if (type === 'smoke') { p.vx *= 0.3; p.vy *= 0.3; p.size = 12; p.decay = 0.01; p.color = '#555'; }
            if (type === 'plasma') { p.decay = 0.08; p.size = Math.random() * 12 + 4; }
            if (type === 'note') { p.decay = 0.02; p.size = 10; p.vx *= 0.5; p.vy = -2; p.char = 'üéµ'; }
            if (type === 'blood') { p.decay = 0.03; p.size = Math.random() * 5 + 2; p.color = '#aa0000'; }
            if (type === 'heal') { p.decay = 0.05; p.vy = -1; p.size = 4; p.color = '#00ff41'; }
            state.particles.push(p);
        }

        function spawnDamageText(x, y, dmg, type = 'normal') {
            let color = '#fff';
            let scale = 1.0;
            let displayVal = (typeof dmg === 'number') ? Math.floor(dmg) : dmg;

            if (type === 'crit') { color = '#00f3ff'; scale = 2.0; }
            if (type === 'player') { color = '#ff003c'; scale = 1.5; displayVal = "-" + displayVal; }
            state.texts.push({ x: x + (Math.random() - 0.5) * 30, y: y, val: displayVal, life: 1, color: color, scale: scale, vy: -2 });
        }

        function addShake(amt) { state.shake = Math.min(state.shake + amt, 30); }

        function calcDamage(base) {
            let levelBonus = Math.max(0, state.level - 1);
            let totalBase = base + (levelBonus * 0.5);
            if (player.items.sword > 0) totalBase *= (1 + (player.items.sword * 0.1));

            // Rhythmic Buff Effect
            if (player.items.rhythmic_buff > 0 && state.rhythmicBuffTimer > 1080) {
                totalBase *= 1.4;
            }

            let isCrit = Math.random() < player.critChance;
            let dmg = totalBase * (isCrit ? 2.0 : 1.0);
            return { d: dmg, c: isCrit };
        }

        // --- FRIENDLY UNIT SYSTEM ---
        class FriendlyUnit {
            constructor(type, x, y) {
                this.type = type;
                this.x = x; this.y = y;

                this.maxDurability = 10;
                this.baseDamage = 50;
                this.radius = 25;
                this.attackRange = 100;
                this.attackSpeed = 180;
                this.moveSpeed = 3.5;
                this.respawnTime = 30 * 60;

                this.durability = this.maxDurability;
                this.attackTimer = 0;
                this.immuneTimer = 0;
                this.dead = false;
                this.respawnTimer = 0;
                this.magnetRadius = 250;
                this.taunting = false;
                this.tauntTimer = 0;
                this.tauntCooldown = 0;
                this.invisibleTimer = 0;

                if (type === 'soldier') { this.maxDurability = 10; }
                if (type === 'titan') { this.baseDamage = 75; }
                if (type === 'vanguard') { this.maxDurability = 20; }
                if (type === 'defender') { this.maxDurability = 15; this.baseDamage = 0; }
                if (type === 'mage') { this.maxDurability = 3; this.attackRange = 400; }

                const tech = player.weapons.serbian;
                if (tech.path === 2 && type === 'soldier') this.maxDurability = 5;

                // --- LEVEL 3 (EVOLUTION) LOGIC ---
                this.isBerserk = false; this.canTaunt = false; this.canPush = false; this.hasBeam = false;

                if (tech.path === 3 && tech.evolved) { this.maxDurability = 30; this.canTaunt = true; } // Warlord Tank
                if (tech.path === 1 && tech.evolved) { this.radius *= 1.5; this.baseDamage *= 1.5; this.attackSpeed = 240; this.isBerserk = true; } // Berserker
                if (tech.path === 2 && tech.evolved) {
                    if (type === 'defender') { this.maxDurability = 10; this.canPush = true; this.pushTimer = 0; } // Elite Defender
                    if (type === 'mage') { this.hasBeam = true; } // Elite Mage
                }
                this.durability = this.maxDurability;
            }

            update() {
                if (this.dead) {
                    this.respawnTimer--;
                    if (this.respawnTimer <= 0) {
                        this.dead = false;
                        this.durability = this.maxDurability;
                        this.immuneTimer = 180;
                        this.x = player.x; this.y = player.y;
                        spawnDamageText(this.x, this.y - 50, "UNIT READY", 'normal');
                        createParticle(this.x, this.y, '#fff', 'plasma', 5);
                    }
                    return;
                }
                if (this.immuneTimer > 0) this.immuneTimer--;
                if (this.invisibleTimer > 0) this.invisibleTimer--;

                state.gems.forEach(g => {
                    if (!g.vacuum) {
                        let d = Math.hypot(g.x - this.x, g.y - this.y);
                        if (d < this.magnetRadius) g.vacuum = true;
                    }
                });

                // AI MOVEMENT
                let target = null;
                let minDist = 9999;
                let enemiesNearby = 0;

                state.enemies.forEach(e => {
                    let d = Math.hypot(e.x - this.x, e.y - this.y);
                    if (d < 150) enemiesNearby++;
                    if (d < minDist) { minDist = d; target = e; }
                });

                let moveX = 0, moveY = 0;
                let distToPlayer = Math.hypot(player.x - this.x, player.y - this.y);

                // --- SQUAD SOLDIER LOGIC: 12000px LEASH ---
                if (this.type === 'soldier' && player.weapons.serbian.path === 2 && distToPlayer > 12000) {
                    // Return to player if absurdly far
                    let ang = Math.atan2(player.y - this.y, player.x - this.x);
                    moveX = Math.cos(ang) * 5.0;
                    moveY = Math.sin(ang) * 5.0;
                }
                else if (distToPlayer > 250 && this.type === 'soldier' && player.weapons.serbian.path === 2) {
                    // No leash logic, free roam until 12000
                    if (target) {
                        let ang = Math.atan2(target.y - this.y, target.x - this.x);
                        moveX = Math.cos(ang); moveY = Math.sin(ang);
                    } else {
                        // Wander
                        moveX = (Math.random() - 0.5); moveY = (Math.random() - 0.5);
                    }
                }
                else if (distToPlayer > 800) {
                    let ang = Math.atan2(player.y - this.y, player.x - this.x);
                    moveX = Math.cos(ang) * 2;
                    moveY = Math.sin(ang) * 2;
                } else {
                    if (this.type === 'mage') {
                        let protectTarget = state.friendlyUnits.find(u => u.type === 'defender' && !u.dead) || player;
                        let dProt = Math.hypot(protectTarget.x - this.x, protectTarget.y - this.y);
                        if (minDist < 200) {
                            let ang = Math.atan2(target.y - this.y, target.x - this.x);
                            moveX = -Math.cos(ang); moveY = -Math.sin(ang);
                        } else if (dProt > 100) {
                            let ang = Math.atan2(protectTarget.y - this.y, protectTarget.x - this.x);
                            moveX = Math.cos(ang); moveY = Math.sin(ang);
                        }
                    }
                    else if (this.type === 'defender') {
                        if (target) {
                            let ang = Math.atan2(target.y - player.y, target.x - player.x);
                            let blockX = player.x + Math.cos(ang) * 60;
                            let blockY = player.y + Math.sin(ang) * 60;
                            let dBlock = Math.hypot(blockX - this.x, blockY - this.y);
                            if (dBlock > 10) {
                                let angM = Math.atan2(blockY - this.y, blockX - this.x);
                                moveX = Math.cos(angM); moveY = Math.sin(angM);
                            }
                        } else {
                            let dP = Math.hypot(player.x - this.x, player.y - this.y);
                            if (dP > 60) {
                                let ang = Math.atan2(player.y - this.y, player.x - this.x);
                                moveX = Math.cos(ang); moveY = Math.sin(ang);
                            }
                        }
                    }
                    else {
                        if (enemiesNearby >= 5) { moveX = 0; moveY = 0; }
                        else {
                            if (target) {
                                let d = Math.hypot(target.x - this.x, target.y - this.y);
                                if (d > 40) {
                                    let ang = Math.atan2(target.y - this.y, target.x - this.x);
                                    moveX = Math.cos(ang); moveY = Math.sin(ang);
                                }
                            } else {
                                let dP = Math.hypot(player.x - this.x, player.y - this.y);
                                if (dP > 100) {
                                    let ang = Math.atan2(player.y - this.y, player.x - this.x);
                                    moveX = Math.cos(ang); moveY = Math.sin(ang);
                                }
                            }
                        }
                    }
                }

                this.x += moveX * this.moveSpeed;
                this.y += moveY * this.moveSpeed;

                // --- LEVEL 3: WARLORD TANK TAUNT ---
                if (this.canTaunt) {
                    if (this.tauntCooldown > 0) this.tauntCooldown--;
                    if (this.taunting) {
                        this.tauntTimer--;
                        if (this.tauntTimer <= 0) {
                            this.taunting = false;
                            this.tauntCooldown = 1200;
                        }
                    } else if (this.tauntCooldown <= 0 && enemiesNearby > 0) {
                        this.taunting = true;
                        this.tauntTimer = 300;
                        spawnDamageText(this.x, this.y - 60, "AGGRESION", 'normal');
                        state.zones.push(new Zone(this.x, this.y, 'taunt_ring', 300));
                    }
                }

                // --- LEVEL 3: ELITE DEFENDER PUSH ---
                if (this.canPush) {
                    this.pushTimer++;
                    if (this.pushTimer > 900) {
                        this.pushTimer = 0;
                        state.zones.push(new Zone(this.x, this.y, 'shield_push', 20));
                        let range = player.weapons.harmonika.range * 1.5;
                        state.enemies.forEach(e => {
                            let d = Math.hypot(e.x - this.x, e.y - this.y);
                            if (d < range) {
                                let ang = Math.atan2(e.y - this.y, e.x - this.x);
                                e.pushX = Math.cos(ang) * 25;
                                e.pushY = Math.sin(ang) * 25;
                            }
                        });
                        spawnDamageText(this.x, this.y - 60, "SHIELD BASH", 'normal');
                    }
                }

                this.attackTimer++;
                if (this.attackTimer > this.attackSpeed) {
                    if (this.type === 'mage') {
                        if (target) {
                            this.attackTimer = 0;
                            let pLevel = Math.max(1, player.weapons.cevapi.level);
                            let p = new Projectile(this.x, this.y, target, 'cevapi');
                            p.overrideDamage = 15 + (pLevel * 10) + (state.level * 1);
                            state.projectiles.push(p);

                            // --- LEVEL 3: ELITE MAGE BEAM ---
                            if (this.hasBeam) {
                                let beamLvl = Math.max(1, player.weapons.pyramid.level);
                                let ang = Math.atan2(target.y - this.y, target.x - this.x);
                                state.beams.push(new Beam(this.x, this.y, ang));
                                state.enemies.forEach(e => {
                                    let d = Math.hypot(e.x - this.x, e.y - this.y);
                                    if (d < 600 && Math.abs(Math.atan2(e.y - this.y, e.x - this.x) - ang) < 0.2) {
                                        e.takeDamage(50 * beamLvl, false, 'friendly_beam');
                                    }
                                });
                            }
                        }
                    }
                    else if (this.type === 'defender') { }
                    else {
                        this.attackTimer = 0;
                        addShake(5);
                        let damageCalc = this.baseDamage + (state.level * 5);

                        // --- LEVEL 3: BERSERKER SPIN ---
                        if (this.isBerserk) {
                            state.zones.push(new Zone(this.x, this.y, 'berserk_spin', 45, damageCalc));
                            spawnDamageText(this.x, this.y - 60, "SPIN!", 'normal');
                        } else {
                            state.zones.push(new Zone(this.x, this.y, 'valk_swing', 15, damageCalc));
                            state.enemies.forEach(e => {
                                if (Math.hypot(e.x - this.x, e.y - this.y) < 160) {
                                    e.takeDamage(damageCalc, true, 'friendly');
                                }
                            });
                        }
                    }
                }
            }

            takeDamage(amt) {
                if (this.immuneTimer > 0) return;
                if (this.invisibleTimer > 0) return; // Mage invisible, no damage

                // MAGE SPECIAL ABILITY: Invisibility on hit
                if (this.type === 'mage') {
                    this.invisibleTimer = 180; // 3 seconds
                    spawnDamageText(this.x, this.y - 40, "PHASE SHIFT", 'normal');
                    return; // NO DURABILITY LOSS
                }

                this.durability--;
                this.immuneTimer = 300;
                spawnDamageText(this.x, this.y - 30, "-1 DUR", 'normal');
                createParticle(this.x, this.y, '#00f3ff', 'plasma', 3);

                if (this.durability <= 0) {
                    this.dead = true;
                    this.respawnTimer = this.respawnTime;
                    spawnDamageText(this.x, this.y - 50, "UNIT DOWN", 'normal');
                }
            }

            draw(cX, cY) {
                if (this.dead) {
                    let sec = Math.ceil(this.respawnTimer / 60);
                    ctx.fillStyle = '#555'; ctx.font = '12px Orbitron'; ctx.fillText(`RESPAWN: ${sec}s`, this.x - cX, this.y - cY);
                    return;
                }
                ctx.save(); ctx.translate(this.x - cX, this.y - cY);

                // COMMON ANIMATION VARIABLES
                let breath = 1 + Math.sin(state.frames * 0.05) * 0.03;
                let bob = Math.sin(state.frames * 0.1) * 2;
                ctx.scale(breath, breath);
                ctx.translate(0, bob);

                if (this.invisibleTimer > 0) ctx.globalAlpha = 0.3;

                if (this.immuneTimer > 0) {
                    ctx.save();
                    ctx.globalAlpha = (this.invisibleTimer > 0 ? 0.3 : 1) * (0.4 + Math.sin(state.frames * 0.5) * 0.2);
                    ctx.fillStyle = '#00f3ff';
                    ctx.beginPath(); ctx.arc(0, 0, 35, 0, 6.28); ctx.fill();
                    ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.stroke();
                    ctx.restore();
                }

                // --- DRAWING LOGIC ---

                if (this.type === 'soldier') {
                    // Level 1: Basic Soldier
                    // Feet (Marching)
                    let legOffset = Math.sin(state.frames * 0.2) * 5;
                    ctx.fillStyle = '#333';
                    ctx.beginPath(); ctx.arc(-8, 20 + legOffset, 5, 0, 6.28); ctx.fill(); // Left foot
                    ctx.beginPath(); ctx.arc(8, 20 - legOffset, 5, 0, 6.28); ctx.fill(); // Right foot
                    // Body / Blue Tabard
                    ctx.fillStyle = '#002395';
                    ctx.beginPath(); ctx.moveTo(-10, -10); ctx.lineTo(10, -10); ctx.lineTo(12, 15); ctx.lineTo(-12, 15); ctx.fill();
                    // Silver Helmet
                    ctx.fillStyle = '#aaa';
                    ctx.beginPath(); ctx.arc(0, -12, 10, 0, Math.PI, true); ctx.lineTo(10, -5); ctx.lineTo(-10, -5); ctx.fill();
                    // Arms & Sword
                    ctx.fillStyle = '#999';
                    ctx.beginPath(); ctx.arc(-12, -2, 4, 0, 6.28); ctx.fill(); // Left Shoulder
                    ctx.beginPath(); ctx.arc(12, -2, 4, 0, 6.28); ctx.fill(); // Right Shoulder

                    ctx.save();
                    ctx.translate(15, 5);
                    let swing = Math.sin(this.attackTimer * 0.2) * 0.5;
                    if (this.attackTimer < 10) swing = -1.5; // Attack frame
                    ctx.rotate(swing);
                    ctx.fillStyle = '#ddd'; ctx.fillRect(-2, -25, 4, 30); // Blade
                    ctx.fillStyle = '#555'; ctx.fillRect(-4, 0, 8, 2); // Crossguard
                    ctx.fillStyle = '#444'; ctx.beginPath(); ctx.arc(0, 5, 3, 0, 6.28); ctx.fill(); // Pommel
                    ctx.restore();
                }
                else if (this.type === 'titan') {
                    // Level 2/3: Titan / Berserker
                    // Massive Feet
                    let legOffset = Math.sin(state.frames * 0.15) * 3;
                    ctx.fillStyle = '#111';
                    ctx.fillRect(-15, 25 + legOffset, 12, 8); ctx.fillRect(5, 25 - legOffset, 12, 8);
                    // Armor
                    ctx.fillStyle = '#222';
                    ctx.beginPath(); ctx.moveTo(-20, -20); ctx.lineTo(20, -20); ctx.lineTo(15, 20); ctx.lineTo(-15, 20); ctx.fill();
                    // Spikes
                    if (this.isBerserk) {
                        ctx.fillStyle = '#800';
                        ctx.beginPath(); ctx.moveTo(-20, -20); ctx.lineTo(-25, -35); ctx.lineTo(-15, -25); ctx.fill();
                        ctx.beginPath(); ctx.moveTo(20, -20); ctx.lineTo(25, -35); ctx.lineTo(15, -25); ctx.fill();
                    }
                    // Helmet & Eyes
                    ctx.fillStyle = '#333'; ctx.beginPath(); ctx.arc(0, -20, 12, 0, 6.28); ctx.fill();
                    ctx.fillStyle = this.isBerserk ? '#f00' : '#fa0';
                    ctx.shadowColor = ctx.fillStyle; ctx.shadowBlur = 10;
                    ctx.beginPath(); ctx.rect(-5, -22, 3, 2); ctx.rect(2, -22, 3, 2); ctx.fill();
                    ctx.shadowBlur = 0;
                    // Massive Sword
                    ctx.save();
                    ctx.translate(25, 0);
                    let angle = 0.5;
                    if (this.isBerserk && this.attackTimer < 15) {
                        angle = -2.0 + (this.attackTimer / 15) * 3.0; // Spin/Slash
                        ctx.fillStyle = 'rgba(255,0,0,0.3)'; ctx.beginPath(); ctx.arc(-25, 0, 70, 0, 6.28); ctx.fill();
                    }
                    ctx.rotate(angle);
                    ctx.fillStyle = '#111'; ctx.fillRect(-5, -60, 14, 70); // Blade slab
                    ctx.fillStyle = '#444'; ctx.fillRect(-8, 5, 20, 5); // Guard
                    ctx.restore();
                }
                else if (this.type === 'vanguard') {
                    ctx.fillStyle = '#223';
                    ctx.fillRect(-12, 22, 10, 8); ctx.fillRect(2, 22, 10, 8);
                    ctx.fillStyle = this.canTaunt ? '#111' : '#445';
                    ctx.fillRect(-15, -15, 30, 40);
                    ctx.fillStyle = '#556';
                    ctx.beginPath(); ctx.arc(0, -18, 12, 0, 6.28); ctx.fill();
                    ctx.fillStyle = '#000'; ctx.fillRect(-8, -20, 16, 4); // Eye slit
                    ctx.fillStyle = this.canTaunt ? '#311' : '#556';
                    ctx.fillRect(-20, -10, 25, 50); // Covers left side mostly
                    ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.strokeRect(-20, -10, 25, 50);
                    ctx.save();
                    ctx.translate(20, 5); ctx.rotate(-0.5);
                    ctx.fillStyle = '#654321'; ctx.fillRect(-2, -20, 4, 25);
                    ctx.fillStyle = '#888'; ctx.beginPath(); ctx.arc(0, -22, 8, 0, 6.28); ctx.fill(); // Head
                    ctx.restore();
                    if (this.taunting) {
                        ctx.strokeStyle = '#ff003c'; ctx.lineWidth = 3;
                        ctx.beginPath(); ctx.arc(0, 0, 60 + Math.sin(state.frames * 0.5) * 10, 0, 6.28); ctx.stroke();
                    }
                }
                else if (this.type === 'defender') {
                    ctx.fillStyle = '#777'; ctx.fillRect(-10, 15, 8, 12); ctx.fillRect(2, 15, 8, 12);
                    ctx.fillStyle = '#889'; ctx.fillRect(-12, -10, 24, 30);
                    ctx.fillStyle = '#fff'; ctx.fillRect(-5, -10, 10, 30); // Cross line
                    ctx.fillStyle = '#667';
                    ctx.beginPath(); ctx.arc(0, -15, 10, 3.14, 0); ctx.fill(); // Dome
                    ctx.fillRect(-12, -15, 24, 4); // Brim
                    ctx.fillStyle = this.canPush ? '#00f3ff' : '#334';
                    if (this.canPush) ctx.globalAlpha = 0.7;
                    ctx.beginPath(); ctx.arc(10, 5, 16, 0, 6.28); ctx.fill();
                    ctx.strokeStyle = '#aaa'; ctx.lineWidth = 3; ctx.stroke();
                    ctx.globalAlpha = 1;
                }
                else if (this.type === 'mage') {
                    let sway = Math.sin(state.frames * 0.1) * 3;
                    ctx.fillStyle = this.hasBeam ? '#4b0082' : '#800080'; // Dark Purple vs Purple
                    ctx.beginPath(); ctx.moveTo(0, -20);
                    ctx.bezierCurveTo(-15, 0, -20 + sway, 25, 0, 30); ctx.bezierCurveTo(20 + sway, 25, 15, 0, 0, -20); ctx.fill();
                    ctx.strokeStyle = '#ffd700'; ctx.lineWidth = 1; ctx.stroke();
                    ctx.fillStyle = this.hasBeam ? '#eee' : '#d000ff';
                    ctx.beginPath(); ctx.arc(0, -20, 8, 0, 6.28); ctx.fill();
                    ctx.fillStyle = '#222';
                    ctx.beginPath(); ctx.moveTo(-10, -24); ctx.lineTo(10, -24); ctx.lineTo(0, -40); ctx.fill();
                    let bookBob = Math.sin(state.frames * 0.15) * 5;
                    ctx.fillStyle = '#8B4513'; ctx.fillRect(15, -10 + bookBob, 12, 16);
                    ctx.fillStyle = '#fff'; ctx.fillRect(17, -8 + bookBob, 8, 12); // Pages
                    if (this.hasBeam) {
                        ctx.strokeStyle = '#d000ff'; ctx.lineWidth = 1;
                        ctx.beginPath(); ctx.arc(0, 0, 35, state.frames * 0.1, state.frames * 0.1 + 4); ctx.stroke();
                    }
                }

                ctx.fillStyle = 'red'; ctx.fillRect(-20, -45, 40, 4);
                ctx.fillStyle = '#0f0'; ctx.fillRect(-20, -45, 40 * (this.durability / this.maxDurability), 4);
                ctx.restore();
            }
        }

        class Crate {
            constructor(x, y, type = 'standard') {
                this.x = x; this.y = y;
                this.bob = 0;
                this.radius = 30;
                this.type = type; // 'standard', 'musical', 'platinum'
            }
            update() {
                this.bob += 0.1;
                const dx = player.x - this.x, dy = player.y - this.y;
                if (Math.hypot(dx, dy) < player.radius + this.radius) {
                    triggerCrateOpening(this.type);
                    return true; // Collected
                }
                return false;
            }
            draw(cX, cY) {
                let yOff = Math.sin(this.bob) * 5;
                let icon = 'üì¶';
                let color = '#fecb00';

                if (this.type === 'musical') { icon = 'üéµ'; color = '#00f3ff'; }
                if (this.type === 'platinum') { icon = 'üíé'; color = '#e5e4e2'; }

                ctx.font = "40px Arial"; ctx.textAlign = "center"; ctx.textBaseline = "middle";
                ctx.fillText(icon, this.x - cX, this.y - cY + yOff);
                // Glow
                ctx.beginPath(); ctx.arc(this.x - cX, this.y - cY + yOff + 5, 25, 0, 6.28);
                ctx.strokeStyle = color;
                ctx.lineWidth = 3; ctx.stroke();
            }
        }

        class Perk {
            constructor(x, y, type) {
                this.x = x; this.y = y; this.type = type; this.bob = 0;
                if (type === 'health') this.icon = '‚ù§Ô∏è';
                else if (type === 'magnet') this.icon = 'üß≤';
                else if (type === 'nuke') this.icon = '‚ò¢Ô∏è';
                else if (type === 'freeze') this.icon = '‚ùÑÔ∏è';
            }
            update() {
                this.bob += 0.1;
                const dx = player.x - this.x, dy = player.y - this.y, dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < player.radius + 30) {
                    if (this.type === 'health') { player.hp = Math.min(player.maxHp, player.hp + 50); spawnDamageText(player.x, player.y - 50, "HEALED", 'normal'); for (let i = 0; i < 10; i++)createParticle(this.x, this.y, '#f00', 'spark'); }
                    if (this.type === 'magnet') { state.gems.forEach(g => g.vacuum = true); spawnDamageText(player.x, player.y - 50, "MAGNETIC", 'normal'); }
                    if (this.type === 'nuke') {
                        addShake(30); state.flashAlpha = 0.8;
                        state.enemies.forEach(e => {
                            if (!e.dead && e.type !== 'BOSS' && e.type !== 'MINI_BOSS' && e.type !== 'BRAXTON' && e.type !== 'POLYRHYTHM' && e.type !== 'TEZINA') { e.takeDamage(9999, true); }
                            else if (e.type === 'BOSS' || e.type === 'BRAXTON' || e.type === 'POLYRHYTHM' || e.type === 'TEZINA') { spawnDamageText(e.x, e.y - 50, "IMMUNE", 'normal'); }
                        });
                        spawnDamageText(player.x, player.y - 50, "NUKE", 'normal'); for (let i = 0; i < 50; i++)createParticle(player.x, player.y, '#ffaa00', 'fire', 5);
                    }
                    if (this.type === 'freeze') {
                        state.enemies.forEach(e => {
                            if (e.type !== 'BOSS' && e.type !== 'BRAXTON' && e.type !== 'POLYRHYTHM' && e.type !== 'TEZINA') e.frozen = 300;
                            else spawnDamageText(e.x, e.y - 50, "IMMUNE", 'normal');
                        });
                        spawnDamageText(player.x, player.y - 50, "FROZEN", 'normal'); for (let i = 0; i < 20; i++)createParticle(player.x, player.y, '#00ffff', 'spark', 2);
                    }
                    updateHud();
                    return true;
                }
                return false;
            }
            draw(cX, cY) {
                let yOff = Math.sin(this.bob) * 5;
                ctx.font = "30px Arial"; ctx.textAlign = "center"; ctx.textBaseline = "middle";
                ctx.fillText(this.icon, this.x - cX, this.y - cY + yOff);
                ctx.beginPath(); ctx.arc(this.x - cX, this.y - cY + yOff, 20, 0, 6.28);
                ctx.strokeStyle = `rgba(255,255,255,${0.5 + Math.sin(this.bob) * 0.3})`; ctx.lineWidth = 2; ctx.stroke();
            }
        }

        class Gem {
            constructor(x, y, val = 0) { this.x = x; this.y = y; this.value = val > 0 ? val : (5 + (state.level * 0.8)); this.wobble = Math.random() * 6.28; this.vacuum = false; this.size = val > 100 ? 10 : 4; this.color = val > 100 ? '#00f3ff' : '#fecb00'; }
            update() {
                this.wobble += 0.1; const dx = player.x - this.x, dy = player.y - this.y, dist = Math.sqrt(dx * dx + dy * dy);
                if (this.vacuum || dist < player.magnetRadius) {
                    let speed = this.vacuum ? 25 : 18;
                    this.x += (dx / dist) * speed; this.y += (dy / dist) * speed;
                }
                if (dist < player.radius + 20) { state.xp += this.value * state.xpMult; checkLevelUp(); updateHud(); return true; } return false;
            }
            draw(cX, cY) {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.translate(this.x - cX, this.y - cY);
                ctx.rotate(this.wobble);
                ctx.rect(-this.size / 2, -this.size / 2, this.size, this.size);
                ctx.fill();
                ctx.rotate(-this.wobble); ctx.translate(-(this.x - cX), -(this.y - cY));
            }
        }

        class Beam {
            constructor(x, y, angle, type = 'default') {
                this.x = x; this.y = y; this.angle = angle; this.type = type;
                this.life = 15; this.maxLife = 15; this.length = 1200;
                if (type === 'heal') { this.length = 200; this.life = 5; this.maxLife = 5; } // Shorter beam for medic
                if (type === 'judgment') { this.length = 2000; this.life = 180; this.maxLife = 180; } // 3 seconds for Te≈æina
            }
            update() { this.life--; return this.life > 0; }
            draw(cX, cY) {
                ctx.save();
                ctx.globalCompositeOperation = 'lighter';

                if (this.type === 'judgment') {
                    const p = this.life / this.maxLife;
                    const width = 120 + Math.sin(state.frames * 0.5) * 20; // Massive

                    // Create holy gradient
                    let grad = ctx.createLinearGradient(this.x - cX, this.y - cY, (this.x - cX) + Math.cos(this.angle) * this.length, (this.y - cY) + Math.sin(this.angle) * this.length);
                    grad.addColorStop(0, '#fff');
                    grad.addColorStop(0.5, '#ffd700'); // Gold
                    grad.addColorStop(1, 'rgba(255, 255, 255, 0)');

                    ctx.strokeStyle = grad;
                    ctx.lineWidth = width * (p > 0.8 ? (1 - p) * 5 : 1); // Fade in/out
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(this.x - cX, this.y - cY);
                    ctx.lineTo((this.x - cX) + Math.cos(this.angle) * this.length, (this.y - cY) + Math.sin(this.angle) * this.length);
                    ctx.stroke();

                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = width * 0.3;
                    ctx.stroke();

                    ctx.restore();
                    return;
                }

                const opacity = this.life / this.maxLife;

                if (this.type === 'heal') {
                    ctx.strokeStyle = `rgba(0, 255, 65, ${opacity})`;
                    ctx.lineWidth = 5 * opacity;
                    ctx.beginPath();
                    ctx.moveTo(this.x - cX, this.y - cY);
                    // Draw to length or target if we had one, assume length for now
                    ctx.lineTo((this.x - cX) + Math.cos(this.angle) * this.length, (this.y - cY) + Math.sin(this.angle) * this.length);
                    ctx.stroke();
                    ctx.restore();
                    return;
                }

                ctx.strokeStyle = `rgba(255, 255, 255, ${opacity})`;
                ctx.lineWidth = 40 * opacity;
                ctx.beginPath();
                ctx.moveTo(this.x - cX, this.y - cY);
                ctx.lineTo((this.x - cX) + Math.cos(this.angle) * this.length, (this.y - cY) + Math.sin(this.angle) * this.length);
                ctx.stroke();
                ctx.strokeStyle = `rgba(255, 100, 0, ${opacity * 0.5})`;
                ctx.lineWidth = 120 * opacity;
                ctx.stroke();
                ctx.restore();
            }
        }

        class Projectile {
            constructor(x, y, target, type) {
                this.x = x; this.y = y; this.type = type; this.life = 150; this.rotation = 0;
                this.pierceHitList = [];
                this.overrideDamage = 0;
                this.hitCooldowns = []; // For Warsaw logic
                this.hitTimer = 0; // Simple timer for Warsaw

                // Rhythmic Buff scaling
                this.scale = 1.0;
                if (player.items.rhythmic_buff > 0 && state.rhythmicBuffTimer > 1080) {
                    this.scale = 1.4;
                }

                if (type === 'boss_missile' || type === 'sniper_shot' || type === 'warsaw' || type === 'bosnian_flag') {
                    let a = 0;
                    if (target) a = Math.atan2(target.y - y, target.x - x);
                    this.speed = 12;

                    if (type === 'sniper_shot') this.speed = 18;
                    if (type === 'warsaw') { this.speed = 10; this.life = 100; }
                    if (type === 'bosnian_flag') {
                        this.speed = 0;
                        this.vx = (Math.random() - 0.5) * 4;
                        this.vy = -12 - Math.random() * 5;
                        this.gravity = 0.6;
                        this.life = 120;
                        this.pierce = true;
                        return;
                    }

                    this.radius = 15;
                    if (type === 'sniper_shot') this.radius = 5;
                    this.vx = Math.cos(a) * this.speed;
                    this.vy = Math.sin(a) * this.speed;
                    return;
                }

                let a = target ? Math.atan2(target.y - y, target.x - x) : Math.random() * 6.28;
                if (type === 'cevapi') { this.speed = 14; this.radius = 8; }
                else if (type === 'cevapi_hot') { this.speed = 14; this.radius = 10; }
                else if (type === 'ajvar') { this.speed = 8; this.radius = 10; }
                else if (type === 'rakija') { this.speed = 10; this.radius = 8; }
                else if (type === 'pyramid') { this.speed = 7; this.radius = 25; this.life = 300; this.pierce = true; }
                this.vx = Math.cos(a) * this.speed; this.vy = Math.sin(a) * this.speed;
            }
            update() {
                if (this.type === 'bosnian_flag') {
                    this.vy += this.gravity;
                    this.x += this.vx; this.y += this.vy;
                    this.rotation = Math.atan2(this.vy, this.vx);
                    this.life--;
                    if (this.y > player.y + 1000) this.life = 0; // Cull if falls too far
                    return;
                }

                this.x += this.vx; this.y += this.vy; this.life--; this.rotation += 0.15;

                if (this.type === 'boss_missile') {
                    createParticle(this.x, this.y, '#ff003c', 'spark', 0.5);
                    return;
                }
                if (this.type === 'sniper_shot') {
                    createParticle(this.x, this.y, '#ff0000', 'spark', 0.2);
                    return;
                }
                if (this.type === 'warsaw') {
                    createParticle(this.x, this.y, '#fff', 'spark', 0.2);
                    if (this.hitTimer > 0) this.hitTimer--;
                    return;
                }

                if (state.frames % 2 === 0) {
                    if (this.type === 'pyramid') createParticle(this.x, this.y, '#2ecc71', 'spark', 0.1);
                    if (this.type === 'cevapi') createParticle(this.x, this.y, '#8b4513', 'smoke', 0.2);
                    if (this.type === 'cevapi_hot') createParticle(this.x, this.y, '#ff4500', 'smoke', 0.4);
                }
                if (this.type === 'ajvar' || this.type === 'rakija') { this.vx *= 0.96; this.vy *= 0.96; this.rotation = this.vx * 0.2; if (this.life < 100 && Math.abs(this.vx) < 1) this.explode(); }
            }
            explode() {
                this.life = 0;
                if (this.type === 'ajvar') {
                    addShake(15);
                    let dmg = calcDamage(player.weapons.ajvar.damage);
                    state.enemies.forEach(e => { if (Math.hypot(e.x - this.x, e.y - this.y) < 150) e.takeDamage(dmg.d, dmg.c) });
                    for (let i = 0; i < 40; i++)createParticle(this.x, this.y, '#ff4500', 'fire', 2.5);
                    state.zones.push(new Zone(this.x, this.y, 'blast', 20));
                }
                if (this.type === 'rakija') { state.zones.push(new Zone(this.x, this.y, 'fire', player.weapons.rakija.duration)); for (let i = 0; i < 20; i++)createParticle(this.x, this.y, '#00ffff', 'fire', 1.5); }
            }
            draw(cX, cY) {
                ctx.save(); ctx.translate(this.x - cX, this.y - cY);
                ctx.scale(this.scale, this.scale); // Scale for Buff
                ctx.rotate(this.rotation);
                if (this.type === 'bosnian_flag') {
                    ctx.rotate(1.57); // Adjust for falling
                    ctx.fillStyle = '#002395'; ctx.fillRect(-10, -15, 20, 30); // Blue
                    ctx.fillStyle = '#fecb00'; ctx.beginPath(); ctx.moveTo(10, -15); ctx.lineTo(-10, -15); ctx.lineTo(10, 15); ctx.fill(); // Triangle
                    ctx.restore();
                    return;
                }

                if (this.type === 'boss_missile') {
                    ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(0, 0, 8, 0, 6.28); ctx.fill();
                    ctx.strokeStyle = '#ff003c'; ctx.lineWidth = 4; ctx.beginPath(); ctx.arc(0, 0, 8, 0, 6.28); ctx.stroke();
                }
                else if (this.type === 'sniper_shot') {
                    ctx.fillStyle = '#ff0000'; ctx.beginPath(); ctx.arc(0, 0, 4, 0, 6.28); ctx.fill();
                }
                else if (this.type === 'warsaw') {
                    ctx.fillStyle = '#fff'; ctx.fillRect(-6, -4, 12, 4);
                    ctx.fillStyle = '#f00'; ctx.fillRect(-6, 0, 12, 4);
                }
                else if (this.type === 'cevapi') {
                    for (let i = -1; i <= 1; i++) {
                        ctx.fillStyle = '#6d4c41'; ctx.beginPath(); ctx.roundRect(-8, i * 5 - 2, 16, 4, 2); ctx.fill();
                        ctx.fillStyle = '#3e2723'; ctx.fillRect(-4, i * 5 - 2, 2, 4); ctx.fillRect(2, i * 5 - 2, 2, 4);
                    }
                }
                else if (this.type === 'cevapi_hot') {
                    for (let i = -1; i <= 1; i++) {
                        ctx.fillStyle = '#800000'; ctx.beginPath(); ctx.roundRect(-8, i * 5 - 2, 16, 4, 2); ctx.fill();
                        ctx.fillStyle = '#ff4500'; ctx.fillRect(-4, i * 5 - 2, 2, 4); ctx.fillRect(2, i * 5 - 2, 2, 4);
                    }
                    ctx.shadowColor = '#f00'; ctx.shadowBlur = 10;
                }
                else if (this.type === 'ajvar') {
                    ctx.fillStyle = '#c0392b'; ctx.beginPath(); ctx.arc(0, 0, 10, 0, 6.28); ctx.fill();
                    ctx.fillStyle = '#f1c40f'; ctx.beginPath(); ctx.arc(0, -6, 6, 0, 6.28); ctx.fill();
                    ctx.fillStyle = 'white'; ctx.font = "10px Arial"; ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.fillText("HOT", 0, 2);
                }
                else if (this.type === 'rakija') {
                    ctx.rotate(-this.rotation); ctx.rotate(Math.sin(state.frames * 0.2) * 0.5);
                    ctx.fillStyle = 'rgba(200,240,255,0.6)'; ctx.beginPath(); ctx.rect(-5, -10, 10, 20); ctx.fill();
                    ctx.fillStyle = '#002395'; ctx.fillRect(-5, -5, 10, 8);
                    ctx.fillStyle = '#aaa'; ctx.fillRect(-3, -14, 6, 4);
                }
                else if (this.type === 'pyramid') {
                    ctx.fillStyle = '#00ff00';
                    ctx.beginPath(); ctx.moveTo(0, -20); ctx.lineTo(15, 15); ctx.lineTo(-15, 15); ctx.fill();
                    ctx.fillStyle = '#fff'; ctx.globalCompositeOperation = 'lighter';
                    ctx.beginPath(); ctx.arc(0, 0, 5, 0, 6.28); ctx.fill();
                }
                ctx.restore();
            }
        }
        class Zone {
            constructor(x, y, type, dur, overrideDamage = 0) { this.x = x; this.y = y; this.life = dur; this.maxLife = dur; this.radius = 90; this.type = type; this.overrideDamage = overrideDamage; if (type === 'blast') this.radius = 120; if (type === 'valk_swing') this.radius = 160; if (type === 'flame_trail') this.radius = 50; if (type === 'spike_burst') this.radius = 30; if (type === 'taco_blaster') this.radius = 40; if (type === 'tempo_wave') this.radius = 10; if (type === 'piano_warning' || type === 'piano_impact') this.radius = 360; if (type === 'musical_blast') this.radius = 80; if (type === 'judgment_beam') this.radius = 120; }
            update() {
                this.life--;
                if (this.type === 'blast' || this.type === 'valk_swing' || this.type === 'shield_push' || this.type === 'taunt_ring' || this.type === 'spike_burst' || this.type === 'musical_blast' || this.type === 'piano_impact') return this.life <= 0;

                // Damage Scaling for Zone Attacks
                let timeMinutes = state.gameTime / 60;
                let damageMultiplier = 1.0;
                if (timeMinutes > 10) {
                    damageMultiplier = 1 + (timeMinutes - 10) * 0.05;
                }

                // MODIFIED: TEMPO WAVE NOW RESPECTS RED LIGHT/GREEN LIGHT (MOVEMENT)
                if (this.type === 'tempo_wave') {
                    this.radius += 15;
                    const maxRad = 800;

                    if (this.radius > maxRad) return true;

                    // Only damage if player is moving
                    if (Math.hypot(player.x - this.x, player.y - this.y) < this.radius + player.radius &&
                        Math.hypot(player.x - this.x, player.y - this.y) > this.radius - 40) {

                        if (!godMode && player.invincible <= 0 && player.moving) {
                            let scaledDmg = 45 * damageMultiplier;
                            player.hp -= scaledDmg;
                            spawnDamageText(player.x, player.y - 60, Math.floor(scaledDmg), 'player');
                            player.invincible = 20;
                            if (player.hp <= 0) triggerDeath();
                        }
                    }
                    return this.life <= 0;
                }

                if (this.type === 'judgment_beam') {
                    if (this.life % 5 === 0) { // Damage ticks
                        let d = this.overrideDamage; // {aimAngle, damageVal}
                        let len = 3000;
                        let ex = this.x + Math.cos(d.aimAngle) * len;
                        let ey = this.y + Math.sin(d.aimAngle) * len;

                        if (lineCircleCollide(player.x, player.y, this.x, this.y, ex, ey, this.radius)) {
                            if (!godMode && player.invincible <= 0) {
                                let tickDmg = d.damageVal / 10; // Distribute stored damage
                                if (tickDmg < 50) tickDmg = 50; // Minimum damage

                                player.hp -= tickDmg;
                                spawnDamageText(player.x, player.y - 50, Math.floor(tickDmg), 'player');
                                addShake(15);
                                if (player.hp <= 0) triggerDeath();
                            }
                        }

                        // Kill friendly units instantly
                        state.friendlyUnits.forEach(u => {
                            if (!u.dead && lineCircleCollide(u.x, u.y, this.x, this.y, ex, ey, this.radius)) {
                                u.takeDamage(9999);
                                spawnDamageText(u.x, u.y - 50, "JUDGED", 'crit');
                            }
                        });
                    }
                    return this.life <= 0;
                }

                if (this.type === 'piano_warning') {
                    if (this.life <= 0) {
                        state.zones.push(new Zone(this.x, this.y, 'piano_impact', 20));
                        // Deal damage
                        if (Math.hypot(player.x - this.x, player.y - this.y) < this.radius && !godMode && player.invincible <= 0) {
                            player.hp -= 60;
                            spawnDamageText(player.x, player.y - 60, "CRUSHED", 'player');
                            addShake(30);
                            player.invincible = 30;
                            if (player.hp <= 0) triggerDeath();
                        }
                        state.friendlyUnits.forEach(u => {
                            if (!u.dead && Math.hypot(u.x - this.x, u.y - this.y) < this.radius) {
                                u.takeDamage(10);
                            }
                        });
                        // Player version does damage to enemies
                        if (this.overrideDamage === 'player') {
                            let dmg = 100 + state.level;
                            state.enemies.forEach(e => {
                                if (Math.hypot(e.x - this.x, e.y - this.y) < this.radius) {
                                    e.takeDamage(dmg, true, 'piano');
                                    // Knockback
                                    let ang = Math.atan2(e.y - this.y, e.x - this.x);
                                    e.pushX = Math.cos(ang) * 20;
                                    e.pushY = Math.sin(ang) * 20;
                                }
                            });
                        }
                        return true;
                    }
                    return false;
                }
                if (this.type === 'musical_blast') {
                    // Damage to player if spawned by Wraith
                    if (Math.hypot(player.x - this.x, player.y - this.y) < this.radius && !godMode && player.invincible <= 0) {
                        let scaledDmg = 10 * damageMultiplier;
                        player.hp -= scaledDmg;
                        spawnDamageText(player.x, player.y - 40, Math.floor(scaledDmg), 'player');
                        player.invincible = 30;
                        if (player.hp <= 0) triggerDeath();
                    }
                    return this.life <= 0;
                }

                if (this.type === 'taco_blaster') {
                    if (this.life < 60) {
                        if (this.life % 5 === 0) { // Damage ticks
                            let d = this.overrideDamage; // {aimAngle}
                            let len = 3000;
                            let ex = this.x + Math.cos(d.aimAngle) * len;
                            let ey = this.y + Math.sin(d.aimAngle) * len;

                            if (lineCircleCollide(player.x, player.y, this.x, this.y, ex, ey, 40)) {
                                if (!godMode && player.invincible <= 0) {
                                    let scaledDmg = 20 * damageMultiplier;
                                    player.hp -= scaledDmg;
                                    spawnDamageText(player.x, player.y - 50, Math.floor(scaledDmg), 'player');
                                    addShake(5);
                                    if (player.hp <= 0) triggerDeath();
                                }
                            }
                        }
                    }
                    return this.life <= 0;
                }

                if (this.type === 'berserk_spin') {
                    if (this.life % 10 === 0) {
                        let dmg = this.overrideDamage;
                        state.enemies.forEach(e => {
                            if (Math.hypot(e.x - this.x, e.y - this.y) < 160) {
                                e.takeDamage(dmg, true, 'berserk');
                                createParticle(e.x, e.y, '#f00', 'blood', 1);
                            }
                        });
                    }
                    let unit = state.friendlyUnits.find(u => u.isBerserk);
                    if (unit) { this.x = unit.x; this.y = unit.y; }
                    return this.life <= 0;
                }

                if (this.type === 'flame_trail') {
                    if (state.frames % 10 === 0) {
                        state.enemies.forEach(e => {
                            if (Math.hypot(e.x - this.x, e.y - this.y) < this.radius) {
                                let baseDmg = player.weapons.burek.damage * 0.25;
                                let dmg = calcDamage(Math.max(1, baseDmg));
                                e.takeDamage(dmg.d, false, 'flame_trail');
                                createParticle(e.x, e.y, '#ff5e00', 'spark', 0.5);
                            }
                        });
                    }
                    if (state.frames % 5 === 0) createParticle(this.x + (Math.random() - 0.5) * 40, this.y + (Math.random() - 0.5) * 40, '#ff5e00', 'fire', 1.0);
                }
                else if (this.type === 'fire' && state.frames % 10 === 0) state.enemies.forEach(e => {
                    if (Math.hypot(e.x - this.x, e.y - this.y) < this.radius) {
                        let dmg = calcDamage(player.weapons.rakija.damage);
                        e.takeDamage(dmg.d, false, 'zone');
                        createParticle(e.x, e.y, '#00ffff', 'fire', 0.5);
                    }
                });
                return this.life <= 0;
            }
            draw(cX, cY) {
                if (this.type === 'tempo_wave') {
                    ctx.save(); ctx.translate(this.x - cX, this.y - cY);
                    // Indicate Danger Level
                    if (player.moving) {
                        ctx.strokeStyle = '#ff003c'; // RED if moving
                        ctx.fillStyle = 'rgba(255, 0, 60, 0.2)';
                    } else {
                        ctx.strokeStyle = '#00f3ff'; // BLUE if safe
                        ctx.fillStyle = 'rgba(0, 243, 255, 0.1)';
                    }
                    ctx.lineWidth = 15;
                    ctx.beginPath(); ctx.arc(0, 0, this.radius, 0, 6.28); ctx.stroke();
                    ctx.fill();
                    ctx.restore();
                    return;
                }
                if (this.type === 'judgment_beam') {
                    // Handled in Beam class logic mostly, but if using Zone for hit detection, the beam draw is triggered there.
                    // Reusing Logic: Actually, Zone logic draws its own if specific.
                    // Let's draw it here for the Zone:
                    let d = this.overrideDamage; // {aimAngle}
                    ctx.save(); ctx.translate(this.x - cX, this.y - cY); ctx.rotate(d.aimAngle);

                    let width = this.radius * 2;
                    // Gradient for beam
                    let grad = ctx.createLinearGradient(0, -width / 2, 0, width / 2);
                    grad.addColorStop(0, 'rgba(255,215,0,0)');
                    grad.addColorStop(0.2, 'rgba(255,215,0,0.5)');
                    grad.addColorStop(0.5, '#fff');
                    grad.addColorStop(0.8, 'rgba(255,215,0,0.5)');
                    grad.addColorStop(1, 'rgba(255,215,0,0)');

                    ctx.fillStyle = grad;
                    ctx.fillRect(0, -width / 2, 3000, width);

                    // Intense central core
                    ctx.fillStyle = 'rgba(255,255,255,0.8)';
                    ctx.fillRect(0, -width / 4, 3000, width / 2);

                    ctx.restore();
                    return;
                }
                if (this.type === 'piano_warning') {
                    ctx.save(); ctx.translate(this.x - cX, this.y - cY);
                    ctx.globalAlpha = 0.5;
                    ctx.fillStyle = '#ff003c';
                    let p = 1 - (this.life / this.maxLife);
                    ctx.beginPath(); ctx.arc(0, 0, this.radius * p, 0, 6.28); ctx.fill();
                    ctx.strokeStyle = '#ff003c'; ctx.lineWidth = 2;
                    ctx.beginPath(); ctx.arc(0, 0, this.radius, 0, 6.28); ctx.stroke();

                    // Falling Piano Visual
                    let dropH = this.life * 10;
                    ctx.font = (this.radius / 2) + "px Arial"; ctx.textAlign = "center"; ctx.textBaseline = "middle";
                    ctx.fillStyle = '#fff';
                    ctx.fillText("üéπ", 0, -dropH);
                    ctx.restore();
                    return;
                }
                if (this.type === 'piano_impact' || this.type === 'musical_blast') {
                    ctx.save(); ctx.translate(this.x - cX, this.y - cY);
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.fillStyle = this.type === 'musical_blast' ? '#00f3ff' : '#ff003c';
                    let s = this.type === 'musical_blast' ? (1 - this.life / 20) : 1;
                    ctx.beginPath(); ctx.arc(0, 0, this.radius * s, 0, 6.28); ctx.fill();
                    ctx.restore();
                    return;
                }
                if (this.type === 'taco_blaster') {
                    let d = this.overrideDamage; // {aimAngle}
                    ctx.save(); ctx.translate(this.x - cX, this.y - cY); ctx.rotate(d.aimAngle);

                    ctx.save();
                    let shake = (this.life > 60) ? Math.random() * 2 : 0;
                    ctx.translate(shake, shake);
                    ctx.fillStyle = '#e67e22'; ctx.beginPath(); ctx.arc(0, 0, 30, Math.PI * 0.5, Math.PI * 1.5); ctx.fill();
                    ctx.fillStyle = '#27ae60'; ctx.fillRect(-5, -25, 5, 50);
                    ctx.fillStyle = '#c0392b'; ctx.fillRect(-2, -20, 5, 40);
                    ctx.restore();

                    if (this.life > 60) {
                        ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)'; ctx.lineWidth = 2; ctx.setLineDash([10, 10]);
                        ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(3000, 0); ctx.stroke();
                    } else {
                        let beamWidth = 60 * Math.sin((60 - this.life) / 60 * Math.PI); // Pulse
                        ctx.strokeStyle = '#fff'; ctx.lineWidth = beamWidth;
                        ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(3000, 0); ctx.stroke();
                        ctx.strokeStyle = '#2ecc71'; ctx.lineWidth = beamWidth * 1.5;
                        ctx.globalAlpha = 0.5;
                        ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(3000, 0); ctx.stroke();
                        ctx.globalAlpha = 1;
                    }
                    ctx.restore();
                    return;
                }
                if (this.type === 'spike_burst') {
                    ctx.save(); ctx.translate(this.x - cX, this.y - cY);
                    let p = this.life / this.maxLife;
                    ctx.scale(1.5, 1.5);
                    let grad = ctx.createLinearGradient(0, 10, 0, -50);
                    grad.addColorStop(0, '#555');
                    grad.addColorStop(0.5, '#aaa');
                    grad.addColorStop(1, '#ff003c');
                    ctx.fillStyle = grad;
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(0, -50 * p); ctx.lineTo(8, 0); ctx.lineTo(-8, 0);
                    ctx.moveTo(-15, -40 * p); ctx.lineTo(-5, 5); ctx.lineTo(-25, 5);
                    ctx.moveTo(15, -40 * p); ctx.lineTo(25, 5); ctx.lineTo(5, 5);
                    ctx.fill();
                    ctx.stroke();
                    ctx.restore();
                    return;
                }
                if (this.type === 'flame_trail') {
                    ctx.save(); ctx.translate(this.x - cX, this.y - cY);
                    let p = this.life / this.maxLife;
                    ctx.globalAlpha = p;
                    let g = ctx.createRadialGradient(0, 0, 10, 0, 0, this.radius);
                    g.addColorStop(0, '#ffcc00'); g.addColorStop(1, 'rgba(255,0,0,0)');
                    ctx.fillStyle = g;
                    ctx.beginPath(); ctx.arc(0, 0, this.radius, 0, 6.28); ctx.fill();
                    ctx.restore();
                    return;
                }
                if (this.type === 'shield_push') {
                    ctx.save(); ctx.translate(this.x - cX, this.y - cY);
                    let p = 1 - (this.life / this.maxLife);
                    ctx.strokeStyle = `rgba(255, 255, 255, ${1 - p})`;
                    ctx.lineWidth = 10;
                    ctx.beginPath(); ctx.arc(0, 0, player.weapons.harmonika.range * 1.5 * p, 0, 6.28); ctx.stroke();
                    ctx.restore();
                    return;
                }
                if (this.type === 'taunt_ring') {
                    return;
                }
                if (this.type === 'valk_swing' || this.type === 'berserk_spin') {
                    ctx.save();
                    ctx.translate(this.x - cX, this.y - cY);

                    let progress = 1 - (this.life / this.maxLife);
                    if (this.type === 'berserk_spin') progress = (state.frames * 0.5) % 6.28;
                    else progress = progress * Math.PI * 2;

                    let angle = progress;
                    if (this.type === 'valk_swing') {
                        ctx.beginPath();
                        ctx.arc(0, 0, this.radius, angle - 1, angle, false);
                        ctx.lineWidth = 40;
                        ctx.strokeStyle = `rgba(255, 255, 255, ${0.5 * (this.life / this.maxLife)})`;
                        ctx.stroke();
                    }

                    ctx.rotate(angle);
                    ctx.translate(20, 0);

                    let grad = ctx.createLinearGradient(0, 0, 100, 0);
                    grad.addColorStop(0, '#aaa'); grad.addColorStop(1, '#fff');
                    ctx.fillStyle = grad;
                    ctx.beginPath(); ctx.moveTo(0, -5); ctx.lineTo(120, 0); ctx.lineTo(0, 5); ctx.fill();
                    ctx.fillStyle = '#444'; ctx.fillRect(-5, -15, 10, 30);
                    ctx.fillStyle = '#654321'; ctx.fillRect(-25, -4, 20, 8);

                    ctx.restore();
                    return;
                }
                if (this.type === 'blast') {
                    ctx.save(); ctx.translate(this.x - cX, this.y - cY);
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.fillStyle = `rgba(255, 100, 0, ${this.life / 20})`;
                    ctx.beginPath(); ctx.arc(0, 0, this.radius * (1 - this.life / 20), 0, 6.28); ctx.fill();
                    ctx.restore();
                    return;
                }
                ctx.save(); ctx.translate(this.x - cX, this.y - cY); let p = 1 + Math.sin(state.frames * 0.1) * 0.1; ctx.scale(p, p);
                let g = ctx.createRadialGradient(0, 0, 10, 0, 0, this.radius);
                g.addColorStop(0, 'rgba(0,255,255,0.4)'); g.addColorStop(1, 'rgba(0,50,255,0)');
                ctx.globalCompositeOperation = 'lighter'; ctx.fillStyle = g; ctx.beginPath(); ctx.arc(0, 0, this.radius, 0, 6.28); ctx.fill(); ctx.restore();
            }
        }

        class Enemy {
            constructor(overrideType = null, x = null, y = null) {
                if (overrideType === 'BOSS' || overrideType === 'MINI_BOSS' || overrideType === 'BRAXTON' || overrideType === 'POLYRHYTHM' || overrideType === 'TEZINA') {
                    this.type = overrideType;
                    let a = Math.random() * 6.28, d = (Math.max(W, H) / 2) + 200;
                    if (x !== null && y !== null) { this.x = x; this.y = y; }
                    else { this.x = player.x + Math.cos(a) * d; this.y = player.y + Math.sin(a) * d; }
                } else {
                    if (x !== null && y !== null) {
                        this.x = x; this.y = y;
                    } else {
                        let a = Math.random() * 6.28, d = (Math.max(W, H) / 2) + 150;
                        this.x = player.x + Math.cos(a) * d; this.y = player.y + Math.sin(a) * d;
                    }
                    this.type = overrideType || 'promaja';
                }

                if (this.type === 'BOSS' || this.type === 'WARLORD_CLONE') {
                    this.maxHp = 5000;
                    this.hp = 5000;
                } else if (this.type === 'BRAXTON') {
                    this.maxHp = 15000;
                    this.hp = 15000;
                } else if (this.type === 'POLYRHYTHM') {
                    this.maxHp = 12000;
                    this.hp = 12000;
                } else if (this.type === 'TEZINA') {
                    this.maxHp = 25000; // Fixed 25000 HP
                    this.hp = this.maxHp;
                } else {
                    let baseHp = 40;
                    if (this.type === 'promaja') baseHp = 25 + state.level * 1;
                    else if (this.type === 'yugo') baseHp = 180 + state.level * 8;
                    else if (this.type === 'hornet') baseHp = 20 + state.level * 1;
                    else if (this.type === 'snajper') baseHp = 10 + state.level * 1;
                    else if (this.type === 'medic') baseHp = 300 + state.level * 5;
                    else if (this.type === 'lovac') baseHp = 500 + state.level * 10;
                    else if (this.type === 'jurisnik') baseHp = 350 + state.level * 8;
                    else if (this.type === 'NOLAN') baseHp = 600;
                    else if (this.type === 'MINI_BOSS') baseHp = 800 + state.level * 100;
                    else if (this.type === 'RHYTHM_WRAITH') baseHp = 10; // Weak

                    const minutes = state.gameTime / 60;

                    if (minutes < 5) {
                        this.maxHp = baseHp + (minutes * 8);
                    } else if (minutes < 10) {
                        let hardBase = baseHp * 1.5;
                        this.maxHp = hardBase * (1 + minutes * 0.25);
                    } else {
                        this.maxHp = baseHp * (1 + Math.pow(minutes, 0.9) * 0.3);
                    }
                    this.hp = this.maxHp;
                }

                this.baseSpeed = 2;
                this.radius = 20;
                this.frozen = 0;
                this.hitFlash = 0;
                this.pushX = 0; this.pushY = 0;
                this.burnTimer = 0;
                this.burekHitTimer = 0;
                this.percentBurnLeft = 0;
                this.dead = false;
                this.deathAnimationTimer = 0;

                if (this.type === 'BOSS' || this.type === 'WARLORD_CLONE') {
                    this.baseSpeed = 2.5; this.radius = 60;
                    this.attackTimer = 150; this.damageCooldown = 0;
                }
                else if (this.type === 'BRAXTON') {
                    this.baseSpeed = 1.8; this.radius = 80;
                    this.attackTimer = 300;
                    this.summonTimer = 600;
                    this.damageCooldown = 0;
                }
                else if (this.type === 'POLYRHYTHM') {
                    this.baseSpeed = 4.0; this.radius = 50; // Fast
                    this.attackTimer = 180;
                    this.shieldTimer = 0;
                    this.hasHealed = false;
                    this.phase2 = false;
                    this.abilityCycle = 0;
                }
                else if (this.type === 'TEZINA') {
                    this.baseSpeed = 2.2; this.radius = 70;
                    this.attackTimer = 180;
                    this.damageCooldown = 0;
                    this.storedDamage = 0;
                    this.judgmentPhase = 0;
                    this.judgmentThresholds = [0.7, 0.4, 0.1];
                    this.isAbsorbing = false;
                    this.absorbTimer = 0;
                    this.isFiring = false;
                    this.fireTimer = 0;
                    this.isCharging = false;
                    this.chargeTimer = 0;
                    this.isDashing = false;
                    this.dashTimer = 0;
                    this.summonTimer = 0;
                    this.trackAngle = 0; // For beam warning
                    this.beamWarningTimer = 0;
                }
                else if (this.type === 'MINI_BOSS') {
                    this.baseSpeed = 2.2; this.radius = 45;
                    this.attackTimer = 200; this.damageCooldown = 0;
                }
                else if (this.type === 'promaja') { this.baseSpeed = 1.8 + Math.random(); this.radius = 22; }
                else if (this.type === 'yugo') { this.baseSpeed = 1.4; this.radius = 35; this.angle = 0; }
                else if (this.type === 'hornet') { this.baseSpeed = 4.2; this.radius = 15; }
                else if (this.type === 'medic') { this.baseSpeed = 1.5; this.radius = 25; }
                else if (this.type === 'lovac') {
                    this.baseSpeed = 3.8; this.radius = 25;
                    this.isPhased = false;
                    this.phaseCD = 0;
                    this.phaseTimer = 0;
                    this.attackAnim = 0;
                }
                else if (this.type === 'jurisnik') {
                    this.baseSpeed = 5.5; this.radius = 18;
                    this.isDashing = false;
                    this.dashTimer = 0;
                    this.dashCooldown = 0;
                    this.dashVulnerable = 0;
                    this.dashVelX = 0;
                    this.dashVelY = 0;
                    this.telegraphTimer = 0;
                    this.attackAnim = 0;
                }
                else if (this.type === 'NOLAN') { this.baseSpeed = 5.0; this.radius = 20; this.attackTimer = 120; }
                else if (this.type === 'snajper') {
                    this.baseSpeed = 1.5; this.radius = 15;
                    this.state = 'move'; this.snajperTimer = 0;
                    this.targetX = 0; this.targetY = 0;
                }
                else if (this.type === 'RHYTHM_WRAITH') { this.baseSpeed = 3.0; this.radius = 15; }

                this.speed = this.baseSpeed;
            }
            update() {
                // Death Logic for Te≈æina (Animation Phase)
                if (this.dead) {
                    if (this.deathAnimationTimer > 0) {
                        this.deathAnimationTimer--;
                        if (state.frames % 5 === 0) createParticle(this.x + (Math.random() - 0.5) * 100, this.y + (Math.random() - 0.5) * 100, '#fff', 'plasma', 5);
                        if (this.deathAnimationTimer <= 0) {
                            this.finishDeath(); // Actually remove and spawn crate
                        }
                    }
                    return;
                }

                // GLOBAL UPDATES
                if (this.hitFlash > 0) this.hitFlash--;
                this.pushX *= 0.9; this.pushY *= 0.9;

                if (this.type === 'BOSS' || this.type === 'BRAXTON' || this.type === 'POLYRHYTHM' || this.type === 'TEZINA') {
                    document.getElementById('boss-hud').style.display = 'flex';
                    document.getElementById('boss-bar-fill').style.width = (this.hp / this.maxHp * 100) + '%';
                }
                if (this.type === 'BOSS') document.getElementById('boss-name').innerText = "TURBO FOLK WARLORD";
                if (this.type === 'BRAXTON') document.getElementById('boss-name').innerText = "BRAXTON-INITE";
                if (this.type === 'POLYRHYTHM') document.getElementById('boss-name').innerText = "THE POLYRHYTHM";
                if (this.type === 'TEZINA') document.getElementById('boss-name').innerText = "TE≈ΩINA PRESUDE";

                if (this.burekHitTimer > 0) this.burekHitTimer--;

                if (this.burnTimer > 0) {
                    this.burnTimer--;
                    if (state.frames % 15 === 0) {
                        this.takeDamage(5, false, 'burn');
                        createParticle(this.x, this.y, '#ff5e00', 'fire', 0.5);
                    }
                }

                if (this.percentBurnLeft > 0) {
                    if (state.frames % 10 === 0) {
                        this.percentBurnLeft--;
                        let p = (this.type.includes('BOSS') || this.type === 'BRAXTON' || this.type === 'POLYRHYTHM' || this.type === 'TEZINA') ? 0.001 : 0.01;
                        let dmg = Math.max(1, this.maxHp * p);
                        this.takeDamage(dmg, false, 'burn_percent');
                        createParticle(this.x, this.y, '#ff0000', 'smoke', 0.5);
                    }
                }

                // --- BOSS BEHAVIORS ---
                if ((this.type === 'BOSS' || this.type === 'MINI_BOSS' || this.type === 'WARLORD_CLONE')) {
                    if (this.damageCooldown > 0) this.damageCooldown--;
                    this.attackTimer--;
                    if (this.attackTimer === 30) {
                        spawnDamageText(this.x, this.y - 80, "!!!", 'normal');
                        createParticle(this.x, this.y, '#f00', 'plasma', 5);
                    }
                    if (this.attackTimer <= 0) {
                        this.attackTimer = this.type.includes('BOSS') ? 150 : 200;
                        state.projectiles.push(new Projectile(this.x, this.y, player, 'boss_missile'));
                    }
                }

                if (this.type === 'BRAXTON') {
                    let dist = Math.hypot(player.x - this.x, player.y - this.y);
                    if (dist > 900) {
                        let angle = Math.random() * 6.28;
                        this.x = player.x + Math.cos(angle) * 400;
                        this.y = player.y + Math.sin(angle) * 400;
                        spawnDamageText(this.x, this.y - 80, "TOO FAR!", 'normal');
                    }

                    this.summonTimer--;
                    if (this.summonTimer <= 0) {
                        this.summonTimer = 600;
                        state.enemies.push(new Enemy('NOLAN', this.x + 50, this.y));
                        spawnDamageText(this.x, this.y - 100, "SUMMON!", 'normal');
                    }

                    this.attackTimer--;
                    if (this.attackTimer <= 0) {
                        this.attackTimer = 300;
                        let randAng = Math.random() * 6.28;
                        let tx = player.x + Math.cos(randAng) * 250;
                        let ty = player.y + Math.sin(randAng) * 250;
                        let aimAng = Math.atan2(player.y - ty, player.x - tx);
                        state.zones.push(new Zone(tx, ty, 'taco_blaster', 120, { aimAngle: aimAng }));
                    }

                    if (this.damageCooldown > 0) this.damageCooldown--;
                }

                if (this.type === 'POLYRHYTHM') {
                    // Shield Logic
                    if (this.shieldTimer > 0) this.shieldTimer--;

                    // Heal Logic
                    if (!this.hasHealed && this.hp < (this.maxHp * 0.6)) {
                        this.hasHealed = true;
                        this.hp = Math.min(this.maxHp, this.hp + (this.maxHp * 0.7));
                        this.shieldTimer = 1800; // 30 seconds
                        spawnDamageText(this.x, this.y - 100, "RHYTHMIC HEAL", 'crit');
                        createParticle(this.x, this.y, '#00f3ff', 'plasma', 10);
                    }

                    // Phase 2 Logic
                    if (this.hp < (this.maxHp * 0.5) && !this.phase2) {
                        this.phase2 = true;
                        this.shieldTimer = 2700; // Gain shield again for 45s
                        spawnDamageText(this.x, this.y - 100, "SHIELD RESTORED", 'crit');
                        const cap = document.getElementById('boss-caption');
                        cap.innerText = "I FEEL THE MUSIC BEATING IN MY HEART!";
                        cap.style.opacity = '1';
                        setTimeout(() => cap.style.opacity = '0', 4000);
                    }

                    // FIX: Spawn Wraiths in Phase 2
                    if (this.phase2 && state.frames % 180 === 0) {
                        state.enemies.push(new Enemy('RHYTHM_WRAITH', this.x + (Math.random() - 0.5) * 100, this.y + (Math.random() - 0.5) * 100));
                    }

                    // Abilities
                    this.attackTimer--;
                    if (this.attackTimer <= 0) {
                        this.attackTimer = 180;
                        this.abilityCycle = (this.abilityCycle + 1) % 2;

                        if (this.abilityCycle === 0) {
                            // Tempo Wave - BUFFED in Zone class
                            state.zones.push(new Zone(this.x, this.y, 'tempo_wave', 240));
                            spawnDamageText(this.x, this.y - 80, "TEMPO WAVE!", 'normal');
                        } else {
                            // Piano Smash
                            state.zones.push(new Zone(player.x, player.y, 'piano_warning', 150)); // 2.5s warning
                        }
                    }

                    // Dodging Movement
                    if (state.frames % 60 === 0) {
                        let randA = Math.random() * 6.28;
                        this.pushX += Math.cos(randA) * 15;
                        this.pushY += Math.sin(randA) * 15;
                    }

                    if (this.damageCooldown > 0) this.damageCooldown--;
                }

                if (this.type === 'TEZINA') {
                    if (this.damageCooldown > 0) this.damageCooldown--;

                    // JUDGMENT LOGIC
                    if (this.judgmentThresholds.length > 0) {
                        let nextThresh = this.judgmentThresholds[0];
                        if (this.hp / this.maxHp <= nextThresh && !this.isAbsorbing && !this.isFiring && this.beamWarningTimer <= 0) {
                            this.judgmentThresholds.shift();
                            this.isAbsorbing = true;
                            this.absorbTimer = 300; // 5 seconds of absorb
                            this.storedDamage = 0;
                            spawnDamageText(this.x, this.y - 100, "JUDGMENT!", 'crit');
                            const cap = document.getElementById('boss-caption');
                            cap.innerText = "JUDGMENT HAS BEGUN";
                            cap.style.opacity = '1';
                            setTimeout(() => cap.style.opacity = '0', 3000);
                            createParticle(this.x, this.y, '#fff', 'plasma', 20);
                        }
                    }

                    if (this.isAbsorbing) {
                        this.absorbTimer--;
                        // Tracking player for beam aim
                        this.trackAngle = Math.atan2(player.y - this.y, player.x - this.x);

                        if (this.absorbTimer <= 0) {
                            this.isAbsorbing = false;
                            this.beamWarningTimer = 90; // 1.5s total warning (1.0 track, 0.5 lock)
                        }
                        return; // IMMOBILE
                    }

                    if (this.beamWarningTimer > 0) {
                        this.beamWarningTimer--;
                        // First 60 frames (1s): Tracking
                        if (this.beamWarningTimer > 30) {
                            this.trackAngle = Math.atan2(player.y - this.y, player.x - this.x);
                        }
                        // Last 30 frames (0.5s): Locked (trackAngle doesn't update)

                        if (this.beamWarningTimer <= 0) {
                            // FIRE
                            this.isFiring = true;
                            this.fireTimer = 180; // 3 seconds beam
                            let dmg = Math.max(500, this.storedDamage);
                            state.zones.push(new Zone(this.x, this.y, 'judgment_beam', 180, { aimAngle: this.trackAngle, damageVal: dmg }));
                            spawnDamageText(this.x, this.y - 100, "VERDICT: GUILTY", 'crit');
                        }
                        return; // IMMOBILE
                    }

                    if (this.isFiring) {
                        this.fireTimer--;
                        if (this.fireTimer <= 0) this.isFiring = false;
                        return; // IMMOBILE
                    }

                    // SWORD OF VERDICT LOGIC
                    if (!this.isCharging && !this.isDashing && Math.random() < 0.005) {
                        this.isCharging = true;
                        this.chargeTimer = 90; // 1.5s
                        this.chargeTarget = { x: player.x, y: player.y };
                        spawnDamageText(this.x, this.y - 80, "VERDICT...", 'normal');
                    }

                    if (this.isCharging) {
                        this.chargeTimer--;
                        if (this.chargeTimer <= 0) {
                            this.isCharging = false;
                            this.isDashing = true;
                            this.dashTimer = 60; // 1s dash
                            let ang = Math.atan2(this.chargeTarget.y - this.y, this.chargeTarget.x - this.x);
                            this.dashVel = { x: Math.cos(ang) * 15, y: Math.sin(ang) * 15 }; // Fast
                            // White flash
                            state.flashAlpha = 0.5;
                        }
                        return; // IMMOBILE
                    }

                    if (this.isDashing) {
                        this.dashTimer--;
                        this.x += this.dashVel.x;
                        this.y += this.dashVel.y;
                        if (state.frames % 5 === 0) state.zones.push(new Zone(this.x, this.y, 'valk_swing', 10, 150)); // Sword swings
                        if (this.dashTimer <= 0) this.isDashing = false;
                        return;
                    }

                    // SUMMON WARLORD
                    let warlords = state.enemies.filter(e => e.type === 'WARLORD_CLONE').length;
                    if (warlords === 0 && Math.random() < 0.002) {
                        state.enemies.push(new Enemy('WARLORD_CLONE', this.x + 100, this.y));
                        spawnDamageText(this.x, this.y - 80, "WITNESS SUMMONED", 'normal');
                    }

                    // Speed debuff if Warlord exists
                    if (warlords > 0) this.speed = this.baseSpeed * 0.7;
                    else this.speed = this.baseSpeed;

                }

                if (this.type === 'medic') {
                    if (state.frames % 60 === 0) {
                        let healCount = 0;
                        state.enemies.forEach(e => {
                            if (e !== this && e.type !== 'medic' && e.hp < e.maxHp && Math.hypot(e.x - this.x, e.y - this.y) < 200) {
                                e.hp = Math.min(e.maxHp, e.hp + 50);
                                createParticle(e.x, e.y, '#00ff41', 'heal', 2);
                                let ang = Math.atan2(e.y - this.y, e.x - this.x);
                                state.beams.push(new Beam(this.x, this.y, ang, 'heal')); // VISUAL BEAM
                                healCount++;
                            }
                        });
                        if (healCount > 0) spawnDamageText(this.x, this.y - 40, "HEAL", 'normal');
                    }
                }

                if (this.type === 'lovac') {
                    if (this.attackAnim > 0) this.attackAnim--;

                    // Phase Logic
                    if (this.phaseCD > 0) this.phaseCD--;
                    if (this.isPhased) {
                        this.phaseTimer--;
                        if (this.phaseTimer <= 0) {
                            this.isPhased = false;
                            spawnDamageText(this.x, this.y - 40, "VISIBLE", 'normal');
                        }
                    } else {
                        let d = Math.hypot(player.x - this.x, player.y - this.y);
                        if (d < 250 && this.phaseCD <= 0) {
                            this.isPhased = true;
                            this.phaseTimer = 120; // 2 seconds
                            this.phaseCD = 420; // 7 seconds
                            spawnDamageText(this.x, this.y - 40, "PHASED", 'normal');
                            createParticle(this.x, this.y, '#fff', 'smoke', 5);
                        }
                    }
                }

                if (this.type === 'jurisnik') {
                    if (this.attackAnim > 0) this.attackAnim--;
                    if (this.dashCooldown > 0) this.dashCooldown--;
                    if (this.dashVulnerable > 0) this.dashVulnerable--;

                    // Count how many jurisniks are currently dashing
                    let dashingCount = state.enemies.filter(e => e.type === 'jurisnik' && e.isDashing).length;

                    if (this.isDashing) {
                        // Execute dash
                        this.dashTimer--;
                        this.x += this.dashVelX;
                        this.y += this.dashVelY;

                        // Light trail particles
                        if (state.frames % 2 === 0) {
                            createParticle(this.x, this.y, '#ffea00', 'spark', 1);
                        }

                        if (this.dashTimer <= 0) {
                            this.isDashing = false;
                            this.dashVulnerable = 60; // 1 second vulnerable after dash
                            this.dashCooldown = 300; // 5 second cooldown
                        }
                    } else if (this.telegraphTimer > 0) {
                        // Telegraphing - about to dash
                        this.telegraphTimer--;
                        // Store dash direction toward current player position
                        let ang = Math.atan2(player.y - this.y, player.x - this.x);
                        this.dashVelX = Math.cos(ang) * 20; // Fast dash speed
                        this.dashVelY = Math.sin(ang) * 20;

                        if (this.telegraphTimer <= 0) {
                            this.isDashing = true;
                            this.dashTimer = 15; // 0.25 seconds of dash
                            spawnDamageText(this.x, this.y - 40, "LIGHT DASH!", 'crit');
                            addShake(5);
                        }
                    } else if (!this.dashVulnerable && this.dashCooldown <= 0 && dashingCount < 3) {
                        // Check if close enough to dash
                        let d = Math.hypot(player.x - this.x, player.y - this.y);
                        if (d < 400 && d > 50) {
                            // Start telegraph
                            this.telegraphTimer = 30; // 0.5 second telegraph
                            spawnDamageText(this.x, this.y - 40, "!", 'normal');
                            createParticle(this.x, this.y, '#fff', 'plasma', 3);
                        }
                    }
                }

                if (this.frozen > 0 && this.type !== 'TEZINA') { // Te≈æina immune to freeze
                    this.frozen--;
                    if (state.frames % 20 === 0) createParticle(this.x, this.y, '#0ff', 'spark');
                    return;
                }

                if (this.type === 'NOLAN') {
                    this.attackTimer--;
                    if (this.attackTimer <= 0) {
                        this.attackTimer = 120;
                        state.projectiles.push(new Projectile(this.x, this.y, player, 'warsaw'));
                    }
                }

                if (this.type === 'snajper') {
                    let dist = Math.hypot(player.x - this.x, player.y - this.y);
                    if (this.state === 'move') {
                        if (dist < 400) { this.state = 'charge'; this.snajperTimer = 60; }
                        else {
                            let ang = Math.atan2(player.y - this.y, player.x - this.x);
                            this.x += Math.cos(ang) * this.speed + this.pushX;
                            this.y += Math.sin(ang) * this.speed + this.pushY;
                        }
                    } else if (this.state === 'charge') {
                        this.snajperTimer--;
                        if (this.snajperTimer <= 0) { this.state = 'fire'; }
                    } else if (this.state === 'fire') {
                        state.projectiles.push(new Projectile(this.x, this.y, player, 'sniper_shot'));
                        this.state = 'cooldown'; this.snajperTimer = 120;
                    } else if (this.state === 'cooldown') {
                        this.snajperTimer--;
                        let ang = Math.atan2(player.y - this.y, player.x - this.x);
                        this.x -= Math.cos(ang) * 1.0; this.y -= Math.sin(ang) * 1.0;
                        if (this.snajperTimer <= 0) this.state = 'move';
                    }
                    return;
                }

                let targetX = player.x, targetY = player.y;
                let taunter = state.friendlyUnits.find(u => u.taunting && !u.dead);
                if (taunter) { targetX = taunter.x; targetY = taunter.y; }
                else {
                    let closestFriendly = null; let minFD = 999;
                    state.friendlyUnits.forEach(u => {
                        if (!u.dead) {
                            if (u.type === 'mage' && u.invisibleTimer > 0) return;
                            let d = Math.hypot(u.x - this.x, u.y - this.y);
                            if (d < minFD) { minFD = d; closestFriendly = u; }
                        }
                    });
                    if (closestFriendly) {
                        let dPlayer = Math.hypot(player.x - this.x, player.y - this.y);
                        if (minFD < dPlayer && dPlayer > 120) { targetX = closestFriendly.x; targetY = closestFriendly.y; }
                        if (minFD < closestFriendly.radius + this.radius) {
                            let ang = Math.atan2(this.y - closestFriendly.y, this.x - closestFriendly.x);
                            this.x = closestFriendly.x + Math.cos(ang) * (closestFriendly.radius + this.radius);
                            this.y = closestFriendly.y + Math.sin(ang) * (closestFriendly.radius + this.radius);
                        }
                    }
                }

                let dx = targetX - this.x, dy = targetY - this.y, dist = Math.sqrt(dx * dx + dy * dy); this.angle = Math.atan2(dy, dx);
                let px = 0, py = 0;
                if (this.type !== 'BOSS' && this.type !== 'MINI_BOSS' && this.type !== 'BRAXTON' && this.type !== 'POLYRHYTHM' && this.type !== 'TEZINA') {
                    state.enemies.forEach(o => { if (o !== this) { let ox = this.x - o.x, oy = this.y - o.y, od = Math.sqrt(ox * ox + oy * oy); if (od < this.radius + o.radius) { px += ox / od; py += oy / od; } } });
                }
                this.x += (Math.cos(this.angle) * this.speed + px * 0.5) + this.pushX; this.y += (Math.sin(this.angle) * this.speed + py * 0.5) + this.pushY;

                if (this.type === 'yugo' && state.frames % 5 === 0) createParticle(this.x - Math.cos(this.angle) * 35, this.y - Math.sin(this.angle) * 35, '#333', 'smoke', 0.5);
            }

            takeDamage(a, crit, source) {
                // Lovac phased: still takes damage but is hard to target

                if (this.type === 'TEZINA' && this.isAbsorbing) {
                    this.storedDamage += a;
                    spawnDamageText(this.x, this.y - 50, "ABSORBED", false);
                    return;
                }

                if (this.type === 'BOSS' || this.type === 'MINI_BOSS' || this.type === 'BRAXTON' || this.type === 'POLYRHYTHM' || this.type === 'TEZINA' || this.type === 'WARLORD_CLONE') {
                    if (this.damageCooldown > 0 && source !== 'burn_percent') return;
                    if (source !== 'burn_percent') this.damageCooldown = 5;

                    // Polyrhythm Shield
                    if (this.type === 'POLYRHYTHM' && this.shieldTimer > 0) {
                        a *= 0.15; // Reduce by 85%
                        spawnDamageText(this.x, this.y - 50, "SHIELDED", false);
                    }
                }
                this.hp -= a;
                if (source !== 'burn_percent') this.hitFlash = 5;
                spawnDamageText(this.x, this.y - 30, a, crit);
                let c = '#880000';
                if (this.type === 'yugo') c = '#000';
                if (this.type === 'hornet') c = '#bfff00';
                if (this.type === 'BOSS' || this.type === 'MINI_BOSS') c = '#ff00ff';
                if (this.type === 'BRAXTON') c = '#2ecc71';
                if (this.type === 'snajper') c = '#ff0000';
                if (this.type === 'medic') c = '#fff';
                if (this.type === 'lovac') c = '#000';
                if (this.type === 'jurisnik') c = '#ffea00';
                if (this.type === 'NOLAN') c = '#fff';
                if (this.type === 'POLYRHYTHM') c = '#00f3ff';
                if (this.type === 'TEZINA') c = '#ffd700';
                if (source !== 'burn_percent') for (let i = 0; i < 3; i++)createParticle(this.x, this.y, c, 'spark');

                if (this.hp <= 0 && !this.dead) { // Trigger Death
                    this.dead = true;

                    // If it's Te≈æina, delay removal for animation
                    if (this.type === 'TEZINA') {
                        this.deathAnimationTimer = 120; // 2 seconds
                        addShake(100);
                        spawnDamageText(this.x, this.y - 100, "JUDGMENT ENDED", 'crit');
                        document.getElementById('boss-hud').style.display = 'none'; // Remove HUD immediately
                        state.tezinaActive = false; // Stop boss logic logic
                        return; // Don't do standard cleanup yet
                    }

                    this.finishDeath();
                }
            }

            finishDeath() {
                if (this.type !== 'WARLORD_CLONE') state.score++;
                if (this.type === 'BOSS' || this.type === 'BRAXTON' || this.type === 'POLYRHYTHM' || this.type === 'TEZINA') {
                    state.bossActive = false;
                    document.getElementById('boss-hud').style.display = 'none';
                    addShake(50); state.flashAlpha = 1;
                    if (this.type !== 'TEZINA') spawnDamageText(this.x, this.y - 100, "BOSS DEFEATED", 'crit');

                    if (this.type === 'BRAXTON') {
                        state.braxtonActive = false;
                        state.crates.push(new Crate(this.x, this.y));
                    } else if (this.type === 'POLYRHYTHM') {
                        state.polyrhythmActive = false;
                        state.crates.push(new Crate(this.x, this.y, 'musical'));
                    } else if (this.type === 'TEZINA') {
                        state.tezinaActive = false;
                        state.crates.push(new Crate(this.x, this.y, 'platinum')); // PLATINUM CRATE
                    } else {
                        for (let i = 0; i < 50; i++) state.gems.push(new Gem(this.x + (Math.random() - 0.5) * 200, this.y + (Math.random() - 0.5) * 200, 150));
                    }
                }
                else if (this.type === 'MINI_BOSS') {
                    spawnDamageText(this.x, this.y - 80, "MINI BOSS DOWN", 'crit');
                    for (let i = 0; i < 10; i++) state.gems.push(new Gem(this.x + (Math.random() - 0.5) * 100, this.y + (Math.random() - 0.5) * 100, 100));
                }
                else if (this.type === 'RHYTHM_WRAITH') {
                    state.zones.push(new Zone(this.x, this.y, 'musical_blast', 20));
                    createParticle(this.x, this.y, '#00f3ff', 'spark', 5);
                }
                else if (this.type === 'WARLORD_CLONE') {
                    spawnDamageText(this.x, this.y - 80, "WITNESS SILENCED", 'normal');
                }
                else { state.gems.push(new Gem(this.x, this.y)); }

                // Standard Particles
                let c = '#880000';
                if (this.type === 'TEZINA') c = '#ffd700';
                for (let i = 0; i < 8; i++)createParticle(this.x, this.y, c, 'blood', 1.5);
                if (this.type === 'yugo' || this.type === 'BOSS') { addShake(5); for (let i = 0; i < 15; i++)createParticle(this.x, this.y, '#f39c12', 'fire', 2); }
            }

            draw(cX, cY) {
                if (this.dead && this.deathAnimationTimer <= 0) return;

                ctx.save(); ctx.translate(this.x - cX, this.y - cY);

                // Death Anim Scaling
                if (this.deathAnimationTimer > 0) {
                    let s = this.deathAnimationTimer / 120;
                    ctx.scale(s, s);
                    ctx.rotate(state.frames * 0.2);
                    ctx.globalAlpha = s;
                }

                if (this.hitFlash > 0) {
                    ctx.globalCompositeOperation = 'lighter'; ctx.fillStyle = '#fff';
                    ctx.beginPath(); ctx.arc(0, 0, this.radius, 0, 6.28); ctx.fill();
                } else {
                    if (this.type === 'BOSS' || this.type === 'MINI_BOSS' || this.type === 'WARLORD_CLONE') {
                        ctx.rotate(state.frames * 0.02); let scale = this.type === 'MINI_BOSS' ? 0.6 : 1;
                        ctx.scale(scale, scale);
                        ctx.strokeStyle = this.type === 'WARLORD_CLONE' ? '#777' : '#ff003c'; ctx.lineWidth = 4;
                        ctx.beginPath(); ctx.moveTo(-30, -30); ctx.lineTo(30, -30); ctx.lineTo(0, 30); ctx.closePath(); ctx.stroke();
                        ctx.fillStyle = '#300'; ctx.fill();
                        ctx.fillStyle = this.type === 'WARLORD_CLONE' ? '#777' : '#f00'; ctx.beginPath(); ctx.arc(0, 0, 10, 0, 6.28); ctx.fill();
                    }
                    else if (this.type === 'BRAXTON') {
                        ctx.fillStyle = '#ff5e00'; ctx.beginPath(); ctx.moveTo(0, -20); ctx.lineTo(40, 40); ctx.lineTo(-40, 40); ctx.fill();
                        ctx.fillStyle = '#2ecc71'; ctx.fillRect(-20, 0, 40, 5);
                        ctx.fillStyle = '#fff'; ctx.fillRect(-30, 20, 60, 5);
                        ctx.fillStyle = '#e67e22'; ctx.beginPath(); ctx.ellipse(0, -20, 60, 15, 0, 0, 6.28); ctx.fill();
                        ctx.beginPath(); ctx.ellipse(0, -35, 20, 20, 0, 0, 6.28); ctx.fill();
                        ctx.strokeStyle = '#f1c40f'; ctx.lineWidth = 3; ctx.stroke();
                    }
                    else if (this.type === 'POLYRHYTHM') {
                        let s = 1 + Math.sin(state.frames * 0.2) * 0.1;
                        ctx.scale(s, s);

                        // Core
                        ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(0, 0, 25, 0, 6.28); ctx.fill();

                        // Equalizer bars rotating
                        ctx.strokeStyle = '#00f3ff'; ctx.lineWidth = 4;
                        for (let i = 0; i < 8; i++) {
                            let h = 10 + Math.sin(state.frames * 0.5 + i) * 15;
                            ctx.save(); ctx.rotate((state.frames * 0.05) + (i * (Math.PI / 4)));
                            ctx.beginPath(); ctx.moveTo(35, -5); ctx.lineTo(35, 5); ctx.stroke();
                            ctx.fillStyle = '#00f3ff'; ctx.fillRect(40, -h / 2, 5, h);
                            ctx.restore();
                        }

                        if (this.shieldTimer > 0) {
                            ctx.strokeStyle = 'rgba(0, 243, 255, 0.6)'; ctx.lineWidth = 5;
                            ctx.beginPath(); ctx.arc(0, 0, 55, 0, 6.28); ctx.stroke();
                        }
                    }
                    else if (this.type === 'TEZINA') {
                        // BEAM WARNING LINE
                        if (this.beamWarningTimer > 0) {
                            ctx.save();
                            let isLocked = this.beamWarningTimer <= 30;
                            ctx.rotate(this.trackAngle);

                            if (isLocked) {
                                if (state.frames % 4 === 0) ctx.strokeStyle = '#fff'; else ctx.strokeStyle = '#f00';
                                ctx.lineWidth = 4;
                            } else {
                                ctx.strokeStyle = 'rgba(255,0,0,0.5)';
                                ctx.lineWidth = 2;
                            }

                            ctx.setLineDash([20, 10]);
                            ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(3000, 0); ctx.stroke();
                            ctx.restore();
                        }

                        // Judgment Model
                        let bob = Math.sin(state.frames * 0.05) * 5;
                        ctx.translate(0, bob);

                        if (this.isAbsorbing) {
                            ctx.strokeStyle = '#fff'; ctx.lineWidth = 3;
                            ctx.beginPath(); ctx.arc(0, 0, 80 + Math.sin(state.frames * 0.2) * 10, 0, 6.28); ctx.stroke();
                            ctx.fillStyle = 'rgba(255,255,255,0.2)'; ctx.fill();
                        }

                        // Cloak
                        ctx.fillStyle = '#1a1a1a';
                        ctx.beginPath(); ctx.moveTo(0, -50); ctx.lineTo(40, 60); ctx.lineTo(-40, 60); ctx.fill();

                        // Hood
                        ctx.fillStyle = '#333';
                        ctx.beginPath(); ctx.arc(0, -40, 20, 3.14, 0); ctx.lineTo(20, -20); ctx.lineTo(-20, -20); ctx.fill();

                        // Void Face
                        ctx.fillStyle = '#000';
                        ctx.beginPath(); ctx.arc(0, -35, 12, 0, 6.28); ctx.fill();
                        // Glowing eyes
                        ctx.fillStyle = '#ffd700'; ctx.shadowColor = '#ffd700'; ctx.shadowBlur = 10;
                        ctx.fillRect(-6, -38, 4, 4); ctx.fillRect(2, -38, 4, 4);
                        ctx.shadowBlur = 0;

                        // Scales (Left Hand)
                        ctx.save(); ctx.translate(-50, 0);
                        ctx.fillStyle = '#b8860b'; ctx.fillRect(-2, -30, 4, 30); // pole
                        ctx.fillRect(-20, -30, 40, 4); // beam
                        ctx.beginPath(); ctx.arc(-20, 0, 10, 0, 3.14); ctx.stroke(); // pans
                        ctx.beginPath(); ctx.arc(20, 0, 10, 0, 3.14); ctx.stroke();
                        ctx.restore();

                        // Sword (Right Hand) - Drawn if charging/dashing
                        if (this.isCharging || this.isDashing) {
                            ctx.save(); ctx.translate(40, -10); ctx.rotate(-0.5);
                            ctx.fillStyle = '#fff'; ctx.shadowColor = '#fff'; ctx.shadowBlur = 15;
                            ctx.fillRect(-5, -60, 10, 70);
                            ctx.shadowBlur = 0;
                            ctx.fillStyle = '#b8860b'; ctx.fillRect(-15, 0, 30, 5);
                            ctx.restore();
                        } else {
                            // Resting arm
                            ctx.fillStyle = '#1a1a1a'; ctx.fillRect(20, -20, 10, 40);
                        }
                    }
                    else if (this.type === 'NOLAN') {
                        ctx.beginPath(); ctx.arc(0, 0, 20, 0, 6.28); ctx.clip();
                        ctx.fillStyle = '#fff'; ctx.fillRect(-20, -20, 40, 20);
                        ctx.fillStyle = '#f00'; ctx.fillRect(-20, 0, 40, 20);
                        ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(-8, -5, 3, 0, 6.28); ctx.arc(8, -5, 3, 0, 6.28); ctx.fill();
                    }
                    else if (this.type === 'snajper') {
                        // NEW SNIPER MODEL
                        let aim = Math.atan2(player.y - this.y, player.x - this.x);
                        ctx.rotate(aim);
                        ctx.fillStyle = '#343'; ctx.beginPath(); ctx.arc(0, 0, 12, 0, 6.28); ctx.fill(); // Body
                        ctx.fillStyle = '#111'; ctx.fillRect(0, -3, 22, 6); // Gun barrel
                        ctx.strokeStyle = '#555'; ctx.lineWidth = 2; ctx.strokeRect(-5, -3, 10, 6); // Gun body
                        if (this.state === 'charge') {
                            ctx.fillStyle = '#f00'; ctx.beginPath(); ctx.arc(0, 0, 2, 0, 6.28); ctx.fill(); // Laser eye
                            // Laser sight
                            ctx.save(); ctx.globalCompositeOperation = 'lighter';
                            ctx.strokeStyle = `rgba(255, 0, 0, ${0.3 + Math.random() * 0.4})`; ctx.lineWidth = 1;
                            ctx.beginPath(); ctx.moveTo(0, 0);
                            let dx = player.x - this.x; let dy = player.y - this.y;
                            let dist = Math.sqrt(dx * dx + dy * dy);
                            ctx.lineTo(dist, 0); ctx.stroke(); ctx.restore();
                            ctx.fillStyle = '#fff'; ctx.fillRect(-15, -20, 30 * (1 - this.snajperTimer / 60), 3); // Charge bar
                        }
                    }
                    else if (this.type === 'lovac') {
                        ctx.rotate(this.angle + 1.57);
                        if (this.isPhased) ctx.globalAlpha = 0.1; // 90% invisible

                        // Cloak
                        ctx.fillStyle = '#800000';
                        ctx.beginPath();
                        ctx.moveTo(0, -25);
                        ctx.quadraticCurveTo(20, 0, 15, 25);
                        ctx.quadraticCurveTo(0, 20, -15, 25);
                        ctx.quadraticCurveTo(-20, 0, 0, -25);
                        ctx.fill();

                        // Hood
                        ctx.fillStyle = '#500';
                        ctx.beginPath(); ctx.arc(0, -10, 12, 0, Math.PI, true); ctx.fill();

                        // Eyes (Only visible when not phased or very faint)
                        ctx.fillStyle = '#f00';
                        ctx.shadowColor = '#f00'; ctx.shadowBlur = 10;
                        ctx.beginPath(); ctx.arc(-5, -12, 2, 0, 6.28); ctx.arc(5, -12, 2, 0, 6.28); ctx.fill();
                        ctx.shadowBlur = 0;

                        // Knife Hand
                        ctx.save();
                        ctx.translate(15, 0);
                        if (this.attackAnim > 0) {
                            // Swing animation
                            let swing = (this.attackAnim / 20) * Math.PI;
                            ctx.rotate(-swing);
                        }
                        ctx.fillStyle = '#ccc';
                        ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(5, -20); ctx.lineTo(-5, -20); ctx.fill(); // Blade
                        ctx.fillStyle = '#333'; ctx.fillRect(-3, 0, 6, 5); // Handle
                        ctx.restore();

                        ctx.globalAlpha = 1;
                    }
                    else if (this.type === 'jurisnik') {
                        ctx.rotate(this.angle + 1.57);

                        // Slim, agile body with light glow
                        let glowIntensity = this.isDashing ? 30 : (this.telegraphTimer > 0 ? 15 : 5);
                        ctx.shadowColor = '#ffea00';
                        ctx.shadowBlur = glowIntensity;

                        // Vulnerable state - dimmer
                        if (this.dashVulnerable > 0) {
                            ctx.globalAlpha = 0.6;
                            ctx.shadowBlur = 2;
                        }

                        // Main body - slim humanoid
                        ctx.fillStyle = this.isDashing ? '#fff' : '#ffea00';
                        ctx.beginPath();
                        ctx.ellipse(0, 0, 8, 14, 0, 0, 6.28);
                        ctx.fill();

                        // Core light energy
                        ctx.fillStyle = '#fff';
                        ctx.beginPath();
                        ctx.ellipse(0, -2, 4, 6, 0, 0, 6.28);
                        ctx.fill();

                        // Head
                        ctx.fillStyle = this.isDashing ? '#fff' : '#ffe066';
                        ctx.beginPath();
                        ctx.arc(0, -16, 6, 0, 6.28);
                        ctx.fill();

                        // Eyes - glowing
                        ctx.fillStyle = '#000';
                        ctx.beginPath();
                        ctx.arc(-2, -17, 1.5, 0, 6.28);
                        ctx.arc(2, -17, 1.5, 0, 6.28);
                        ctx.fill();

                        // Arms/Claws reaching forward
                        ctx.strokeStyle = this.isDashing ? '#fff' : '#ffcc00';
                        ctx.lineWidth = 3;
                        let armSwing = Math.sin(state.frames * 0.3) * 0.3;

                        ctx.save();
                        ctx.translate(-6, -5);
                        ctx.rotate(-0.5 + armSwing);
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(-8, -12);
                        ctx.stroke();
                        ctx.restore();

                        ctx.save();
                        ctx.translate(6, -5);
                        ctx.rotate(0.5 - armSwing);
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(8, -12);
                        ctx.stroke();
                        ctx.restore();

                        // Telegraph indicator
                        if (this.telegraphTimer > 0) {
                            ctx.strokeStyle = '#fff';
                            ctx.lineWidth = 2;
                            let rad = 25 + (30 - this.telegraphTimer);
                            ctx.beginPath();
                            ctx.arc(0, 0, rad, 0, 6.28);
                            ctx.stroke();
                        }

                        // Dash trail effect
                        if (this.isDashing) {
                            ctx.globalCompositeOperation = 'lighter';
                            ctx.fillStyle = 'rgba(255, 234, 0, 0.3)';
                            ctx.beginPath();
                            ctx.ellipse(0, 15, 10, 25, 0, 0, 6.28);
                            ctx.fill();
                        }

                        ctx.shadowBlur = 0;
                        ctx.globalAlpha = 1;
                    }
                    else if (this.type === 'medic') {
                        ctx.rotate(this.angle + 1.57);
                        ctx.fillStyle = '#eee'; ctx.beginPath(); ctx.arc(0, 0, 14, 0, 6.28); ctx.fill(); // Body
                        ctx.fillStyle = '#0f0'; ctx.font = "bold 16px Arial"; ctx.fillText('+', -5, 5); // Cross
                        ctx.fillStyle = '#ccc'; ctx.fillRect(8, -5, 8, 10); // Healing Gun
                        ctx.fillStyle = '#0f0'; ctx.fillRect(16, -2, 4, 4); // Gun Tip
                    }
                    else if (this.type === 'promaja') {
                        ctx.rotate(state.frames * 0.2); ctx.shadowBlur = 10; ctx.shadowColor = 'rgba(200, 255, 255, 0.5)';
                        ctx.strokeStyle = 'rgba(220, 240, 255, 0.8)'; ctx.lineWidth = 2;
                        ctx.beginPath(); ctx.arc(0, 0, 8, 0, 5); ctx.stroke();
                        ctx.rotate(2); ctx.beginPath(); ctx.arc(0, 0, 16, 0, 4.5); ctx.stroke();
                        ctx.rotate(2); ctx.strokeStyle = 'rgba(220, 240, 255, 0.4)'; ctx.beginPath(); ctx.arc(0, 0, 24, 0, 3); ctx.stroke();
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.9)'; ctx.beginPath(); ctx.arc(0, 0, 4, 0, 6.28); ctx.fill();
                    }
                    else if (this.type === 'yugo') {
                        ctx.rotate(this.angle); ctx.fillStyle = '#800000'; ctx.fillRect(-20, -15, 40, 30);
                        ctx.fillStyle = '#300000'; ctx.fillRect(-5, -13, 20, 26);
                        ctx.globalCompositeOperation = 'lighter'; ctx.fillStyle = 'rgba(255, 255, 200, 0.4)';
                        ctx.beginPath(); ctx.moveTo(20, -10); ctx.lineTo(120, -30); ctx.lineTo(120, 30); ctx.lineTo(20, 10); ctx.fill();
                        ctx.fillStyle = '#ff0'; ctx.fillRect(18, -12, 4, 6); ctx.fillRect(18, 6, 4, 6);
                    }
                    else if (this.type === 'RHYTHM_WRAITH') {
                        ctx.fillStyle = '#00f3ff'; ctx.beginPath(); ctx.moveTo(0, -10); ctx.lineTo(10, 10); ctx.lineTo(-10, 10); ctx.fill();
                    }
                    else {
                        // HORNET
                        ctx.rotate(this.angle + 1.57); ctx.fillStyle = 'rgba(255,255,255,0.6)';
                        let flap = Math.sin(state.frames * 0.8) * 5;
                        ctx.beginPath(); ctx.ellipse(8 + flap, -5, 5, 12, 0.5, 0, 6.28); ctx.fill(); // Wing 1
                        ctx.beginPath(); ctx.ellipse(-8 - flap, -5, 5, 12, -0.5, 0, 6.28); ctx.fill(); // Wing 2
                        ctx.fillStyle = '#f1c40f'; ctx.beginPath(); ctx.ellipse(0, 0, 8, 14, 0, 0, 6.28); ctx.fill();
                        ctx.fillStyle = '#000'; ctx.fillRect(-6, -2, 12, 2); ctx.fillRect(-6, 4, 12, 2);
                        ctx.fillStyle = '#f00'; ctx.beginPath(); ctx.moveTo(0, 14); ctx.lineTo(2, 20); ctx.lineTo(-2, 20); ctx.fill();
                    }
                }
                if (this.frozen > 0) { ctx.fillStyle = 'rgba(0,255,255,0.4)'; ctx.beginPath(); ctx.arc(0, 0, this.radius + 5, 0, 6.28); ctx.fill(); }
                if (this.burnTimer > 0) { ctx.fillStyle = 'rgba(255, 100, 0, 0.5)'; ctx.beginPath(); ctx.arc(0, 0, this.radius + 5, 0, 6.28); ctx.fill(); }
                if (this.percentBurnLeft > 0) {
                    ctx.strokeStyle = '#ff4500'; ctx.lineWidth = 2;
                    ctx.beginPath(); ctx.arc(0, 0, this.radius + 2, 0, 6.28); ctx.stroke();
                }
                ctx.restore();
            }
        }

        function checkLevelUp() {
            if (state.xp >= state.nextLevelXp) {
                state.xp -= state.nextLevelXp;
                state.level++;
                player.maxHp += 10; player.hp += 10;
                spawnDamageText(player.x, player.y - 60, "+10 HP", 'normal');
                state.nextLevelXp = Math.floor(state.nextLevelXp + 50 + (state.level * 25));
                isPaused = true;
                generateCards();
            }
        }

        function spawnBoss() {
            if (state.bossActive) return;
            state.bossActive = true;
            state.enemies = state.enemies.filter(e => e.type === 'MINI_BOSS');
            state.flashAlpha = 1.0;
            addShake(50);
            document.getElementById('boss-hud').style.display = 'flex';
            state.enemies.push(new Enemy('BOSS'));
        }

        function triggerBraxtonCutscene() {
            if (state.braxtonSpawned) return;
            state.braxtonSpawned = true;
            state.enemies = [];
            isCutscene = true;
            const cutscene = document.getElementById('braxton-cutscene');
            const dialogue = document.getElementById('braxton-dialogue');
            const taco = document.getElementById('taco-anim');
            cutscene.style.display = 'flex';
            taco.style.display = 'block';
            dialogue.style.display = 'none';

            setTimeout(() => {
                taco.style.display = 'none';
                dialogue.style.display = 'block';
                const lines = ["THIS SUCKS!", "YOU SUCK!", "GAME BAD!"];
                let lineIdx = 0;
                const lineInterval = setInterval(() => {
                    if (lineIdx < lines.length) { dialogue.innerText = lines[lineIdx]; lineIdx++; }
                    else {
                        clearInterval(lineInterval);
                        setTimeout(() => {
                            cutscene.style.display = 'none';
                            isCutscene = false;
                            state.braxtonActive = true;
                            let a = Math.random() * 6.28, d = 600;
                            let bx = player.x + Math.cos(a) * d, by = player.y + Math.sin(a) * d;
                            state.enemies.push(new Enemy('BRAXTON', bx, by));
                            spawnDamageText(bx, by - 100, "BRAXTON HAS ARRIVED", 'normal');
                        }, 1000);
                    }
                }, 1000);
            }, 2000);
        }

        function triggerMusicalIntro() {
            if (state.polyrhythmSpawned) return;
            state.polyrhythmSpawned = true;
            isCutscene = true;
            state.enemies = []; // Despawn standard enemies
            const overlay = document.getElementById('musical-overlay');
            overlay.style.display = 'block';

            const notes = ['üéµ', 'üé∂', 'üéº', 'üéπ', 'üéª'];
            for (let i = 0; i < 30; i++) {
                let el = document.createElement('div');
                el.className = 'note-anim';
                el.innerText = notes[Math.floor(Math.random() * notes.length)];
                el.style.left = (Math.random() * 100) + '%';
                el.style.top = (Math.random() * 100) + '%';
                el.style.setProperty('--tx', (Math.random() * 200 - 100) + 'px');
                el.style.setProperty('--ty', (Math.random() * 200 - 100) + 'px');
                el.style.setProperty('--rot', (Math.random() * 360) + 'deg');
                el.style.animationDelay = (Math.random() * 2) + 's';
                overlay.appendChild(el);
            }

            document.getElementById('boss-caption').style.opacity = '0';

            setTimeout(() => {
                overlay.innerHTML = '';
                overlay.style.display = 'none';
                isCutscene = false;
                state.polyrhythmActive = true;
                let a = Math.random() * 6.28, d = 600;
                let bx = player.x + Math.cos(a) * d, by = player.y + Math.sin(a) * d;
                state.enemies.push(new Enemy('POLYRHYTHM', bx, by));
                spawnDamageText(bx, by - 100, "THE POLYRHYTHM", 'crit');
            }, 2500);
        }

        function triggerClockIntro() {
            if (state.tezinaSpawned) return;
            state.tezinaSpawned = true;
            isCutscene = true;
            state.enemies = []; // Clear field
            const overlay = document.getElementById('clock-overlay');
            const hHand = document.getElementById('hand-hour');
            const mHand = document.getElementById('hand-minute');
            const text = document.getElementById('clock-text');

            overlay.style.display = 'flex';

            // Initial state
            hHand.style.transform = 'rotate(0deg)';
            mHand.style.transform = 'rotate(0deg)';
            text.style.opacity = '0';

            setTimeout(() => {
                // Animate to 12:20
                // Hour hand moves slightly (20/60 of 30deg) = 10deg
                // Minute hand moves to 4 (120deg)
                hHand.style.transform = 'rotate(10deg)';
                mHand.style.transform = 'rotate(120deg)';
                text.style.opacity = '1';
            }, 100);

            setTimeout(() => {
                overlay.style.display = 'none';
                isCutscene = false;
                state.tezinaActive = true;
                let a = Math.random() * 6.28, d = 600;
                let bx = player.x + Math.cos(a) * d, by = player.y + Math.sin(a) * d;
                state.enemies.push(new Enemy('TEZINA', bx, by));
                spawnDamageText(bx, by - 100, "JUDGMENT COMETH", 'crit');
            }, 3500);
        }

        function triggerCrateOpening(type = 'standard') {
            if (document.getElementById('crate-screen').style.display === 'flex') return;
            isPaused = true;

            const screen = document.getElementById('crate-screen');
            const anim = document.getElementById('crate-anim');
            const cardsDiv = document.getElementById('crate-cards');
            const btn = document.getElementById('crate-claim-btn');
            const title = document.getElementById('crate-title');
            const flash = document.getElementById('white-flash');

            cardsDiv.innerHTML = '';
            btn.style.opacity = '0';
            title.style.opacity = '0';
            anim.style.display = 'block';
            anim.style.transform = 'scale(1)';

            screen.style.display = 'flex';

            // Animation Sequence
            anim.className = 'crate-drop';
            anim.innerText = type === 'musical' ? 'üéµ' : 'üì¶';
            if (type === 'platinum') anim.innerText = 'üíé';

            setTimeout(() => {
                anim.className = 'crate-shake';
                setTimeout(() => {
                    flash.style.opacity = '1';
                    setTimeout(() => { flash.style.opacity = '0'; }, 500);
                    anim.style.display = 'none';
                    title.style.opacity = '1';
                    btn.style.opacity = '1';
                    if (type === 'musical') generateMusicalLoot();
                    else if (type === 'platinum') generatePlatinumLoot();
                    else generateCrateLoot();
                }, 1000);
            }, 500);
        }

        function generateCrateLoot() {
            crateRewards = [];
            let available = [];
            UPGRADES.forEach(u => {
                let currentLvl = 0;
                if (player.weapons[u.id]) currentLvl = player.weapons[u.id].level;
                else if (player.items[u.id] !== undefined) currentLvl = player.items[u.id];

                if (currentLvl < (u.max || 10)) {
                    available.push(u);
                }
            });

            for (let i = 0; i < 3; i++) {
                if (available.length > 0) {
                    let r = Math.floor(Math.random() * available.length);
                    crateRewards.push(available[r]);
                }
            }
            renderCrateCards(crateRewards);
        }

        function generateMusicalLoot() {
            crateRewards = SPECIAL_REWARDS;
            renderCrateCards(crateRewards);
        }

        function generatePlatinumLoot() {
            crateRewards = [];
            let rares = UPGRADES.filter(u => u.tier === 'rare' || u.tier === 'legendary');
            let available = [];
            UPGRADES.forEach(u => { available.push(u); });

            // 3 Guaranteed Rares (that you don't have maxed, ideally)
            for (let i = 0; i < 3; i++) {
                let r = rares[Math.floor(Math.random() * rares.length)];
                crateRewards.push(r);
            }
            // 2 Random
            for (let i = 0; i < 2; i++) {
                let r = available[Math.floor(Math.random() * available.length)];
                crateRewards.push(r);
            }
            renderCrateCards(crateRewards, true);
        }

        function renderCrateCards(list, platinum = false) {
            const container = document.getElementById('crate-cards');
            list.forEach(o => {
                const el = document.createElement('div'); el.className = 'card';
                if (o.tier === 'legendary') el.classList.add('legendary');
                if (o.tier === 'rare') el.classList.add('rare');
                if (platinum && (o.tier === 'rare' || o.tier === 'legendary')) el.classList.add('platinum');

                let lvlText = '';
                if (player.weapons[o.id]) lvlText = 'Lvl ' + (player.weapons[o.id].level + 1);
                else if (player.items[o.id] !== undefined) lvlText = 'Lvl ' + (player.items[o.id] + 1);

                el.innerHTML = `<div class="card-level">${lvlText}</div><div class="card-icon">${o.icon}</div><div class="card-name">${o.name}</div><div class="card-desc">${o.desc}</div>`;
                el.onclick = () => {
                    if (crateRewards === SPECIAL_REWARDS) {
                        applyUpgrade(o.id); document.getElementById('crate-screen').style.display = 'none'; isPaused = false;
                    }
                    // For other crates, clicking just visual, claim all button does the work
                };
                container.appendChild(el);
            });
            if (crateRewards === SPECIAL_REWARDS) document.getElementById('crate-claim-btn').style.display = 'none';
            else document.getElementById('crate-claim-btn').style.display = 'block';
        }

        function claimCrateRewards() {
            crateRewards.forEach(r => {
                applyUpgrade(r.id);
            });
            document.getElementById('crate-screen').style.display = 'none';
            state.crates = [];
            isPaused = false;
        }

        function updateHud() {
            document.getElementById('lvl-display').innerText = state.level;
            document.getElementById('score-display').innerText = state.score;
            document.getElementById('xp-fill').style.width = Math.min(100, (state.xp / state.nextLevelXp * 100)) + '%';
            document.getElementById('hp-fill').style.width = Math.max(0, (player.hp / player.maxHp * 100)) + '%';

            let m = Math.floor(state.gameTime / 60);
            let s = Math.floor(state.gameTime % 60);
            document.getElementById('timer-display').innerText =
                (m < 10 ? "0" + m : m) + ":" + (s < 10 ? "0" + s : s);
        }

        function gameLoop() {
            if (gameActive && !isPaused && !isCutscene) { update(); draw(); }
            else if (!gameActive) {
                ctx.fillStyle = '#050510'; ctx.fillRect(0, 0, W, H);
                state.backgroundStars.forEach(s => {
                    s.x -= 0.2; if (s.x < 0) s.x = W;
                    ctx.fillStyle = `rgba(255,255,255,${s.alpha})`; ctx.fillRect(s.x, s.y, s.size, s.size);
                });
            }
            requestAnimationFrame(gameLoop);
        }

        function getClosestEnemy() {
            let c = null, m = 800;
            state.enemies.forEach(e => {
                // Skip phased enemies (Lovac) - projectiles don't target them
                if (e.isPhased) return;
                let d = Math.hypot(e.x - player.x, e.y - player.y);
                if (d < m) { m = d; c = e; }
            });
            return c;
        }

        function spawnPerk() {
            let chance = 0.0008 * player.luck;
            if (Math.random() > chance) return;
            const types = ['health', 'magnet', 'nuke', 'freeze'];
            let dist = 300 + Math.random() * 400;
            let ang = Math.random() * 6.28;
            state.perks.push(new Perk(player.x + Math.cos(ang) * dist, player.y + Math.sin(ang) * dist, types[Math.floor(Math.random() * types.length)]));
        }

        function lineCircleCollide(px, py, ax, ay, bx, by, r) {
            const vX = bx - ax, vY = by - ay; const wX = px - ax, wY = py - ay;
            const c1 = wX * vX + wY * vY;
            if (c1 <= 0) return Math.hypot(px - ax, py - ay) < r;
            const c2 = vX * vX + vY * vY;
            if (c2 <= c1) return Math.hypot(px - bx, py - by) < r;
            const b = c1 / c2; const projX = ax + b * vX, projY = ay + b * vY;
            return Math.hypot(px - projX, py - projY) < r;
        }

        function spawnCircle(type, count) {
            spawnDamageText(player.x, player.y - 100, "‚ö†Ô∏è SWARM DETECTED ‚ö†Ô∏è", 'normal');
            for (let i = 0; i < count; i++) {
                let angle = (i / count) * 6.28;
                let dist = 800;
                state.enemies.push(new Enemy(type, player.x + Math.cos(angle) * dist, player.y + Math.sin(angle) * dist));
            }
        }

        function handleWaves() {
            if (state.braxtonActive || state.polyrhythmActive || state.tezinaActive) return;
            if (!spawningEnabled) return;

            let t = state.gameTime;

            // 14:00 - Polyrhythm Tease
            if (t === 840 && state.frames % 60 === 0) {
                const cap = document.getElementById('boss-caption');
                cap.innerText = "THE MUSIC, CAN YOU HEAR IT?";
                cap.style.opacity = '1';
                setTimeout(() => cap.style.opacity = '0', 4000);
            }

            // 15:00 - Polyrhythm Intro
            if (t >= 900 && t < 1200 && !state.polyrhythmSpawned) {
                triggerMusicalIntro();
                return;
            }

            // 20:00 - Te≈æina Presude Intro
            if (t >= 1200 && !state.tezinaSpawned) {
                triggerClockIntro();
                return;
            }

            // 10 MINUTE MARK - BRAXTON
            if (t >= 600 && t < 900 && !state.braxtonSpawned) {
                triggerBraxtonCutscene();
                return;
            }

            // SWARMS
            if (t >= 300 && !state.bossActive && state.frames % 60 === 0) {
                if (Math.random() < 0.01) {
                    let types = ['promaja', 'hornet', 'yugo'];
                    let chosen = types[Math.floor(Math.random() * types.length)];
                    let amount = 15 + Math.floor(t / 10);
                    spawnCircle(chosen, amount);
                }
            }

            // KRVAVI LOVAC SPAWN LOGIC (7 minutes / 420 seconds)
            if (t >= 420 && !state.bossActive) {
                if (state.frames % 500 === 0) {
                    state.enemies.push(new Enemy('lovac'));
                }
            }

            // SVJETLOSNI JURI≈†NIK SPAWN LOGIC (17 minutes / 1020 seconds)
            if (t >= 1020 && !state.bossActive) {
                if (state.frames % 400 === 0) {
                    state.enemies.push(new Enemy('jurisnik'));
                }
            }

            if (t < 300) {
                if (t < 60) {
                    if (state.frames % 90 === 0) state.enemies.push(new Enemy('promaja'));
                }
                else if (t < 120) {
                    if (state.frames % 60 === 0) state.enemies.push(new Enemy('promaja'));
                    if (state.frames % 120 === 0) state.enemies.push(new Enemy('hornet'));
                }
                else if (t < 180) {
                    if (state.frames % 40 === 0) state.enemies.push(new Enemy('promaja'));
                    if (state.frames % 80 === 0) state.enemies.push(new Enemy('hornet'));
                    if (state.frames % 300 === 0) state.enemies.push(new Enemy('yugo'));
                }
                else if (t < 240) {
                    if (state.frames % 30 === 0) state.enemies.push(new Enemy('promaja'));
                    if (state.frames % 60 === 0) state.enemies.push(new Enemy('hornet'));
                    if (state.frames % 120 === 0) state.enemies.push(new Enemy('yugo'));
                }
                else if (t < 300) {
                    if (state.frames % 20 === 0) state.enemies.push(new Enemy(Math.random() < 0.5 ? 'promaja' : 'hornet'));
                    if (state.frames % 80 === 0) state.enemies.push(new Enemy('yugo'));
                }
            }
            else if (t >= 300) {
                if (!state.bossSpawnedOnce) {
                    spawnBoss();
                    state.bossSpawnedOnce = true;
                }
                if (state.bossActive) {
                    if (state.frames % 100 === 0) state.enemies.push(new Enemy('promaja'));
                    if (state.frames % 200 === 0) state.enemies.push(new Enemy('hornet'));
                }
                else {
                    if (state.frames % 15 === 0) state.enemies.push(new Enemy(Math.random() < 0.5 ? 'promaja' : 'hornet'));
                    if (state.frames % 50 === 0) state.enemies.push(new Enemy('yugo'));

                    // SNIPER STARTS AT 6 MINUTES (360s)
                    if (t >= 360 && state.frames % 200 === 0) state.enemies.push(new Enemy('snajper'));

                    if (state.frames % 300 === 0) {
                        let medicCount = state.enemies.filter(e => e.type === 'medic').length;
                        if (medicCount < 3) {
                            state.enemies.push(new Enemy('medic'));
                        }
                    }

                    if (state.frames % 600 === 0) {
                        if (Math.random() < 0.05) state.enemies.push(new Enemy('MINI_BOSS'));
                    }
                }
            }
        }

        function update() {
            if (state.flashAlpha > 0) state.flashAlpha -= 0.02;

            let mx = 0, my = 0; if (keys['w'] || keys['arrowup']) my = -1; if (keys['s'] || keys['arrowdown']) my = 1; if (keys['a'] || keys['arrowleft']) mx = -1; if (keys['d'] || keys['arrowright']) mx = 1;

            // MOVING CHECK FOR POLYRHYTHM BOSS MECHANIC
            player.moving = (mx !== 0 || my !== 0);

            if (mx !== 0 || my !== 0) {
                let l = Math.sqrt(mx * mx + my * my);
                player.x += (mx / l) * player.speed;
                player.y += (my / l) * player.speed;
                player.facing = Math.atan2(my, mx);
            }

            if (player.invincible > 0) player.invincible--;

            if (player.regen > 0 && state.frames % 60 === 0 && player.hp < player.maxHp) { player.hp = Math.min(player.maxHp, player.hp + player.regen); updateHud(); spawnDamageText(player.x, player.y - 50, player.regen, true); }

            if (state.frames % 60 === 0) {
                state.gameTime++;
                updateHud();
            }

            // Rhythmic Buff Timer
            if (player.items.rhythmic_buff > 0) {
                state.rhythmicBuffTimer++;
                if (state.rhythmicBuffTimer > 1200) state.rhythmicBuffTimer = 0; // 20s cycle
                if (state.rhythmicBuffTimer === 1080) spawnDamageText(player.x, player.y - 60, "RHYTHMIC POWER", 'crit');
            }

            handleWaves();
            spawnPerk();

            state.friendlyUnits.forEach(u => u.update());

            const wc = player.weapons.cevapi;
            if (wc.level > 0) {
                wc.timer++;
                if (wc.timer > wc.cooldown) {
                    let t = getClosestEnemy();
                    if (t) {
                        state.projectiles.push(new Projectile(player.x, player.y, t, 'cevapi'));
                        wc.timer = 0;
                    }
                }

                // CEVAPI EVOLUTION LOGIC (Secondary Fire)
                if (wc.evolved) {
                    wc.grillAngle += 0.05;
                    if (state.frames % 60 === 0 && state.enemies.length > 0) {
                        // Calculate shot count based on overheat progress
                        let heatProgress = state.score - wc.lastBurstScore;
                        if (heatProgress > 100) heatProgress = 100;
                        if (heatProgress < 0) heatProgress = 0;
                        let extraShots = Math.floor((heatProgress / 100) * 4); // 0 to 4
                        if (heatProgress >= 90) extraShots = 4;
                        let totalShots = 3 + extraShots;

                        for (let i = 0; i < totalShots; i++) {
                            let t = state.enemies[Math.floor(Math.random() * state.enemies.length)];
                            let gX = player.x + Math.cos(wc.grillAngle) * 60;
                            let gY = player.y + Math.sin(wc.grillAngle) * 60;
                            state.projectiles.push(new Projectile(gX, gY, t, 'cevapi'));
                        }
                    }
                    if (state.score >= wc.lastBurstScore + 100 && state.score > 0) {
                        wc.lastBurstScore = state.score;
                        spawnDamageText(player.x, player.y - 60, "OVERHEAT!", 'crit');
                        addShake(20);
                        for (let i = 0; i < 25; i++) {
                            let ang = (i / 25) * 6.28;
                            let p = new Projectile(player.x, player.y, null, 'cevapi_hot');
                            p.vx = Math.cos(ang) * 10;
                            p.vy = Math.sin(ang) * 10;
                            state.projectiles.push(p);
                        }
                    }
                }
            }

            const wa = player.weapons.ajvar; if (wa.level > 0) { wa.timer++; if (wa.timer > wa.cooldown && state.enemies.length > 0) { let ts = state.enemies.filter(e => Math.hypot(e.x - player.x, e.y - player.y) < 700); if (ts.length) { state.projectiles.push(new Projectile(player.x, player.y, ts[Math.floor(Math.random() * ts.length)], 'ajvar')); wa.timer = 0; } } }
            const wr = player.weapons.rakija; if (wr.level > 0) { wr.timer++; if (wr.timer > wr.cooldown) { let t = getClosestEnemy(); if (t) { state.projectiles.push(new Projectile(player.x, player.y, t, 'rakija')); wr.timer = 0; } } }

            const ws = player.weapons.spike;
            if (ws.level > 0) {
                ws.timer++;
                if (ws.timer > ws.cooldown && state.enemies.length > 0) {
                    let targets = state.enemies.sort((a, b) => b.hp - a.hp).slice(0, 3);
                    targets.forEach(t => {
                        let baseDmg = 60 + (ws.level * 15) + (state.level * 2);
                        let dmg = calcDamage(baseDmg);
                        t.takeDamage(dmg.d, dmg.c, 'spike');
                        state.zones.push(new Zone(t.x, t.y, 'spike_burst', 20));
                    });
                    ws.timer = 0;
                }
            }

            const wf = player.weapons.flag;
            if (wf.level > 0) {
                wf.timer++;
                if (wf.timer > wf.cooldown) {
                    wf.timer = 0;
                    for (let i = 0; i < wf.count; i++) {
                        state.projectiles.push(new Projectile(player.x, player.y, null, 'bosnian_flag'));
                    }
                }
            }

            const wp = player.weapons.pyramid;
            if (wp.level > 0) {
                wp.timer++;
                if (wp.timer > wp.cooldown) {
                    let t = getClosestEnemy();
                    if (t) {
                        if (wp.evolved) {
                            addShake(15);
                            const angle = Math.atan2(t.y - player.y, t.x - player.x);
                            state.beams.push(new Beam(player.x, player.y, angle));
                            const endX = player.x + Math.cos(angle) * 1200;
                            const endY = player.y + Math.sin(angle) * 1200;
                            state.enemies.forEach(e => {
                                if (lineCircleCollide(e.x, e.y, player.x, player.y, endX, endY, e.radius + 100)) {
                                    let dmg = calcDamage(wp.damage);
                                    e.takeDamage(dmg.d, dmg.c, 'beam');
                                    createParticle(e.x, e.y, '#fecb00', 'spark', 1.5);
                                }
                            });
                            wp.timer = 0;
                        } else {
                            state.projectiles.push(new Projectile(player.x, player.y, t, 'pyramid'));
                            wp.timer = 0;
                        }
                    }
                }
            }

            // Piano Smash Ability
            const pps = player.weapons.piano_smash;
            if (pps.level > 0) {
                pps.timer++;
                if (pps.timer > pps.cooldown) {
                    pps.timer = 0;
                    // Pick random location near player
                    let ang = Math.random() * 6.28;
                    let dist = Math.random() * 200;
                    let tx = player.x + Math.cos(ang) * dist;
                    let ty = player.y + Math.sin(ang) * dist;
                    state.zones.push(new Zone(tx, ty, 'piano_warning', 150, 'player'));
                }
            }

            const bur = player.weapons.burek;
            if (bur.evolved) {
                let fireDist = bur.dist * 2.0;
                if (state.frames % 15 === 0) {
                    let baseTick = Math.max(1, bur.damage * 0.5);
                    state.enemies.forEach(e => {
                        if (Math.hypot(e.x - player.x, e.y - player.y) < fireDist) {
                            let dmg = calcDamage(baseTick);
                            e.takeDamage(dmg.d, false, 'fire_aura');
                            createParticle(e.x, e.y, '#ff5e00', 'fire', 0.5);
                        }
                    });
                }
                if (state.frames % 5 === 0) {
                    let rAng = Math.random() * 6.28;
                    let rDist = Math.random() * fireDist;
                    createParticle(player.x + Math.cos(rAng) * rDist, player.y + Math.sin(rAng) * rDist, 'rgba(255,100,0,0.3)', 'fire', 0.5);
                }
            }

            state.gems = state.gems.filter(g => !g.update()); state.zones = state.zones.filter(z => !z.update()); state.perks = state.perks.filter(p => p.update());
            state.beams = state.beams.filter(b => b.update());
            state.crates = state.crates.filter(c => !c.update());

            state.projectiles.forEach(p => p.update());
            state.projectiles = state.projectiles.filter(p => {
                // DAMAGE SCALING CALCULATION (PROJECTILES)
                let timeMinutes = state.gameTime / 60;
                let damageMultiplier = 1.0;
                let bossDamageMultiplier = 1.0;
                if (timeMinutes > 10) {
                    damageMultiplier = 1 + (timeMinutes - 10) * 0.05;
                    bossDamageMultiplier = 1 + (timeMinutes - 10) * 0.025;
                }

                if (p.type === 'bosnian_flag') {
                    if (p.life <= 0) return false;
                    state.enemies.forEach(e => {
                        if (!p.pierceHitList.includes(e) && Math.hypot(e.x - p.x, e.y - p.y) < e.radius + 15) {
                            let baseDmg = 12 + state.level;
                            let dmg = calcDamage(baseDmg);
                            e.takeDamage(dmg.d, dmg.c, 'flag');
                            p.pierceHitList.push(e);
                            createParticle(e.x, e.y, '#002395', 'spark', 0.5);
                        }
                    });
                    return true;
                }
                if (p.type === 'boss_missile' || p.type === 'sniper_shot' || p.type === 'warsaw') {
                    if (Math.hypot(p.x - player.x, p.y - player.y) < player.radius + 10) {
                        if (!godMode) {
                            let hitDmg = p.type === 'sniper_shot' ? 15 : 40;
                            if (p.type === 'warsaw') hitDmg = 20;

                            // Apply Scaling
                            if (p.type === 'sniper_shot' || p.type === 'warsaw') hitDmg *= damageMultiplier;
                            if (p.type === 'boss_missile') hitDmg *= bossDamageMultiplier;

                            if (p.type !== 'warsaw') {
                                if (player.invincible <= 10) {
                                    player.hp -= hitDmg;
                                    spawnDamageText(player.x, player.y - 60, Math.floor(hitDmg), 'player');
                                    player.invincible = 30;
                                    if (player.hp <= 0) triggerDeath();
                                }
                            } else {
                                if (p.hitCooldowns.length === 0) {
                                    if (p.life % 20 === 0) {
                                        player.hp -= hitDmg;
                                        spawnDamageText(player.x, player.y - 40, Math.floor(hitDmg), 'player');
                                        p.hitCooldowns.push(20);
                                        if (player.hp <= 0) triggerDeath();
                                    }
                                    return true;
                                }
                            }
                        }
                        if (godMode) spawnDamageText(player.x, player.y - 50, "BLOCKED", true);

                        addShake(20);
                        updateHud();
                        return p.type === 'warsaw';
                    }
                    for (let u of state.friendlyUnits) {
                        if (!u.dead && Math.hypot(p.x - u.x, p.y - u.y) < u.radius + 10) {
                            u.takeDamage(40);
                            if (p.type !== 'warsaw') return false;
                        }
                    }
                    return p.life > 0;
                }

                if (p.type === 'pyramid' && p.life > 0) {
                    state.enemies.forEach(e => {
                        if (Math.hypot(e.x - p.x, e.y - p.y) < e.radius + p.radius) {
                            if (!p.pierceHitList.includes(e)) {
                                let dmg = calcDamage(player.weapons.pyramid.damage);
                                e.takeDamage(dmg.d, dmg.c, 'projectile');
                                createParticle(e.x, e.y, '#0f0', 'spark');
                                p.pierceHitList.push(e);
                            }
                        }
                    });
                    return true;
                }
                if (p.type === 'cevapi') {
                    for (let e of state.enemies) {
                        if (Math.hypot(e.x - p.x, e.y - p.y) < e.radius + 15) {
                            let dmg = p.overrideDamage > 0 ? { d: p.overrideDamage, c: false } : calcDamage(player.weapons.cevapi.damage);
                            e.takeDamage(dmg.d, dmg.c, 'projectile');
                            p.life = 0;
                            return false;
                        }
                    }
                }
                if (p.type === 'cevapi_hot') {
                    for (let e of state.enemies) {
                        if (Math.hypot(e.x - p.x, e.y - p.y) < e.radius + 20) {
                            if (!p.pierceHitList.includes(e)) {
                                // Apply burn
                                e.percentBurnLeft += player.weapons.cevapi.burnCount;
                                e.takeDamage(10, false, 'projectile');
                                // p.life = 0; // Removed self-destruction for piercing
                                createParticle(e.x, e.y, '#ff4500', 'fire', 1.0);
                                p.pierceHitList.push(e); // Add to hit list
                            }
                        }
                    }
                    return p.life > 0; // Projectile stays alive until time runs out
                }

                return p.life > 0;
            });

            const harm = player.weapons.harmonika;

            state.enemies.forEach(e => {
                e.speed = e.baseSpeed;
                // Harmonika Slow (Ignored by Phased Lovac)
                if (harm.level > 0 && !e.isPhased) {
                    if (Math.hypot(e.x - player.x, e.y - player.y) < harm.range) {
                        let effectiveSlow = Math.min(harm.slow, 0.8);
                        e.speed = e.baseSpeed * (1 - effectiveSlow);
                        if (state.frames % 20 === 0) createParticle(e.x, e.y, '#00f3ff', 'spark', 0.2);
                    }
                }

                e.update();
                let safeDist = player.radius + e.radius - 5;

                // COLLISION
                if (!e.frozen && Math.hypot(e.x - player.x, e.y - player.y) < safeDist) {

                    // DAMAGE SCALING CALCULATION
                    let timeMinutes = state.gameTime / 60;
                    let damageMultiplier = 1.0;
                    let bossMultiplier = 1.0;

                    if (timeMinutes > 10) {
                        damageMultiplier = 1 + (timeMinutes - 10) * 0.05;
                        bossMultiplier = 1 + (timeMinutes - 10) * 0.025;
                    }

                    if (e.type === 'BRAXTON') {
                        if (e.damageCooldown <= 0) {
                            let dmg = 60 * bossMultiplier;
                            if (!godMode) player.hp -= dmg;
                            e.damageCooldown = 30;
                            addShake(10);
                            if (player.invincible <= 0) player.invincible = 30;
                            spawnDamageText(player.x, player.y - 60, Math.floor(dmg), 'player');
                        }
                    } else if (e.type === 'POLYRHYTHM') {
                        if (e.damageCooldown <= 0) {
                            let dmg = 40 * bossMultiplier;
                            if (!godMode) player.hp -= dmg;
                            e.damageCooldown = 20;
                            addShake(5);
                            if (player.invincible <= 0) player.invincible = 20;
                            spawnDamageText(player.x, player.y - 60, Math.floor(dmg), 'player');
                        }
                    } else if (e.type === 'TEZINA') {
                        // Collision damage with Te≈æina is minimal unless dashing, focus on abilities
                        if (e.damageCooldown <= 0) {
                            let dmg = 30 * bossMultiplier;
                            if (e.isDashing) dmg = 150;

                            if (!godMode) player.hp -= dmg;
                            e.damageCooldown = 30;
                            addShake(10);
                            if (player.invincible <= 0) player.invincible = 30;
                            spawnDamageText(player.x, player.y - 60, Math.floor(dmg), 'player');
                        }
                    } else {
                        let baseDmg = 5;
                        if (e.type === 'yugo') baseDmg = 15;
                        if (e.type === 'hornet') baseDmg = 3;
                        if (e.type === 'medic') baseDmg = 4;
                        if (e.type === 'lovac') {
                            baseDmg = 20;
                            e.attackAnim = 20; // Trigger knife anim
                        }
                        if (e.type === 'jurisnik') {
                            // Calculate time-based damage scaling
                            let minutesElapsed = Math.floor(state.gameTime / 60);

                            if (e.isDashing) {
                                // Light Dash hit - 50 base + time scaling + stun
                                baseDmg = 50 + (minutesElapsed * 2);
                                player.invincible = 30; // 0.5s stun (can't move during invincibility)
                                spawnDamageText(player.x, player.y - 80, "STUNNED!", 'crit');
                                addShake(15);
                                e.isDashing = false; // End dash on hit
                                e.dashVulnerable = 60;
                                e.dashCooldown = 300;
                            } else {
                                // Base melee attack - 32 + time scaling
                                baseDmg = 32 + (minutesElapsed * 1);
                            }
                            e.attackAnim = 15;
                        }
                        if (e.type === 'BOSS' || e.type === 'MINI_BOSS' || e.type === 'WARLORD_CLONE') baseDmg = 20;
                        if (e.type === 'RHYTHM_WRAITH') baseDmg = 30;

                        // Apply Scaling
                        if (e.type === 'BOSS' || e.type === 'MINI_BOSS' || e.type === 'WARLORD_CLONE') baseDmg *= bossMultiplier;
                        else baseDmg *= damageMultiplier;

                        let dmgAmt = Math.max(1, baseDmg - player.armor);

                        if (!godMode) {
                            if (player.invincible <= 0) {
                                player.hp -= dmgAmt;
                                player.invincible = 30; // 0.5s I-frames
                                spawnDamageText(player.x, player.y - 60, Math.floor(dmgAmt), 'normal');
                            }
                        }
                        addShake(2);

                        if (e.type === 'RHYTHM_WRAITH') {
                            e.takeDamage(999, true, 'suicide'); // Wraith dies on contact
                        }
                    }

                    updateHud();
                    if (player.hp <= 0) triggerDeath();
                }

                state.friendlyUnits.forEach(u => {
                    if (!u.dead && !e.frozen && Math.hypot(e.x - u.x, e.y - u.y) < u.radius + e.radius) {
                        u.takeDamage(1);
                    }
                });

                while (bur.orbs.length < bur.count) bur.orbs.push({ timer: 0 });
                for (let b = 0; b < bur.count; b++) {
                    if (bur.orbs[b].timer > 0) { bur.orbs[b].timer--; continue; }
                    const ang = (state.frames * bur.speed) + (b * 6.28 / bur.count), bx = player.x + Math.cos(ang) * bur.dist, by = player.y + Math.sin(ang) * bur.dist;

                    let hitRadius = 45;
                    if (Math.hypot(e.x - bx, e.y - by) < hitRadius && e.burekHitTimer <= 0) {
                        if (bur.evolved) {
                            let dmg = calcDamage(bur.damage);
                            e.takeDamage(dmg.d, dmg.c, 'burek');
                            e.burnTimer = 60;
                            createParticle(bx, by, '#ff5e00', 'fire', 1.0);
                            e.burekHitTimer = 30;
                        }
                        else {
                            let dmg = calcDamage(bur.damage);
                            e.takeDamage(dmg.d, dmg.c, 'burek');
                            createParticle(e.x, e.y, '#e67e22', 'spark');
                            e.burekHitTimer = 30;
                        }
                    }
                }
            });

            // --- FIXED BOSS DESPAWN GLITCH ---
            // We filter out enemies that are dead AND have finished their death animation.
            // If e.dead is true, we ONLY keep them if e.deathAnimationTimer > 0.
            state.enemies = state.enemies.filter(e => (!e.dead || e.deathAnimationTimer > 0) && (Math.hypot(e.x - player.x, e.y - player.y) < 2000 || e.type.includes('BOSS') || e.type === 'BRAXTON' || e.type === 'POLYRHYTHM' || e.type === 'TEZINA'));

            state.particles.forEach(p => { p.x += p.vx; p.y += p.vy; p.life -= p.decay; p.vx *= 0.95; p.vy *= 0.95; }); state.particles = state.particles.filter(p => p.life > 0);
            state.texts.forEach(t => { t.y += t.vy; t.vy *= 0.9; t.life -= 0.02; }); state.texts = state.texts.filter(t => t.life > 0);
            if (state.shake > 0) state.shake *= 0.9; state.frames++;
        }

        function draw() {
            let cX = player.x - W / 2, cY = player.y - H / 2;
            if (state.shake > 0.5) { cX += (Math.random() - 0.5) * state.shake; cY += (Math.random() - 0.5) * state.shake; }

            ctx.fillStyle = '#050510'; ctx.fillRect(0, 0, W, H);

            state.backgroundStars.forEach(s => {
                let px = (s.x - cX * 0.1) % W; if (px < 0) px += W;
                let py = (s.y - cY * 0.1) % H; if (py < 0) py += H;
                ctx.fillStyle = `rgba(255,255,255,${s.alpha})`;
                ctx.fillRect(px, py, s.size, s.size);
            });

            ctx.strokeStyle = '#1a1a2e'; ctx.lineWidth = 1; ctx.beginPath();
            let ox = -cX % 150, oy = -cY % 150;
            for (let i = ox; i < W; i += 150) { ctx.moveTo(i, 0); ctx.lineTo(i, H); }
            for (let i = oy; i < H; i += 150) { ctx.moveTo(0, i); ctx.lineTo(W, i); }
            ctx.stroke();

            state.zones.forEach(z => z.draw(cX, cY));
            state.gems.forEach(g => g.draw(cX, cY));
            state.perks.forEach(p => p.draw(cX, cY));
            state.crates.forEach(c => c.draw(cX, cY));

            state.friendlyUnits.forEach(u => u.draw(cX, cY));

            state.enemies.forEach(e => e.draw(cX, cY));
            state.projectiles.forEach(p => p.draw(cX, cY));
            state.beams.forEach(b => b.draw(cX, cY));

            let pX = player.x - cX, pY = player.y - cY;

            ctx.save();
            ctx.translate(pX, pY);

            // ORBITING GRILL
            if (player.weapons.cevapi.evolved) {
                let gx = Math.cos(player.weapons.cevapi.grillAngle) * 60;
                let gy = Math.sin(player.weapons.cevapi.grillAngle) * 60;
                ctx.fillStyle = '#333';
                ctx.fillRect(gx - 10, gy - 10, 20, 20); // Grill Body
                ctx.fillStyle = '#ff4500';
                ctx.fillRect(gx - 8, gy - 8, 16, 16); // Coals
                ctx.fillStyle = '#000'; // Grate lines
                ctx.fillRect(gx - 8, gy - 2, 16, 2);
                ctx.fillRect(gx - 8, gy + 2, 16, 2);
                ctx.fillRect(gx - 2, gy - 8, 2, 16);
            }

            ctx.rotate(player.facing + 1.57);

            if (player.invincible > 0) ctx.globalAlpha = 0.4;

            ctx.shadowBlur = 15; ctx.shadowColor = 'rgba(0,0,0,0.5)';

            // Robes
            ctx.fillStyle = '#002395';
            ctx.beginPath();
            let sway = Math.sin(state.frames * 0.2) * 2;
            ctx.moveTo(0, 0);
            ctx.bezierCurveTo(-15, 5, -15, 20 + sway, 0, 25);
            ctx.bezierCurveTo(15, 20 - sway, 15, 5, 0, 0);
            ctx.fill();

            // Gold Trim
            ctx.strokeStyle = '#fecb00';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Head
            ctx.fillStyle = '#ffdbac';
            ctx.beginPath(); ctx.arc(0, 0, 8, 0, 6.28); ctx.fill();

            // Wizard Hat
            ctx.fillStyle = '#001a75';
            ctx.beginPath(); ctx.moveTo(0, 15); ctx.lineTo(-12, -2); ctx.lineTo(12, -2); ctx.fill();
            ctx.beginPath(); ctx.ellipse(0, -2, 14, 5, 0, 0, 6.28); ctx.fill();

            ctx.fillStyle = '#fecb00';
            ctx.beginPath(); ctx.arc(0, 5, 3, 0, 6.28); ctx.fill();

            // Staff
            ctx.save();
            ctx.translate(15, 5);
            let bob = Math.sin(state.frames * 0.1) * 3;
            ctx.translate(0, bob);
            ctx.rotate(-0.5);
            ctx.fillStyle = '#654321'; ctx.fillRect(-2, -20, 4, 40);

            ctx.shadowBlur = 20; ctx.shadowColor = 'rgba(0, 243, 255, 0.8)';
            ctx.fillStyle = '#00f3ff';
            let pulse = Math.sin(state.frames * 0.1) * 2;
            ctx.beginPath(); ctx.arc(0, -22, 6 + pulse, 0, 6.28); ctx.fill();
            ctx.restore();

            ctx.restore();

            const bur = player.weapons.burek;

            if (bur.evolved) {
                let range = bur.dist * 2.0;
                ctx.save(); ctx.translate(pX, pY);
                let fireGrad = ctx.createRadialGradient(0, 0, 40, 0, 0, range);
                fireGrad.addColorStop(0, 'rgba(255, 150, 0, 0.1)');
                fireGrad.addColorStop(0.8, 'rgba(255, 60, 0, 0.2)');
                fireGrad.addColorStop(1, 'rgba(255, 0, 0, 0)');

                ctx.fillStyle = fireGrad;
                ctx.beginPath(); ctx.arc(0, 0, range, 0, 6.28); ctx.fill();

                ctx.strokeStyle = `rgba(255, 100, 0, ${0.3 + Math.sin(state.frames * 0.1) * 0.2})`;
                ctx.lineWidth = 2;
                ctx.beginPath(); ctx.arc(0, 0, range, 0, 6.28); ctx.stroke();
                ctx.restore();
            }

            for (let i = 0; i < bur.count; i++) {
                if (!bur.orbs[i] || bur.orbs[i].timer > 0) continue;
                let ang = (state.frames * bur.speed) + (i * 6.28 / bur.count), bx = pX + Math.cos(ang) * bur.dist, by = pY + Math.sin(ang) * bur.dist;
                ctx.save(); ctx.translate(bx, by);
                if (bur.evolved) {
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.fillStyle = '#ffaa00'; ctx.beginPath(); ctx.arc(0, 0, 8, 0, 6.28); ctx.fill();
                    let f = Math.sin(state.frames * 0.5) * 3;
                    ctx.fillStyle = 'rgba(255, 50, 0, 0.6)'; ctx.beginPath(); ctx.arc(0, 0, 14 + f, 0, 6.28); ctx.fill();
                    if (state.frames % 5 === 0) createParticle(bx + cX, by + cY, '#ffaa00', 'fire', 0.5);
                } else {
                    ctx.rotate(ang * 4);
                    ctx.strokeStyle = '#e67e22'; ctx.lineWidth = 4;
                    ctx.beginPath();
                    for (let j = 0; j < 20; j++) {
                        let r = j; let angle = j * 0.5;
                        ctx.lineTo(Math.cos(angle) * r, Math.sin(angle) * r);
                    }
                    ctx.stroke();
                } ctx.restore();
            }

            ctx.globalCompositeOperation = 'lighter';
            state.particles.forEach(p => {
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                if (p.type === 'note') { ctx.font = "15px Arial"; ctx.fillText(p.char, p.x - cX, p.y - cY); }
                else { ctx.beginPath(); ctx.arc(p.x - cX, p.y - cY, p.size, 0, 6.28); ctx.fill(); }
            });

            if (player.weapons.harmonika.level > 0) {
                ctx.strokeStyle = 'rgba(0, 243, 255, 0.3)'; ctx.lineWidth = 2;
                ctx.fillStyle = 'rgba(0, 243, 255, 0.05)';
                ctx.beginPath(); ctx.arc(pX, pY, player.weapons.harmonika.range, 0, 6.28);
                ctx.fill(); ctx.stroke();

                ctx.strokeStyle = 'rgba(0, 243, 255, 0.1)';
                ctx.beginPath();
                ctx.arc(pX, pY, player.weapons.harmonika.range - 10, state.frames * 0.02, state.frames * 0.02 + 4);
                ctx.stroke();
            }

            ctx.globalCompositeOperation = 'source-over'; ctx.globalAlpha = 1; ctx.shadowBlur = 0;

            let lg = ctx.createRadialGradient(W / 2, H / 2, 100, W / 2, H / 2, Math.max(W, H));
            lg.addColorStop(0, 'rgba(0,0,0,0)');
            lg.addColorStop(0.6, 'rgba(0,5,20,0.3)');
            lg.addColorStop(1, 'rgba(0,0,0,0.9)');
            ctx.fillStyle = lg; ctx.fillRect(0, 0, W, H);

            if (state.flashAlpha > 0) {
                ctx.fillStyle = `rgba(255,255,255,${state.flashAlpha})`;
                ctx.fillRect(0, 0, W, H);
            }

            state.texts.forEach(t => {
                ctx.fillStyle = t.color;
                ctx.font = `bold ${18 * t.scale}px Orbitron`;
                ctx.fillText(t.val, t.x - cX, t.y - cY);
            });
        }

        function generateCards() {
            const container = document.getElementById('cards-box');
            container.innerHTML = '';
            document.getElementById('levelup-screen').style.display = 'flex';

            let available = [];

            UPGRADES.forEach(u => {
                let currentLvl = 0;
                if (player.weapons[u.id]) currentLvl = player.weapons[u.id].level;
                else if (player.items[u.id] !== undefined) currentLvl = player.items[u.id];

                if (currentLvl >= (u.max || 10)) return;

                if (u.id === 'burek' && player.weapons.burek.evolved) return;
                if (u.id === 'pyramid' && player.weapons.pyramid.evolved) return;
                if (u.id === 'cevapi' && player.weapons.cevapi.evolved) return; // Evo condition
                if (u.id === 'serbian' && player.weapons.serbian.level >= 1) return;

                available.push(u);
            });

            if (player.weapons.burek.level >= 8 && !player.weapons.burek.evolved) available.push(EVOLUTIONS.find(e => e.id === 'burek_evo'));
            if (player.weapons.pyramid.level >= 6 && !player.weapons.pyramid.evolved) available.push(EVOLUTIONS.find(e => e.id === 'pyramid_evo'));
            if (player.weapons.cevapi.level >= 10 && !player.weapons.cevapi.evolved) available.push(EVOLUTIONS.find(e => e.id === 'cevapi_evo'));

            if (player.weapons.burek.evolved) available.push(SUPERCHARGES.find(s => s.id === 'supercharge_burek'));
            if (player.weapons.pyramid.evolved) available.push(SUPERCHARGES.find(s => s.id === 'supercharge_pyramid'));
            if (player.weapons.cevapi.evolved) available.push(SUPERCHARGES.find(s => s.id === 'supercharge_cevapi'));

            if (player.weapons.serbian.level > 0 && !player.weapons.serbian.evolved) {
                if (player.weapons.serbian.path === 0) {
                    available.push({ id: 'serbian_selector', name: 'UNIT EVOLUTION', icon: '‚ö°', tier: 'legendary', desc: 'Choose a specialization path for your unit.' });
                }
                else if (player.weapons.serbian.path === 1) available.push(EVOLUTIONS.find(e => e.id === 'serbian_p1_evo'));
                else if (player.weapons.serbian.path === 2) available.push(EVOLUTIONS.find(e => e.id === 'serbian_p2_evo'));
                else if (player.weapons.serbian.path === 3) available.push(EVOLUTIONS.find(e => e.id === 'serbian_p3_evo'));
            }

            // --- SOFTLOCK FIX: FORCE SOUP ---
            if (available.length === 0) {
                let soup = UPGRADES.find(u => u.id === 'heal');
                if (soup) available.push(soup);
            }

            let pools = {
                legendary: available.filter(u => u.tier === 'legendary'),
                rare: available.filter(u => u.tier === 'rare'),
                common: available.filter(u => u.tier === 'common')
            };

            let selectedCards = [];

            for (let i = 0; i < 3; i++) {
                let card = null;
                let safetyCounter = 0;

                while (card === null && safetyCounter < 10) {
                    safetyCounter++;
                    let rng = Math.random() * 100;
                    let chosenTier = 'common';

                    if (rng < (1 * player.luck)) chosenTier = 'legendary';
                    else if (rng < (16 * player.luck)) chosenTier = 'rare';
                    else chosenTier = 'common';

                    if (chosenTier === 'legendary' && pools.legendary.length === 0) chosenTier = 'rare';
                    if (chosenTier === 'rare' && pools.rare.length === 0) chosenTier = 'common';

                    let pool = pools[chosenTier];
                    if (pool.length > 0) {
                        let candidate = pool[Math.floor(Math.random() * pool.length)];
                        if (!selectedCards.includes(candidate)) {
                            card = candidate;
                        }
                    }
                }

                if (!card && pools.common.length > 0) card = pools.common[Math.floor(Math.random() * pools.common.length)];

                if (card && !selectedCards.includes(card)) selectedCards.push(card);
            }

            // Fallback for duplicates or tiny pool
            if (selectedCards.length < 3 && available.length > 0) {
                available.forEach(c => {
                    if (selectedCards.length < 3 && !selectedCards.includes(c)) selectedCards.push(c);
                });
            }

            selectedCards.forEach(o => {
                const el = document.createElement('div'); el.className = 'card';
                if (o.tier === 'legendary') el.classList.add('legendary');
                if (o.tier === 'rare') el.classList.add('rare');

                let lvlText = '';
                if (player.weapons[o.id]) lvlText = 'Lvl ' + (player.weapons[o.id].level + 1);
                else if (player.items[o.id] !== undefined) lvlText = 'Lvl ' + (player.items[o.id] + 1);
                else if (o.base && player.weapons[o.base]) lvlText = 'EVO';
                if (o.max > 100) lvlText = '‚àû'; // Infinite symbol

                el.innerHTML = `<div class="card-level">${lvlText}</div><div class="card-icon">${o.icon}</div><div class="card-name">${o.name}</div><div class="card-desc">${o.desc}</div>`;
                el.onclick = () => { applyUpgrade(o.id); }; container.appendChild(el);
            });
        }

        function triggerPathSelection() {
            document.getElementById('levelup-screen').style.display = 'none';
            const overlay = document.getElementById('evolution-overlay');
            overlay.style.display = 'flex';

            overlay.innerHTML = '<h1 class="evo-text">EVOLUTION<br>IMMINENT</h1>';

            setTimeout(() => {
                overlay.innerHTML = '<h1 style="color:var(--bosnia-yellow); margin-bottom:20px; font-family:Orbitron; font-size:40px;">CHOOSE YOUR PATH</h1><div id="evo-cards" class="cards-container"></div>';
                const container = document.getElementById('evo-cards');

                const paths = [
                    EVOLUTIONS.find(e => e.id === 'serbian_p1'),
                    EVOLUTIONS.find(e => e.id === 'serbian_p2'),
                    EVOLUTIONS.find(e => e.id === 'serbian_p3')
                ];

                paths.forEach(o => {
                    const el = document.createElement('div'); el.className = 'card legendary';
                    el.innerHTML = `<div class="card-level">PATH SELECTION</div><div class="card-icon">${o.icon}</div><div class="card-name">${o.name}</div><div class="card-desc">${o.desc}</div>`;
                    el.onclick = () => {
                        applyUpgrade(o.id);
                        overlay.style.display = 'none';
                        isPaused = false;
                    };
                    container.appendChild(el);
                });
            }, 2000);
        }

        function applyUpgrade(id) {
            if (id === 'serbian_selector') {
                triggerPathSelection();
                return;
            }

            if (id === 'burek_evo') {
                player.weapons.burek.evolved = true;
                player.weapons.burek.count += 1;
                player.weapons.burek.damage += 5;
            }
            if (id === 'pyramid_evo') { player.weapons.pyramid.evolved = true; player.weapons.pyramid.damage = 400; player.weapons.pyramid.baseCool = 180; player.weapons.pyramid.timer = 0; }
            if (id === 'cevapi_evo') {
                player.weapons.cevapi.evolved = true;
                player.weapons.cevapi.lastBurstScore = state.score;
            }

            if (id === 'supercharge_burek') { player.weapons.burek.damage *= 1.2; spawnDamageText(player.x, player.y - 50, "MAGMA INTENSIFIES", true); }
            if (id === 'supercharge_pyramid') { player.weapons.pyramid.damage *= 1.2; spawnDamageText(player.x, player.y - 50, "POWER UP!", true); }
            if (id === 'supercharge_cevapi') { player.weapons.cevapi.burnCount += 1; spawnDamageText(player.x, player.y - 50, "MORE COAL!", true); }

            if (id === 'burek') {
                player.weapons.burek.count++;
                player.weapons.burek.level++;
                player.weapons.burek.speed += 0.005;
            }

            if (id === 'cevapi') {
                player.weapons.cevapi.level++;
                // New Fire Rate Scaling: Starts 60 (1s), ends 30 (0.5s)
                // Linear decrease: 3.33 per level
                player.weapons.cevapi.baseCool = 60 - ((player.weapons.cevapi.level - 1) * 3.33);
                player.weapons.cevapi.damage += 5;
            }

            if (id === 'ajvar') {
                player.weapons.ajvar.level++;
                if (player.weapons.ajvar.level > 1) { player.weapons.ajvar.baseCool *= 0.85; player.weapons.ajvar.damage += 20; }
            }
            if (id === 'rakija') {
                player.weapons.rakija.level++;
                if (player.weapons.rakija.level > 1) { player.weapons.rakija.baseCool *= 0.85; player.weapons.rakija.damage += 2; }
            }
            if (id === 'pyramid') {
                player.weapons.pyramid.level++;
                if (player.weapons.pyramid.level > 1) { player.weapons.pyramid.baseCool *= 0.85; player.weapons.pyramid.damage += 15; }
            }
            if (id === 'spike') {
                player.weapons.spike.level++;
            }
            if (id === 'flag') {
                player.weapons.flag.level++;
                player.weapons.flag.count++;
            }
            if (id === 'harmonika') {
                player.weapons.harmonika.level++;
                if (player.weapons.harmonika.level > 1) {
                    player.weapons.harmonika.slow += 0.05;
                }
            }

            if (id === 'serbian') {
                player.weapons.serbian.level = 1;
                player.weapons.serbian.path = 0;
                state.friendlyUnits = [new FriendlyUnit('soldier', player.x, player.y)];
                spawnDamageText(player.x, player.y - 80, "UNIT DEPLOYED", true);
            }

            if (id === 'serbian_p1') {
                player.weapons.serbian.path = 1;
                state.friendlyUnits = [new FriendlyUnit('titan', player.x, player.y)];
                spawnDamageText(player.x, player.y - 80, "TITAN UPGRADE", true);
            }
            if (id === 'serbian_p1_evo') {
                player.weapons.serbian.evolved = true;
                state.friendlyUnits = [new FriendlyUnit('titan', player.x, player.y)];
                spawnDamageText(player.x, player.y - 80, "BERSERKER MODE", true);
            }

            if (id === 'serbian_p2') {
                player.weapons.serbian.path = 2;
                state.friendlyUnits = [
                    new FriendlyUnit('soldier', player.x + 20, player.y),
                    new FriendlyUnit('defender', player.x - 20, player.y),
                    new FriendlyUnit('mage', player.x, player.y - 20)
                ];
                spawnDamageText(player.x, player.y - 80, "SQUAD DEPLOYED", true);
            }
            if (id === 'serbian_p2_evo') {
                player.weapons.serbian.evolved = true;
                state.friendlyUnits = [
                    new FriendlyUnit('soldier', player.x + 20, player.y),
                    new FriendlyUnit('defender', player.x - 20, player.y),
                    new FriendlyUnit('mage', player.x, player.y - 20)
                ];
                spawnDamageText(player.x, player.y - 80, "ELITE SQUAD", true);
            }

            if (id === 'serbian_p3') {
                player.weapons.serbian.path = 3;
                state.friendlyUnits = [new FriendlyUnit('vanguard', player.x, player.y)];
                spawnDamageText(player.x, player.y - 80, "VANGUARD", true);
            }
            if (id === 'serbian_p3_evo') {
                player.weapons.serbian.evolved = true;
                state.friendlyUnits = [new FriendlyUnit('vanguard', player.x, player.y)];
                spawnDamageText(player.x, player.y - 80, "WARLORD TANK", true);
            }

            // New Special Rewards
            if (id === 'musical_beat') { state.xpMult *= 1.5; spawnDamageText(player.x, player.y - 60, "XP BOOSTED", true); }
            if (id === 'rhythmic_buff') { player.items.rhythmic_buff = 1; spawnDamageText(player.x, player.y - 60, "RHYTHMIC POWER", true); }
            if (id === 'piano_smash') { player.weapons.piano_smash.level = 1; spawnDamageText(player.x, player.y - 60, "PIANO UNLOCKED", true); }

            if (['speed', 'magnet', 'armor', 'heal', 'coffee', 'lily', 'vrelo', 'xp_boost', 'sword', 'cracked_jewelry'].includes(id)) {
                if (player.items[id] !== undefined) player.items[id]++;
            }

            if (id === 'speed') player.speed *= 1.15; if (id === 'magnet') player.magnetRadius += 50; if (id === 'armor') player.armor += 1.5; if (id === 'heal') player.hp = Math.min(player.maxHp, player.hp + 50);
            if (id === 'coffee') player.cdr *= 0.9; if (id === 'lily') player.critChance += 0.10; if (id === 'vrelo') player.regen += 2;

            if (id === 'xp_boost') state.xpMult += 0.5;
            if (id === 'cracked_jewelry') state.xpMult += 0.25;

            ['cevapi', 'ajvar', 'rakija', 'pyramid', 'spike', 'piano_smash'].forEach(w => { if (player.weapons[w]) player.weapons[w].cooldown = player.weapons[w].baseCool ? player.weapons[w].baseCool * player.cdr : player.weapons[w].cooldown; });

            let maxCoffee = player.items.coffee >= 10;

            if (player.weapons.cevapi.level >= 10) {
                // Cap firing rate with coffee
                let limit = maxCoffee ? 6 : 15;
                if (player.weapons.cevapi.cooldown < limit) player.weapons.cevapi.cooldown = limit;
            }

            if (player.weapons.pyramid.level >= 6) {
                let limit = maxCoffee ? 42 : 60;
                player.weapons.pyramid.cooldown = limit;
            }

            if (document.getElementById('levelup-screen').style.display === 'flex') {
                document.getElementById('levelup-screen').style.display = 'none';
                updateHud();
                isPaused = false;
            }
        }
        gameLoop();
    </script>
</body>

</html>
