<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Bosnian Survivors: JUDGMENT UPDATE</title>
<style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@500;700&display=swap');
    :root { 
        --bosnia-blue:#002395; 
        --bosnia-yellow:#fecb00; 
        --neon-cyan:#00f3ff; 
        --rare-blue:#4d80ff; 
        --supercharge:#ff2a2a; 
        --legendary:#d000ff; 
        --danger:#ff003c; 
        --dark:#050510; 
        --fire-orange:#ff5e00;
        --medic-green:#00ff41;
        --blood-red: #8a0303;
        --platinum: #e5e4e2;
    }
    body { margin:0; overflow:hidden; background-color:var(--dark); font-family:'Rajdhani', sans-serif; color:white; user-select:none; }
    
    #crt-overlay {
        position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 9999;
        background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.1) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.03), rgba(0, 255, 0, 0.01), rgba(0, 0, 255, 0.03));
        background-size: 100% 4px, 6px 100%;
    }

    #ui-layer { position:fixed; top:0; left:0; width:100%; height:100%; pointer-events:none; padding:20px; box-sizing:border-box; display:flex; flex-direction:column; z-index:50; }
    .hud-top { display:flex; justify-content:space-between; align-items:flex-start; pointer-events: none; width: 100%; }
    
    .stat-box { 
        background:rgba(0, 10, 30, 0.6); 
        backdrop-filter:blur(4px); 
        border:1px solid rgba(0, 243, 255, 0.2); 
        border-bottom:3px solid var(--bosnia-yellow); 
        padding:8px 25px; 
        transform: skewX(-15deg);
        display:flex; flex-direction:column; align-items:center; 
    }
    .stat-content { transform: skewX(15deg); text-align: center; }

    .label { font-size:10px; color:var(--neon-cyan); text-transform:uppercase; letter-spacing:2px; font-family:'Orbitron'; margin-bottom:2px; opacity: 0.8; }
    .value { font-size:24px; font-weight:700; color:#fff; text-shadow:0 0 5px var(--neon-cyan); }
    
    /* TIMER */
    #timer-box {
        position: absolute; top: 10px; left: 50%; transform: translateX(-50%) skewX(-15deg);
        background:rgba(0, 0, 0, 0.8); border:1px solid var(--bosnia-yellow);
        padding: 5px 30px; z-index: 60;
    }
    #timer-display {
        font-family: 'Orbitron'; font-size: 32px; color: var(--bosnia-yellow); transform: skewX(15deg); letter-spacing: 3px;
    }

    /* HP BAR */
    #hp-container {
        position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
        width: 500px; text-align: center; pointer-events: none;
    }
    #hp-bar-frame {
        width:100%; height:16px; background:rgba(0,0,0,0.8); 
        transform: skewX(-20deg); border:1px solid #555; overflow: hidden; position: relative;
    }
    #hp-fill { height:100%; width:100%; background:linear-gradient(90deg, #ff003c, #ff5e00); transition:width 0.1s linear; }

    /* BOSS HUD */
    #boss-hud { display:none; position:fixed; top:80px; left:50%; transform:translateX(-50%); width:600px; z-index:60; flex-direction:column; align-items:center; }
    #boss-name { font-family:'Orbitron'; font-size:28px; color:var(--danger); margin-bottom:5px; letter-spacing:8px; font-weight:900; text-shadow: 0 0 10px black; }
    #boss-bar-bg { width:100%; height:12px; background:rgba(0,0,0,0.8); border:1px solid var(--danger); transform: skewX(-20deg); overflow:hidden; }
    #boss-bar-fill { width:100%; height:100%; background:linear-gradient(90deg, #800000, #ff003c); transition:width 0.1s; }

    /* BOSS CAPTION (BOTTOM) */
    #boss-caption {
        position: fixed; bottom: 100px; width: 100%; text-align: center; pointer-events: none;
        font-family: 'Orbitron'; font-size: 30px; color: var(--neon-cyan);
        text-shadow: 0 0 10px var(--neon-cyan); letter-spacing: 5px; opacity: 0; transition: opacity 0.5s; z-index: 999;
    }

    #pause-btn { pointer-events: auto; background:rgba(0,0,0,0.5); border:1px solid var(--neon-cyan); color:var(--neon-cyan); width:40px; height:40px; border-radius:0; transform: skewX(-10deg); font-family:'Orbitron'; font-weight:bold; cursor:pointer; margin-left:10px; display:flex; align-items:center; justify-content:center; transition:0.2s; }
    #pause-btn:hover { background:var(--neon-cyan); color:black; }

    .xp-container { position:fixed; top:0; left:0; width:100%; height:4px; background:#000; z-index:100; pointer-events: none; }
    #xp-fill { height:100%; width:0%; background:linear-gradient(90deg, var(--bosnia-blue), var(--neon-cyan)); transition:width 0.2s; }
    
    .screen-overlay { display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(5, 5, 10, 0.95); z-index:2000; flex-direction:column; align-items:center; justify-content:center; pointer-events:auto; overflow-y:auto;}
    
    /* MUSICAL OVERLAY */
    #musical-overlay { display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8); z-index:9100; pointer-events:none; }
    .note-anim { position: absolute; font-size: 80px; animation: noteFloat 2s ease-out forwards; opacity: 0; color: var(--neon-cyan); text-shadow: 0 0 20px blue; }
    @keyframes noteFloat { 0% { transform: translate(0, 0) rotate(0deg); opacity: 0; } 20% { opacity: 1; } 100% { transform: translate(var(--tx), var(--ty)) rotate(var(--rot)); opacity: 0; } }

    /* UPDATED MAIN MENU */
    #main-menu { 
        display:flex; 
        background: radial-gradient(circle at center, rgba(10, 20, 40, 0.9), #000), url('https://img.freepik.com/free-vector/blue-futuristic-networking-technology-background-vector_53876-114068.jpg'); 
        background-size:cover; background-position: center; 
    }
    .title-container { position: relative; text-align: center; animation: floatTitle 3s ease-in-out infinite; z-index: 10; }
    .title-glitch { font-family:'Orbitron'; font-weight: 900; font-size:90px; color:white; text-shadow: 0 0 10px var(--bosnia-blue), 4px 4px 0px #000, -2px -2px 0 var(--bosnia-yellow); letter-spacing: 5px; margin: 0; line-height: 0.9; }
    .subtitle { font-family:'Rajdhani'; font-weight: 700; letter-spacing:15px; color:var(--neon-cyan); margin-top:10px; font-size: 32px; text-shadow: 0 0 20px var(--bosnia-blue); animation: pulseText 2s infinite alternate; }
    #balance-scale-bg { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 400px; opacity: 0.15; color: var(--bosnia-yellow); animation: balanceRock 5s ease-in-out infinite; pointer-events: none; z-index: 1; filter: drop-shadow(0 0 20px var(--bosnia-yellow)); }
    
    @keyframes balanceRock { 0% { transform: translate(-50%, -50%) rotate(-10deg); } 50% { transform: translate(-50%, -50%) rotate(10deg); } 100% { transform: translate(-50%, -50%) rotate(-10deg); } }
    @keyframes floatTitle { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-10px); } }
    @keyframes pulseText { 0% { opacity: 0.7; text-shadow: 0 0 10px var(--neon-cyan); } 100% { opacity: 1; text-shadow: 0 0 30px var(--bosnia-blue); } }
    
    .menu-btn { background:linear-gradient(90deg, rgba(0,0,0,0.8), rgba(0, 35, 149, 0.6)); border:1px solid var(--bosnia-blue); border-left: 4px solid var(--bosnia-yellow); color:white; padding:20px 60px; margin:15px; font-size:24px; font-family:'Orbitron'; cursor:pointer; text-transform:uppercase; letter-spacing:4px; width:350px; transition:0.3s; z-index: 10; clip-path: polygon(15px 0, 100% 0, 100% calc(100% - 15px), calc(100% - 15px) 100%, 0 100%, 0 15px); position: relative; overflow: hidden; }
    .menu-btn:hover { background:var(--bosnia-yellow); color:black; border-color:white; font-weight: 900; transform: scale(1.05); box-shadow: 0 0 30px rgba(254, 203, 0, 0.4); }

    /* ADMIN */
    #admin-panel { display:none; border:2px solid var(--danger); background:rgba(0,0,0,0.95); box-shadow: 0 0 50px rgba(255,0,0,0.2); flex-direction: column; align-items: center;}
    .admin-grid { display:grid; grid-template-columns: 1fr 1fr; gap:10px; width:600px; padding:20px; }
    .admin-btn { background:#111; border:1px solid #555; color:white; padding:15px; cursor:pointer; font-family:'Orbitron'; text-transform:uppercase; transition:0.2s; font-size: 14px; }
    .admin-btn:hover { background:var(--danger); color:white; border-color:white; box-shadow: 0 0 10px var(--danger); }
    .admin-header { font-family:'Orbitron'; color:var(--danger); font-size:30px; margin:20px 0; text-shadow:0 0 10px red; letter-spacing: 5px; text-align: center; width: 100%; border-bottom: 1px solid #333; padding-bottom: 10px;}
    #admin-augment-select { background: #000; color: var(--neon-cyan); border: 1px solid var(--neon-cyan); padding: 10px; width: 100%; font-family: 'Rajdhani'; font-size: 16px; margin-bottom: 10px; }
    .spawn-control { display:flex; gap: 5px; grid-column: span 2; }
    .spawn-select { flex-grow: 1; background: #000; color: #fff; padding: 10px; font-family: Orbitron; border: 1px solid #555; }

    /* BRAXTON CUTSCENE */
    #braxton-cutscene { display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.9); z-index:9000; flex-direction:column; align-items:center; justify-content:center; }
    #taco-anim { font-size: 200px; animation: tacoDrop 2s ease-out forwards; }
    @keyframes tacoDrop { 0% { transform: translateY(-100vh) rotate(0deg); opacity: 0;} 70% { transform: translateY(0) rotate(360deg); opacity: 1;} 85% { transform: translateY(-20px) rotate(360deg); } 100% { transform: translateY(0) rotate(360deg); } }
    
    .dialogue-box { 
        margin-top: 50px; background: #000; border: 4px solid #2ecc71; padding: 20px; width: 60%; 
        color: #2ecc71; font-family: 'Orbitron'; font-size: 24px; text-align: center; display:none;
        box-shadow: 0 0 20px #2ecc71;
    }

    /* CLOCK INTRO */
    #clock-overlay { display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.95); z-index:9200; flex-direction:column; align-items:center; justify-content:center; }
    .clock-face {
        width: 300px; height: 300px; border: 10px solid var(--bosnia-yellow); border-radius: 50%;
        position: relative; box-shadow: 0 0 50px var(--bosnia-yellow); background: #000;
    }
    .clock-center { position: absolute; top: 50%; left: 50%; width: 20px; height: 20px; background: var(--danger); border-radius: 50%; transform: translate(-50%, -50%); z-index: 5; }
    .clock-hand { position: absolute; bottom: 50%; left: 50%; transform-origin: bottom center; background: white; border-radius: 5px; transition: transform 3s cubic-bezier(0.1, 0.7, 1.0, 0.1); }
    .hand-hour { width: 8px; height: 80px; margin-left: -4px; z-index: 3; background: #fff; transform: rotate(0deg); }
    .hand-minute { width: 4px; height: 120px; margin-left: -2px; z-index: 4; background: var(--neon-cyan); transform: rotate(0deg); }
    .clock-text { margin-top: 50px; font-family: 'Orbitron'; font-size: 50px; color: var(--danger); letter-spacing: 10px; opacity: 0; transition: opacity 2s; text-shadow: 0 0 20px red; }

    #pause-stats { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; width: 80%; max-width: 600px; margin-bottom: 20px; max-height: 400px; overflow-y: auto; }
    .pause-item { background: rgba(255,255,255,0.05); padding: 10px; border: 1px solid #333; display: flex; justify-content: space-between; align-items: center; }
    .pause-item span { font-family: 'Rajdhani'; font-size: 18px; color: var(--bosnia-yellow); }

    .cards-container { display:flex; gap:25px; margin-top:30px; flex-wrap:wrap; justify-content:center; max-width:1200px;perspective: 1000px; }
    .card { background:linear-gradient(170deg, #0a0a15 0%, #101025 100%); border:1px solid #333; width:220px; height:380px; border-radius:2px; padding:20px; cursor:pointer; transition:0.3s; display:flex; flex-direction:column; align-items:center; text-align:center; box-shadow:0 10px 30px rgba(0,0,0,0.8); position:relative; overflow:hidden; clip-path: polygon(20px 0, 100% 0, 100% calc(100% - 20px), calc(100% - 20px) 100%, 0 100%, 0 20px); opacity: 0; animation: cardFadeIn 0.5s forwards;}
    @keyframes cardFadeIn { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }

    .card:hover { transform:translateY(-10px); border-color:var(--bosnia-yellow); z-index: 10; }
    .card:hover .card-icon { transform: scale(1.1); }
    .card::after { content:''; position: absolute; top:0; left:0; width:100%; height:4px; background: var(--bosnia-yellow); }
    .card.rare { border-color: var(--rare-blue); background:linear-gradient(170deg, #051025 0%, #001530 100%); }
    .card.rare::after { background: var(--rare-blue); }
    .card.rare .card-name { color: var(--rare-blue); }
    .card.legendary { border-color: var(--legendary); background:linear-gradient(170deg, #1a0025 0%, #100020 100%); }
    .card.legendary::after { background: var(--legendary); }
    .card.legendary .card-name { color: var(--legendary); text-shadow: 0 0 5px var(--legendary); }
    .card-icon { font-size:60px; margin: 30px 0; transition: 0.3s; filter: drop-shadow(0 0 5px rgba(255,255,255,0.2)); }
    .card-name { font-family:'Orbitron'; font-weight:900; color:#fff; margin-bottom:10px; font-size:18px; text-transform:uppercase; letter-spacing: 1px;}
    .card-desc { font-size:13px; color:#99a; line-height:1.5; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 10px; width: 100%; }
    .card-level { position:absolute; top:10px; right:10px; font-size:10px; color:#555; font-family:'Orbitron'; font-weight: bold; }

    .info-grid { display:grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap:20px; max-width:1100px; width:90%; padding:20px; }
    .info-card { background:rgba(255,255,255,0.03); border:1px solid rgba(255,255,255,0.1); padding:20px; border-radius:4px; display:flex; align-items:center; gap:15px; position:relative; overflow:hidden;}
    .info-card.rare { border: 1px solid var(--rare-blue); box-shadow: inset 0 0 20px rgba(77, 128, 255, 0.1); }
    .info-card.legendary { border: 1px solid var(--legendary); box-shadow: inset 0 0 20px rgba(208, 0, 255, 0.1); }
    .info-icon { font-size:30px; min-width:60px; height: 60px; display: flex; align-items: center; justify-content: center; background: rgba(0,0,0,0.3); border-radius: 50%; border:1px solid rgba(255,255,255,0.1); }
    .info-text h3 { margin:0 0 5px 0; color:var(--bosnia-yellow); font-family:'Orbitron'; font-size:16px; letter-spacing: 1px; }
    .info-text p { margin:0; color:#aaa; font-size:13px; line-height:1.4; }
    .close-btn { position:absolute; top:30px; right:30px; background:none; border:none; color:white; font-size:40px; cursor:pointer; font-family: 'Rajdhani'; line-height: 20px;}
    .close-btn:hover { color:var(--danger); }

    .restart-btn { background: var(--danger); color:white; border:none; padding:20px 60px; font-size:24px; font-weight:900; cursor:pointer; font-family:'Orbitron'; clip-path:polygon(10px 0, 100% 0, 100% calc(100% - 10px), calc(100% - 10px) 100%, 0 100%, 0 10px); transition:0.2s; box-shadow:0 0 15px var(--danger); margin-top:30px; text-transform:uppercase; letter-spacing: 2px; }
    .restart-btn:hover { transform:scale(1.05); background: white; color: var(--danger); }
    
    /* CRATE SCREEN */
    #crate-screen { display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(5, 5, 10, 0.98); z-index:3000; flex-direction:column; align-items:center; justify-content:center; }
    #crate-anim { font-size: 150px; margin-bottom: 20px; transition: transform 0.1s; }
    
    /* Crate Animation Classes */
    .crate-drop { animation: crateDropIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards; }
    @keyframes crateDropIn { 0% { transform: translateY(-500px) scale(0.1); opacity: 0; } 100% { transform: translateY(0) scale(1); opacity: 1; } }
    
    .crate-shake { animation: crateShakeViolent 0.5s linear infinite; }
    @keyframes crateShakeViolent { 0% { transform: translate(0, 0) rotate(0deg); } 25% { transform: translate(-10px, 10px) rotate(-10deg); } 50% { transform: translate(10px, -10px) rotate(10deg); } 75% { transform: translate(-10px, -10px) rotate(-10deg); } 100% { transform: translate(0, 0) rotate(0deg); } }

    #white-flash { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: white; opacity: 0; pointer-events: none; z-index: 3001; transition: opacity 0.5s; }

    .claim-btn { background: var(--bosnia-yellow); color:black; border:none; padding:15px 40px; font-family:'Orbitron'; font-weight:900; font-size:24px; cursor:pointer; margin-top:30px; box-shadow: 0 0 20px var(--bosnia-yellow); animation: pulseBtn 1s infinite alternate; opacity: 0; transition: opacity 0.5s; }
    @keyframes pulseBtn { 0% { transform: scale(1); } 100% { transform: scale(1.1); } }

    canvas { display:block; position:absolute; top:0; left:0; z-index:1; }
</style>
</head>
<body>

<div id="crt-overlay"></div>
<div class="xp-container"><div id="xp-fill"></div></div>
<div id="musical-overlay"></div>

<!-- BOSS HUD -->
<div id="boss-hud">
    <div id="boss-name">TURBO FOLK WARLORD</div>
    <div id="boss-bar-bg"><div id="boss-bar-fill"></div></div>
</div>

<div id="boss-caption"></div>

<!-- BRAXTON CUTSCENE -->
<div id="braxton-cutscene">
    <div id="taco-anim">üåÆ</div>
    <div class="dialogue-box" id="braxton-dialogue"></div>
</div>

<!-- CLOCK INTRO -->
<div id="clock-overlay">
    <div class="clock-face">
        <div class="clock-center"></div>
        <div class="clock-hand hand-hour" id="hand-hour"></div>
        <div class="clock-hand hand-minute" id="hand-minute"></div>
    </div>
    <div class="clock-text" id="clock-text">TE≈ΩINA PRESUDE</div>
</div>

<!-- CRATE LOOT SCREEN -->
<div id="crate-screen">
    <div id="white-flash"></div>
    <div id="crate-anim">üì¶</div>
    <h1 id="crate-title" style="font-family:'Orbitron'; color:var(--bosnia-yellow); text-shadow:0 0 20px var(--bosnia-yellow); opacity:0; transition:opacity 0.5s;">SUPPLY DROP</h1>
    <div class="cards-container" id="crate-cards"></div>
    <button class="claim-btn" id="crate-claim-btn" onclick="claimCrateRewards()">CLAIM ALL</button>
</div>

<!-- MAIN MENU -->
<div id="main-menu" class="screen-overlay" style="display:flex;">
    <div id="balance-scale-bg">‚öñÔ∏è</div>
    <div class="title-container">
        <h1 class="title-glitch">BOSNIAN<br><span style="color:var(--bosnia-yellow)">SURVIVORS</span></h1>
        <div class="subtitle">ROSTILJ UPDATE</div>
    </div>
    <div style="height:60px;"></div>
    <button class="menu-btn" onclick="startGame()">DEPLOY</button>
    <button class="menu-btn" onclick="openInfo('armory')">ARMORY</button>
    <button class="menu-btn" onclick="openInfo('intel')">INTEL</button>
</div>

<!-- INFO MODAL -->
<div id="info-modal" class="screen-overlay">
    <button class="close-btn" onclick="closeInfo()">√ó</button>
    <h1 id="info-title" style="font-family:'Orbitron'; color:var(--bosnia-yellow); margin-top:50px; font-size: 40px; text-shadow: 0 0 10px var(--bosnia-yellow);">DATA</h1>
    <div id="info-content" class="info-grid"></div>
</div>

<!-- ADMIN PANEL -->
<div id="admin-panel" class="screen-overlay">
    <div class="admin-header">/// DEBUG CONTROL ///</div>
    <div class="admin-grid" style="grid-template-columns: 1fr 1fr; width: 400px; margin-bottom: 20px;">
        <label style="color:white; font-family:'Orbitron'; font-size:12px;">FORCE AUGMENTATION</label>
        <div style="display:flex; gap:10px;">
            <select id="admin-augment-select"></select>
            <button class="admin-btn" style="padding:10px;" onclick="adminForceUpgrade()">ADD</button>
        </div>
    </div>
    <div class="admin-grid">
        <button class="admin-btn" onclick="toggleGodMode()">Toggle God Mode</button>
        <button class="admin-btn" onclick="adminLevelUp()">+1 Level</button>
        <button class="admin-btn" onclick="adminKillAll()">Kill All Enemies</button>
        <button class="admin-btn" onclick="adminToggleSpawns()">Toggle Spawns</button>
        <button class="admin-btn" onclick="adminCycleLuck()">CYCLE LUCK: <span id="admin-luck-val">1x</span></button>
        <button class="admin-btn" onclick="adminHeal()">Full Heal</button>
        
        <div class="spawn-control">
            <select id="spawn-enemy-select" class="spawn-select">
                <option value="promaja">Promaja</option>
                <option value="yugo">Yugo</option>
                <option value="hornet">Hornet</option>
                <option value="snajper">Snajper</option>
                <option value="medic">Medic</option>
                <option value="lovac">Krvavi Lovac</option>
                <option value="NOLAN">Nolan-ite</option>
                <option value="MINI_BOSS">Mini Boss</option>
                <option value="BOSS">Warlord</option>
                <option value="BRAXTON">Braxton-inite</option>
                <option value="POLYRHYTHM">The Polyrhythm</option>
                <option value="TEZINA">Te≈æina Presude</option>
            </select>
            <button class="admin-btn" style="padding:10px; width:100px;" onclick="adminSpawnEnemy()">SPAWN</button>
        </div>
    </div>
    <button class="menu-btn" style="width:200px; margin-top:20px;" onclick="closeAdmin()">RESUME</button>
</div>

<!-- PAUSE MENU -->
<div id="pause-screen" class="screen-overlay">
    <h1 style="font-family:'Orbitron'; font-size:60px; color:var(--neon-cyan);">PAUSED</h1>
    <div id="pause-stats"></div>
    <button class="menu-btn" onclick="togglePause()">RESUME</button>
    <button class="menu-btn" onclick="quitGame()">MAIN MENU</button>
</div>

<!-- EVOLUTION OVERLAY -->
<div id="evolution-overlay" class="screen-overlay"></div>

<!-- GAME UI -->
<div id="ui-layer" style="display:none;">
    <div id="timer-box">
        <div id="timer-display">00:00</div>
    </div>
    
    <div class="hud-top">
        <div class="stat-box">
            <div class="stat-content">
                <div class="label">Threat Level</div>
                <div class="value" style="color:var(--bosnia-yellow)" id="lvl-display">1</div>
            </div>
        </div>
        <div style="display:flex;">
            <div class="stat-box">
                <div class="stat-content">
                    <div class="label">Kills</div>
                    <div class="value" style="color:#fff" id="score-display">0</div>
                </div>
            </div>
            <button id="pause-btn" onclick="togglePause()">||</button>
        </div>
    </div>

    <div id="hp-container">
        <div id="hp-bar-frame">
            <div id="hp-fill"></div>
        </div>
        <div style="font-size: 10px; color: #888; margin-top: 5px; font-family: 'Orbitron'; letter-spacing: 2px;">VITAL SYSTEMS</div>
    </div>

    <div id="god-mode-indicator" style="display:none; position:fixed; bottom:20px; left:20px; color:var(--danger); font-family:'Orbitron'; font-size:20px; text-shadow:0 0 10px red;">GOD MODE ACTIVE</div>
</div>

<div id="levelup-screen" class="screen-overlay">
    <h1 style="font-family:'Orbitron'; font-size:50px; color:var(--bosnia-yellow); margin-bottom:5px; text-shadow:0 0 15px var(--bosnia-yellow); letter-spacing: 5px;">SYSTEM UPGRADE</h1>
    <p style="color:var(--neon-cyan); margin-bottom:30px; font-size:18px; font-family: 'Rajdhani'; letter-spacing: 2px;">SELECT AUGMENTATION</p>
    <div class="cards-container" id="cards-box"></div>
</div>

<div id="game-over" class="screen-overlay">
    <h1 style="color:var(--danger); font-family:'Orbitron'; font-size:100px; margin:0; text-shadow:0 0 20px red; letter-spacing:10px;">MIA</h1>
    <p style="font-size:24px; color:white; font-family: 'Rajdhani'; letter-spacing: 2px;">FINAL SCORE: <span id="final-score" style="color:var(--bosnia-yellow); font-weight:bold;">0</span></p>
    <button class="restart-btn" onclick="resetGame()">RESPAWN</button>
    <button class="menu-btn" style="margin-top:20px; font-size:16px;" onclick="quitGame()">EXIT TO MENU</button>
</div>

<canvas id="game"></canvas>

<script>
    const canvas = document.getElementById('game'), ctx = canvas.getContext('2d', { alpha: false });
    let W, H;
    
    // ADMIN VARS
    const CHEAT_CODE = "Roblox13_isme";
    let inputBuffer = "";
    let godMode = false;
    let spawningEnabled = true;

    // ASSETS
    const UPGRADES=[
        {id:'burek',name:'Golden Burek',icon:'ü•ê',desc:'Spawns rotating pastry shields that damage enemies.', tier:'common', max:8},
        {id:'cevapi',name:'Rapid Cevapi',icon:'üå≠',desc:'Fires delicious grilled meat missiles.', tier:'common', max:10},
        {id:'ajvar',name:'Nuclear Ajvar',icon:'üå∂Ô∏è',desc:'Throws explosive jars of pepper paste.', tier:'common', max:10},
        {id:'rakija',name:'Holy Rakija',icon:'üçæ',desc:'Smashes bottles creating purifying fire zones.', tier:'common', max:10},
        {id:'pyramid',name:'Visoko Beam',icon:'‚õ∞Ô∏è',desc:'Fires a high-energy piercing triangle beam.', tier:'common', max:6},
        
        {id:'spike', name:'Impaler Spikes', icon:'üî©', desc:'Summons spikes under the 3 strongest enemies. (Dmg scales with Player Level)', tier:'common', max:10},
        {id:'flag', name:'Bosnian Flag', icon:'üáßüá¶', desc:'Throws a flag into the air that falls and pierces enemies. (+1 Flag per Card Level).', tier:'rare', max:6},
        {id:'sword', name:'Dull Bosnian Sword', icon:'üó°Ô∏è', desc:'+10% Damage for ALL attacks. (Additive Stack)', tier:'common', max:10},
        
        {id:'harmonika',name:'Harmonika Aura',icon:'üéπ',desc:'Slows all enemies within range. (30% Base, +10% per level, Max 80%)', tier:'rare', max:8},
        {id:'xp_boost',name:'Poor Jewelry',icon:'üíç',desc:'+50% EXP Gain (Stacks)', tier:'rare', max:10},
        {id:'cracked_jewelry', name:'Cracked Jewelry', icon:'üìø', desc:'+25% EXP Gain (Stacks with Poor Jewelry).', tier:'common', max:10},
        
        {id:'serbian',name:'Serbian Warrior',icon:'‚öîÔ∏è',desc:'Summons a Friendly Unit. Targets Hordes. 30s Respawn.', tier:'legendary', max:1},
        
        {id:'speed',name:'Turbo Folk Speed',icon:'‚ö°',desc:'Increases Movement Speed by 20%.', tier:'common', max:10},
        {id:'magnet',name:'Super Magnet',icon:'üß≤',desc:'Increases Item Pickup Range by 50%.', tier:'common', max:10},
        {id:'armor',name:'Kevlar Vest',icon:'üõ°Ô∏è',desc:'Reduces incoming damage.', tier:'common', max:10},
        {id:'heal',name:'Grandma Soup',icon:'üç≤',desc:'Instantly restores 50 HP.', tier:'common', max:10},
        {id:'coffee',name:'Bosnian Coffee',icon:'‚òï',desc:'Reduces all weapon cooldowns by 10%.', tier:'common', max:10},
        {id:'lily',name:'Golden Lily',icon:'‚öúÔ∏è',desc:'Increases Critical Hit Chance by 10%.', tier:'common', max:10},
        {id:'vrelo',name:'Vrelo Bosne',icon:'üèûÔ∏è',desc:'Regenerates 2 HP per second.', tier:'common', max:10}
    ];

    const EVOLUTIONS = [
        {id:'burek_evo',base:'burek',name:'RING OF FIRE',icon:'üî•',desc:'EVOLUTION: Massive permanent fire zone. 2x Radius. Burns ALL enemies constantly.', tier:'rare'},
        {id:'pyramid_evo',base:'pyramid',name:'SOLAR FLARE',icon:'‚òÄÔ∏è',desc:'EVOLUTION: Instantly blasts enemies with a massive laser beam.', tier:'rare'},
        {id:'cevapi_evo',base:'cevapi',name:'ROSTILJ MASTER',icon:'üçñ',desc:'EVO: Summons an orbiting grill. Shoots 3-7 Cevapi/sec based on heat. Overheats every 100 kills.', tier:'rare'},
        {id:'serbian_p1', base:'serbian', name:'PATH 1: TITAN SWORD', icon:'üó°Ô∏è', desc:'LVL 2: Bigger Sword. Higher Damage. Same AI.', tier:'legendary', req:'serbian'},
        {id:'serbian_p2', base:'serbian', name:'PATH 2: TACTICAL SQUAD', icon:'üë•', desc:'LVL 2: Splits into 3 Units: Soldier, Defender, Mage.', tier:'legendary', req:'serbian'},
        {id:'serbian_p3', base:'serbian', name:'PATH 3: VANGUARD', icon:'üõ°Ô∏è', desc:'LVL 2: Sword & Shield Unit. 20 Durability. Tanky.', tier:'legendary', req:'serbian'},
        {id:'serbian_p1_evo', base:'serbian_p1', name:'BERSERKER', icon:'üå™Ô∏è', desc:'LVL 3: 1.5x Size/Dmg. Spin Attack (3 hits). 4s Cooldown.', tier:'legendary', req:'serbian_p1'},
        {id:'serbian_p2_evo', base:'serbian_p2', name:'ELITE SQUAD', icon:'‚ú®', desc:'LVL 3: Shield gets Pushback. Mage gets Visoko Beam.', tier:'legendary', req:'serbian_p2'},
        {id:'serbian_p3_evo', base:'serbian_p3', name:'WARLORD TANK', icon:'üí¢', desc:'LVL 3: 30 Durability. Taunts enemies every 20s.', tier:'legendary', req:'serbian_p3'}
    ];
    
    const SUPERCHARGES = [
        {id:'supercharge_burek', name:'SUPERCHARGE: MAGMA', icon:'üåã', desc:'Increases Burn Damage.', tier:'legendary'},
        {id:'supercharge_pyramid', name:'SUPERCHARGE: SOLAR', icon:'üî•', desc:'+20% Damage for Solar Flare.', tier:'legendary'},
        {id:'supercharge_cevapi', name:'SUPERCHARGE: COAL', icon:'ü•©', desc:'+1 Burn Tick Duration for Overheat Cevapis.', tier:'legendary'}
    ];

    const SPECIAL_REWARDS = [
        {id:'musical_beat', name:'MUSICAL BEAT', icon:'üéµ', desc:'XP Gain Multiplied by 1.5x.', tier:'legendary'},
        {id:'rhythmic_buff', name:'RHYTHMIC BUFF', icon:'ü•Å', desc:'Every 18s, gain +40% Size and Damage for 2s.', tier:'legendary'},
        {id:'piano_smash', name:'PIANO SMASH', icon:'üéπ', desc:'Calls down a piano to smash enemies near you. (100 Base Dmg + Level).', tier:'legendary'}
    ];

    const ENEMY_INFO = [
        {name:'Promaja', icon:'üí®', desc:'The silent killer. A swirling vortex of cold air.'},
        {name:'Yugo 45', icon:'üöó', desc:'Tanky unit. Hard to destroy, hits like a truck.'},
        {name:'Hornet', icon:'üêù', desc:'Swarm unit. Fast, aggressive, attacks in groups.'},
        {name:'Snajper', icon:'üü•', desc:'Long-range sniper. Punishment for standing still.'},
        {name:'Medic', icon:'üöë', desc:'Healer unit. Sustains the horde. Priority target.'},
        {name:'Krvavi Lovac', icon:'üî™', desc:'Phase Shifter. Turns invisible and immune. Spawns after 7 mins.'},
        {name:'Nolan-ite', icon:'üáµüá±', desc:'Summoned by Braxton. Fast, shoots Warsaw blasts.'},
        {name:'WARLORD', icon:'üëπ', desc:'The Final Boss. Immune to Nuke/Freeze. 5000 HP.'},
        {name:'BRAXTON-inite', icon:'üåÆ', desc:'15,000 HP. Kills everything. Summons Nolans. Lasers.'},
        {name:'The Polyrhythm', icon:'üé∂', desc:'15 Min Boss. Fast, Dodges, Heals. Don\'t move during waves.'},
        {name:'Te≈æina Presude', icon:'‚öñÔ∏è', desc:'20 Min Boss. Judgment. Stores damage then reflects it. Instakills summons.'}
    ];

    let gameActive = false;
    let isPaused = false;
    let isCutscene = false;
    let crateRewards = []; 
    
    let state = { 
        frames:0, gameTime:0, score:0, level:1, xp:0, nextLevelXp:20, xpMult:1, shake:0, 
        enemies:[], particles:[], projectiles:[], beams:[], zones:[], gems:[], perks:[], backgroundStars:[], 
        bossActive:false, bossSpawnedOnce:false, braxtonSpawned:false, braxtonActive:false, flashAlpha:0,
        friendlyUnits: [], crates: [], texts: [],
        polyrhythmSpawned: false, polyrhythmActive: false, rhythmicBuffTimer: 0,
        tezinaSpawned: false, tezinaActive: false
    };
    let player = { 
        x:0, y:0, hp:100, maxHp:100, speed:6, radius:20, magnetRadius:140, armor:0, regen:0, critChance:0.05, cdr:1.0, facing:0, 
        luck: 1.0, visible: true, invincible: 0,
        weapons:{},
        items:{} 
    };

    function resize(){ W=canvas.width=window.innerWidth; H=canvas.height=window.innerHeight; }
    window.addEventListener('resize', resize); resize();

    const keys = {};
    window.addEventListener('keydown', e=>{
        keys[e.key.toLowerCase()]=true;
        if(e.key === "Escape" && gameActive) togglePause();
        
        if(e.key.length === 1) {
            inputBuffer += e.key;
            if(inputBuffer.length > CHEAT_CODE.length) inputBuffer = inputBuffer.slice(-CHEAT_CODE.length);
            if(inputBuffer === CHEAT_CODE){
                openAdmin();
            }
        }
    }); 
    window.addEventListener('keyup', e=>keys[e.key.toLowerCase()]=false);

    function triggerDeath() {
        document.getElementById('final-score').innerText=state.score;
        document.getElementById('game-over').style.display='flex';
        gameActive=false;
    }

    function openAdmin(){
        if(!gameActive) return;
        populateAdminSelect();
        document.getElementById('admin-panel').style.display='flex';
        if(!isPaused) togglePause();
    }
    
    function populateAdminSelect() {
        const sel = document.getElementById('admin-augment-select');
        sel.innerHTML = "";
        const all = [...UPGRADES, ...EVOLUTIONS, ...SUPERCHARGES, ...SPECIAL_REWARDS];
        all.forEach(u => {
            let opt = document.createElement('option');
            opt.value = u.id;
            opt.innerText = u.name;
            sel.appendChild(opt);
        });
    }
    
    function adminForceUpgrade() {
        const val = document.getElementById('admin-augment-select').value;
        applyUpgrade(val);
        spawnDamageText(player.x, player.y-80, "ADMIN UPGRADE", true);
        closeAdmin();
    }

    function adminCycleLuck() {
        if(player.luck === 1.0) player.luck = 2.0;
        else if(player.luck === 2.0) player.luck = 5.0;
        else if(player.luck === 5.0) player.luck = 10.0;
        else player.luck = 1.0;
        document.getElementById('admin-luck-val').innerText = player.luck + "x";
    }

    function adminToggleSpawns() {
        spawningEnabled = !spawningEnabled;
        spawnDamageText(player.x, player.y-60, spawningEnabled ? "SPAWNS ON" : "SPAWNS OFF", 'normal');
    }

    function adminSpawnEnemy() {
        const type = document.getElementById('spawn-enemy-select').value;
        let e = new Enemy(type);
        if(type === 'BRAXTON') { 
            triggerBraxtonCutscene(); 
            closeAdmin();
            return;
        }
        if(type === 'POLYRHYTHM') {
             triggerMusicalIntro();
             closeAdmin();
             return;
        }
        if(type === 'TEZINA') {
            triggerClockIntro();
            closeAdmin();
            return;
        }
        state.enemies.push(e);
        spawnDamageText(player.x, player.y-80, "SPAWNED " + type, 'normal');
    }

    function closeAdmin(){
        document.getElementById('admin-panel').style.display='none';
        if(isPaused) togglePause();
    }
    function toggleGodMode(){
        godMode = !godMode;
        document.getElementById('god-mode-indicator').style.display = godMode ? 'block' : 'none';
        spawnDamageText(player.x, player.y-60, godMode ? "GOD MODE ON" : "GOD MODE OFF", 'normal');
    }
    function adminLevelUp(){
        state.xp = state.nextLevelXp;
        checkLevelUp();
    }
    function adminKillAll(){
        state.enemies.forEach(e => {
            if(e.type !== 'BRAXTON' && e.type !== 'POLYRHYTHM' && e.type !== 'TEZINA') e.takeDamage(99999, true);
        });
    }
    function adminHeal(){
        player.hp = player.maxHp;
        updateHud();
    }

    function openInfo(type){
        document.getElementById('info-modal').style.display='flex';
        const content = document.getElementById('info-content');
        const title = document.getElementById('info-title');
        content.innerHTML = '';
        
        if(type === 'armory'){
            title.innerText = "ARMORY PROTOCOLS";
            const allItems = [...UPGRADES, ...EVOLUTIONS, ...SPECIAL_REWARDS].filter(u => !u.id.includes('serbian_p'));

            allItems.forEach(u => {
                let extraClass = '';
                if(u.tier === 'rare') extraClass = 'rare';
                if(u.tier === 'legendary') extraClass = 'legendary';
                content.innerHTML += `
                <div class="info-card ${extraClass}">
                    <div class="info-icon">${u.icon}</div>
                    <div class="info-text"><h3>${u.name}</h3><p>${u.desc}</p></div>
                </div>`;
            });
        } else {
            title.innerText = "THREAT INTEL";
            ENEMY_INFO.forEach(e => {
                content.innerHTML += `
                <div class="info-card">
                    <div class="info-icon">${e.icon}</div>
                    <div class="info-text"><h3>${e.name}</h3><p>${e.desc}</p></div>
                </div>`;
            });
        }
    }

    function closeInfo(){ document.getElementById('info-modal').style.display='none'; }
    
    function startGame(){
        document.getElementById('main-menu').style.display='none';
        resetGame();
    }
    
    function quitGame(){
        gameActive = false;
        document.getElementById('game-over').style.display='none';
        document.getElementById('pause-screen').style.display='none';
        document.getElementById('ui-layer').style.display='none';
        document.getElementById('boss-hud').style.display='none';
        document.getElementById('admin-panel').style.display='none';
        document.getElementById('evolution-overlay').style.display='none';
        document.getElementById('braxton-cutscene').style.display='none';
        document.getElementById('crate-screen').style.display='none';
        document.getElementById('clock-overlay').style.display='none';
        document.getElementById('boss-caption').style.opacity = '0';
        document.getElementById('main-menu').style.display='flex';
    }

    function togglePause(){
        if(!gameActive) return;
        if(isCutscene) return;
        if(document.getElementById('levelup-screen').style.display === 'flex') return;
        if(document.getElementById('evolution-overlay').style.display === 'flex') return;
        if(document.getElementById('crate-screen').style.display === 'flex') return;
        isPaused = !isPaused;
        document.getElementById('pause-screen').style.display = isPaused ? 'flex' : 'none';
        
        if(isPaused) {
            const statsBox = document.getElementById('pause-stats');
            statsBox.innerHTML = '';
            
            let allAbilities = [];
            for (const [key, val] of Object.entries(player.weapons)) {
                if (val.level > 0) {
                    let info = UPGRADES.find(u => u.id === key) || SPECIAL_REWARDS.find(u => u.id === key);
                    let name = info ? info.name : key;
                    if(key === 'serbian') name = "Serbian Warrior";
                    let displayLvl = val.evolved ? "EVOLVED" : val.level;
                    allAbilities.push({ name: name, lvl: displayLvl });
                }
            }
            for (const [key, val] of Object.entries(player.items)) {
                if (val > 0) {
                    let info = UPGRADES.find(u => u.id === key) || SPECIAL_REWARDS.find(u => u.id === key);
                    let name = info ? info.name : key;
                    allAbilities.push({ name: name, lvl: val });
                }
            }
            if(allAbilities.length === 0) statsBox.innerHTML = '<div style="color:#777; font-family:Rajdhani">No Augmentations</div>';

            allAbilities.forEach(ab => {
                 let row = document.createElement('div');
                 row.className = 'pause-item';
                 row.innerHTML = `<span>${ab.name}</span><span style="color:var(--neon-cyan)">${ab.lvl}</span>`;
                 statsBox.appendChild(row);
            });
        }
    }

    function initBackground() {
        state.backgroundStars = [];
        for(let i=0; i<60; i++) { 
            state.backgroundStars.push({
                x: Math.random() * W,
                y: Math.random() * H,
                size: Math.random() * 2 + 1,
                alpha: Math.random() * 0.5 + 0.1
            });
        }
    }

    function resetGame(){
        gameActive = true;
        isPaused = false;
        isCutscene = false;
        godMode = false;
        spawningEnabled = true;
        document.getElementById('god-mode-indicator').style.display='none';
        document.getElementById('boss-caption').style.opacity = '0';
        state = { 
            frames:0, gameTime:0, score:0, level:1, xp:0, nextLevelXp:20, xpMult:1, shake:0, 
            enemies:[], particles:[], projectiles:[], beams:[], zones:[], gems:[], perks:[], backgroundStars:[],
            bossActive:false, bossSpawnedOnce:false, braxtonSpawned:false, braxtonActive:false, flashAlpha:0,
            friendlyUnits: [], crates: [], texts: [],
            polyrhythmSpawned: false, polyrhythmActive: false, rhythmicBuffTimer: 0,
            tezinaSpawned: false, tezinaActive: false
        };
        initBackground();
        
        player = { 
            x:W/2, y:H/2, hp:100, maxHp:100, speed:6, radius:20, magnetRadius:140, armor:0, regen:0, critChance:0.05, cdr:1.0, facing:0, 
            luck: 1.0, visible: true, invincible: 0,
            weapons:{
                burek: { level:1, count:1, damage:10, dist:100, speed:0.02, evolved:false, orbs:[], trailTimer:0 },
                cevapi: { level:1, cooldown:30, baseCool:30, timer:0, damage:15, evolved:false, grillAngle:0, lastBurstScore:0, burnCount:25 }, 
                ajvar: { level:0, cooldown:140, baseCool:140, timer:0, damage:80 },
                rakija: { level:0, cooldown:190, baseCool:190, timer:0, damage:4, duration:300 }, 
                pyramid: { level:0, cooldown:110, baseCool:110, timer:0, damage:50, evolved:false },
                spike: { level:0, cooldown:180, baseCool:180, timer:0, damage:60 }, 
                flag: { level:0, cooldown:240, baseCool:240, count:1, timer:0 },
                harmonika: { level:0, range:240, slow:0.30 },
                serbian: { level:0, path: 0, evolved: false },
                piano_smash: { level: 0, cooldown: 300, timer: 0 }
            },
            items: {
                speed:0, magnet:0, armor:0, heal:0, coffee:0, lily:0, vrelo:0, xp_boost:0,
                sword:0, cracked_jewelry:0, musical_beat:0, rhythmic_buff:0
            }
        };

        document.getElementById('game-over').style.display='none';
        document.getElementById('levelup-screen').style.display='none';
        document.getElementById('pause-screen').style.display='none';
        document.getElementById('boss-hud').style.display='none';
        document.getElementById('admin-panel').style.display='none';
        document.getElementById('evolution-overlay').style.display='none';
        document.getElementById('braxton-cutscene').style.display='none';
        document.getElementById('crate-screen').style.display='none';
        document.getElementById('clock-overlay').style.display='none';
        document.getElementById('ui-layer').style.display='flex';
        updateHud();
    }

    function createParticle(x,y,color,type,speedM=1) {
        if(state.particles.length>250) return; 
        const p={x:x,y:y,vx:(Math.random()-0.5)*8*speedM,vy:(Math.random()-0.5)*8*speedM,life:1,decay:0.015+Math.random()*0.03,color:color,size:Math.random()*6+2,type:type};
        if(type==='fire'){p.vy-=2;p.decay=0.04;p.size*=1.5;} 
        if(type==='spark'){p.decay=0.06;p.size=2;p.life=0.8;} 
        if(type==='smoke'){p.vx*=0.3;p.vy*=0.3;p.size=12;p.decay=0.01;p.color='#555';} 
        if(type==='plasma'){p.decay=0.08;p.size=Math.random()*12+4;}
        if(type==='note'){p.decay=0.02;p.size=10;p.vx*=0.5;p.vy=-2;p.char='üéµ';}
        if(type==='blood'){p.decay=0.03;p.size=Math.random()*5+2;p.color='#aa0000';}
        if(type==='heal'){p.decay=0.05; p.vy=-1; p.size=4; p.color='#00ff41';}
        state.particles.push(p);
    }
    
    function spawnDamageText(x,y,dmg,type='normal'){ 
        let color = '#fff';
        let scale = 1.0;
        let displayVal = (typeof dmg === 'number') ? Math.floor(dmg) : dmg;

        if(type === 'crit') { color = '#00f3ff'; scale = 2.0; }
        if(type === 'player') { color = '#ff003c'; scale = 1.5; displayVal = "-" + displayVal; } 
        state.texts.push({x:x+(Math.random()-0.5)*30,y:y,val:displayVal,life:1,color:color,scale:scale,vy:-2}); 
    }
    
    function addShake(amt){ state.shake=Math.min(state.shake+amt,30); }
    
    function calcDamage(base){ 
        let levelBonus = Math.max(0, state.level - 1); 
        let totalBase = base + (levelBonus * 0.5);
        if(player.items.sword > 0) totalBase *= (1 + (player.items.sword * 0.1));
        
        // Rhythmic Buff Effect
        if(player.items.rhythmic_buff > 0 && state.rhythmicBuffTimer > 1080) {
            totalBase *= 1.4;
        }

        let isCrit = Math.random() < player.critChance; 
        let dmg = totalBase * (isCrit ? 2.0 : 1.0); 
        return {d:dmg, c:isCrit}; 
    }

    // --- FRIENDLY UNIT SYSTEM ---
    class FriendlyUnit {
        constructor(type, x, y) {
            this.type = type;
            this.x = x; this.y = y;
            
            this.maxDurability = 10;
            this.baseDamage = 50;
            this.radius = 25;
            this.attackRange = 100;
            this.attackSpeed = 180;
            this.moveSpeed = 3.5;
            this.respawnTime = 30 * 60;
            
            this.durability = this.maxDurability;
            this.attackTimer = 0;
            this.immuneTimer = 0;
            this.dead = false;
            this.respawnTimer = 0;
            this.magnetRadius = 250;
            this.taunting = false;
            this.tauntTimer = 0;
            this.tauntCooldown = 0;
            this.invisibleTimer = 0; 

            if(type === 'soldier') { this.maxDurability = 10; }
            if(type === 'titan') { this.baseDamage = 75; }
            if(type === 'vanguard') { this.maxDurability = 20; }
            if(type === 'defender') { this.maxDurability = 15; this.baseDamage = 0; }
            if(type === 'mage') { this.maxDurability = 3; this.attackRange = 400; }

            const tech = player.weapons.serbian;
            if(tech.path === 2 && type === 'soldier') this.maxDurability = 5;
            
            // --- LEVEL 3 (EVOLUTION) LOGIC ---
            this.isBerserk = false; this.canTaunt = false; this.canPush = false; this.hasBeam = false;

            if(tech.path === 3 && tech.evolved) { this.maxDurability = 30; this.canTaunt = true; } // Warlord Tank
            if(tech.path === 1 && tech.evolved) { this.radius *= 1.5; this.baseDamage *= 1.5; this.attackSpeed = 240; this.isBerserk = true; } // Berserker
            if(tech.path === 2 && tech.evolved) {
                if(type === 'defender') { this.maxDurability = 10; this.canPush = true; this.pushTimer = 0; } // Elite Defender
                if(type === 'mage') { this.hasBeam = true; } // Elite Mage
            }
            this.durability = this.maxDurability;
        }

        update() {
            if(this.dead) {
                this.respawnTimer--;
                if(this.respawnTimer <= 0) {
                    this.dead = false;
                    this.durability = this.maxDurability;
                    this.immuneTimer = 180;
                    this.x = player.x; this.y = player.y;
                    spawnDamageText(this.x, this.y-50, "UNIT READY", 'normal');
                    createParticle(this.x, this.y, '#fff', 'plasma', 5);
                }
                return;
            }
            if(this.immuneTimer > 0) this.immuneTimer--;
            if(this.invisibleTimer > 0) this.invisibleTimer--;

            state.gems.forEach(g => {
                if(!g.vacuum) {
                    let d = Math.hypot(g.x - this.x, g.y - this.y);
                    if(d < this.magnetRadius) g.vacuum = true;
                }
            });

            // AI MOVEMENT
            let target = null;
            let minDist = 9999;
            let enemiesNearby = 0;

            state.enemies.forEach(e => {
                let d = Math.hypot(e.x - this.x, e.y - this.y);
                if(d < 150) enemiesNearby++;
                if(d < minDist) { minDist = d; target = e; }
            });

            let moveX = 0, moveY = 0;
            let distToPlayer = Math.hypot(player.x - this.x, player.y - this.y);
            
            // --- SQUAD SOLDIER LOGIC: 12000px LEASH ---
            if(this.type === 'soldier' && player.weapons.serbian.path === 2 && distToPlayer > 12000) {
                 // Return to player if absurdly far
                 let ang = Math.atan2(player.y - this.y, player.x - this.x);
                 moveX = Math.cos(ang) * 5.0; 
                 moveY = Math.sin(ang) * 5.0;
            } 
            else if(distToPlayer > 250 && this.type === 'soldier' && player.weapons.serbian.path === 2) {
                 // No leash logic, free roam until 12000
                 if(target) {
                     let ang = Math.atan2(target.y - this.y, target.x - this.x);
                     moveX = Math.cos(ang); moveY = Math.sin(ang);
                 } else {
                     // Wander
                     moveX = (Math.random()-0.5); moveY = (Math.random()-0.5);
                 }
            } 
            else if(distToPlayer > 800) {
                 let ang = Math.atan2(player.y - this.y, player.x - this.x);
                 moveX = Math.cos(ang) * 2;
                 moveY = Math.sin(ang) * 2;
            } else {
                if(this.type === 'mage') {
                    let protectTarget = state.friendlyUnits.find(u => u.type === 'defender' && !u.dead) || player;
                    let dProt = Math.hypot(protectTarget.x - this.x, protectTarget.y - this.y);
                    if(minDist < 200) { 
                         let ang = Math.atan2(target.y - this.y, target.x - this.x);
                         moveX = -Math.cos(ang); moveY = -Math.sin(ang);
                    } else if(dProt > 100) { 
                         let ang = Math.atan2(protectTarget.y - this.y, protectTarget.x - this.x);
                         moveX = Math.cos(ang); moveY = Math.sin(ang);
                    }
                } 
                else if (this.type === 'defender') {
                     if(target) {
                         let ang = Math.atan2(target.y - player.y, target.x - player.x);
                         let blockX = player.x + Math.cos(ang) * 60;
                         let blockY = player.y + Math.sin(ang) * 60;
                         let dBlock = Math.hypot(blockX - this.x, blockY - this.y);
                         if(dBlock > 10) {
                             let angM = Math.atan2(blockY - this.y, blockX - this.x);
                             moveX = Math.cos(angM); moveY = Math.sin(angM);
                         }
                     } else {
                         let dP = Math.hypot(player.x - this.x, player.y - this.y);
                         if(dP > 60) {
                             let ang = Math.atan2(player.y - this.y, player.x - this.x);
                             moveX = Math.cos(ang); moveY = Math.sin(ang);
                         }
                     }
                }
                else { 
                    if(enemiesNearby >= 5) { moveX = 0; moveY = 0; } 
                    else {
                        if(target) {
                            let d = Math.hypot(target.x - this.x, target.y - this.y);
                            if(d > 40) {
                                 let ang = Math.atan2(target.y - this.y, target.x - this.x);
                                 moveX = Math.cos(ang); moveY = Math.sin(ang);
                            }
                        } else {
                            let dP = Math.hypot(player.x - this.x, player.y - this.y);
                             if(dP > 100) {
                                 let ang = Math.atan2(player.y - this.y, player.x - this.x);
                                 moveX = Math.cos(ang); moveY = Math.sin(ang);
                             }
                        }
                    }
                }
            }

            this.x += moveX * this.moveSpeed;
            this.y += moveY * this.moveSpeed;

            // --- LEVEL 3: WARLORD TANK TAUNT ---
            if(this.canTaunt) {
                if(this.tauntCooldown > 0) this.tauntCooldown--;
                if(this.taunting) {
                    this.tauntTimer--;
                    if(this.tauntTimer <= 0) {
                        this.taunting = false;
                        this.tauntCooldown = 1200; 
                    }
                } else if(this.tauntCooldown <= 0 && enemiesNearby > 0) {
                    this.taunting = true;
                    this.tauntTimer = 300; 
                    spawnDamageText(this.x, this.y-60, "AGGRESION", 'normal');
                    state.zones.push(new Zone(this.x, this.y, 'taunt_ring', 300));
                }
            }

            // --- LEVEL 3: ELITE DEFENDER PUSH ---
            if(this.canPush) {
                 this.pushTimer++;
                 if(this.pushTimer > 900) { 
                     this.pushTimer = 0;
                     state.zones.push(new Zone(this.x, this.y, 'shield_push', 20)); 
                     let range = player.weapons.harmonika.range * 1.5;
                     state.enemies.forEach(e => {
                         let d = Math.hypot(e.x - this.x, e.y - this.y);
                         if(d < range) {
                             let ang = Math.atan2(e.y - this.y, e.x - this.x);
                             e.pushX = Math.cos(ang) * 25;
                             e.pushY = Math.sin(ang) * 25;
                         }
                     });
                     spawnDamageText(this.x, this.y-60, "SHIELD BASH", 'normal');
                 }
            }

            this.attackTimer++;
            if(this.attackTimer > this.attackSpeed) {
                if(this.type === 'mage') {
                    if(target) {
                        this.attackTimer = 0;
                        let pLevel = Math.max(1, player.weapons.cevapi.level);
                        let p = new Projectile(this.x, this.y, target, 'cevapi');
                        p.overrideDamage = 15 + (pLevel * 10) + (state.level * 1);
                        state.projectiles.push(p);

                        // --- LEVEL 3: ELITE MAGE BEAM ---
                        if(this.hasBeam) {
                             let beamLvl = Math.max(1, player.weapons.pyramid.level);
                             let ang = Math.atan2(target.y - this.y, target.x - this.x);
                             state.beams.push(new Beam(this.x, this.y, ang));
                             state.enemies.forEach(e => {
                                 let d = Math.hypot(e.x - this.x, e.y - this.y); 
                                 if(d < 600 && Math.abs(Math.atan2(e.y-this.y, e.x-this.x) - ang) < 0.2) {
                                     e.takeDamage(50 * beamLvl, false, 'friendly_beam');
                                 }
                             });
                        }
                    }
                }
                else if(this.type === 'defender') { }
                else {
                    this.attackTimer = 0;
                    addShake(5);
                    let damageCalc = this.baseDamage + (state.level * 5);
                    
                    // --- LEVEL 3: BERSERKER SPIN ---
                    if(this.isBerserk) {
                        state.zones.push(new Zone(this.x, this.y, 'berserk_spin', 45, damageCalc)); 
                        spawnDamageText(this.x, this.y-60, "SPIN!", 'normal');
                    } else {
                        state.zones.push(new Zone(this.x, this.y, 'valk_swing', 15, damageCalc));
                        state.enemies.forEach(e => {
                            if(Math.hypot(e.x - this.x, e.y - this.y) < 160) {
                                e.takeDamage(damageCalc, true, 'friendly');
                            }
                        });
                    }
                }
            }
        }

        takeDamage(amt) {
            if(this.immuneTimer > 0) return;
            if(this.invisibleTimer > 0) return; // Mage invisible, no damage

            // MAGE SPECIAL ABILITY: Invisibility on hit
            if(this.type === 'mage') {
                this.invisibleTimer = 180; // 3 seconds
                spawnDamageText(this.x, this.y - 40, "PHASE SHIFT", 'normal');
                return; // NO DURABILITY LOSS
            }

            this.durability--;
            this.immuneTimer = 300; 
            spawnDamageText(this.x, this.y - 30, "-1 DUR", 'normal');
            createParticle(this.x, this.y, '#00f3ff', 'plasma', 3);

            if(this.durability <= 0) {
                this.dead = true;
                this.respawnTimer = this.respawnTime;
                spawnDamageText(this.x, this.y-50, "UNIT DOWN", 'normal');
            }
        }

        draw(cX, cY) {
            if(this.dead) {
                let sec = Math.ceil(this.respawnTimer / 60);
                ctx.fillStyle = '#555'; ctx.font='12px Orbitron'; ctx.fillText(`RESPAWN: ${sec}s`, this.x - cX, this.y - cY);
                return;
            }
            ctx.save(); ctx.translate(this.x - cX, this.y - cY);
            
            // COMMON ANIMATION VARIABLES
            let breath = 1 + Math.sin(state.frames * 0.05) * 0.03;
            let bob = Math.sin(state.frames * 0.1) * 2;
            ctx.scale(breath, breath);
            ctx.translate(0, bob);

            if(this.invisibleTimer > 0) ctx.globalAlpha = 0.3;

            if(this.immuneTimer > 0) {
                 ctx.save();
                 ctx.globalAlpha = (this.invisibleTimer > 0 ? 0.3 : 1) * (0.4 + Math.sin(state.frames*0.5)*0.2);
                 ctx.fillStyle = '#00f3ff';
                 ctx.beginPath(); ctx.arc(0,0, 35, 0, 6.28); ctx.fill();
                 ctx.strokeStyle = '#fff'; ctx.lineWidth=2; ctx.stroke();
                 ctx.restore();
            }
            
            // --- DRAWING LOGIC ---

            if(this.type === 'soldier') {
                 // Level 1: Basic Soldier
                 // Feet (Marching)
                 let legOffset = Math.sin(state.frames * 0.2) * 5;
                 ctx.fillStyle = '#333';
                 ctx.beginPath(); ctx.arc(-8, 20+legOffset, 5, 0, 6.28); ctx.fill(); // Left foot
                 ctx.beginPath(); ctx.arc(8, 20-legOffset, 5, 0, 6.28); ctx.fill(); // Right foot
                 // Body / Blue Tabard
                 ctx.fillStyle = '#002395'; 
                 ctx.beginPath(); ctx.moveTo(-10, -10); ctx.lineTo(10, -10); ctx.lineTo(12, 15); ctx.lineTo(-12, 15); ctx.fill();
                 // Silver Helmet
                 ctx.fillStyle = '#aaa'; 
                 ctx.beginPath(); ctx.arc(0, -12, 10, 0, Math.PI, true); ctx.lineTo(10, -5); ctx.lineTo(-10, -5); ctx.fill();
                 // Arms & Sword
                 ctx.fillStyle = '#999';
                 ctx.beginPath(); ctx.arc(-12, -2, 4, 0, 6.28); ctx.fill(); // Left Shoulder
                 ctx.beginPath(); ctx.arc(12, -2, 4, 0, 6.28); ctx.fill(); // Right Shoulder
                 
                 ctx.save();
                 ctx.translate(15, 5); 
                 let swing = Math.sin(this.attackTimer * 0.2) * 0.5;
                 if(this.attackTimer < 10) swing = -1.5; // Attack frame
                 ctx.rotate(swing);
                 ctx.fillStyle = '#ddd'; ctx.fillRect(-2, -25, 4, 30); // Blade
                 ctx.fillStyle = '#555'; ctx.fillRect(-4, 0, 8, 2); // Crossguard
                 ctx.fillStyle = '#444'; ctx.beginPath(); ctx.arc(0, 5, 3, 0, 6.28); ctx.fill(); // Pommel
                 ctx.restore();
            }
            else if (this.type === 'titan') {
                 // Level 2/3: Titan / Berserker
                 // Massive Feet
                 let legOffset = Math.sin(state.frames * 0.15) * 3;
                 ctx.fillStyle = '#111';
                 ctx.fillRect(-15, 25+legOffset, 12, 8); ctx.fillRect(5, 25-legOffset, 12, 8);
                 // Armor
                 ctx.fillStyle = '#222'; 
                 ctx.beginPath(); ctx.moveTo(-20, -20); ctx.lineTo(20, -20); ctx.lineTo(15, 20); ctx.lineTo(-15, 20); ctx.fill();
                 // Spikes
                 if(this.isBerserk) {
                     ctx.fillStyle = '#800'; 
                     ctx.beginPath(); ctx.moveTo(-20,-20); ctx.lineTo(-25,-35); ctx.lineTo(-15,-25); ctx.fill();
                     ctx.beginPath(); ctx.moveTo(20,-20); ctx.lineTo(25,-35); ctx.lineTo(15,-25); ctx.fill();
                 }
                 // Helmet & Eyes
                 ctx.fillStyle = '#333'; ctx.beginPath(); ctx.arc(0, -20, 12, 0, 6.28); ctx.fill();
                 ctx.fillStyle = this.isBerserk ? '#f00' : '#fa0'; 
                 ctx.shadowColor = ctx.fillStyle; ctx.shadowBlur = 10;
                 ctx.beginPath(); ctx.rect(-5, -22, 3, 2); ctx.rect(2, -22, 3, 2); ctx.fill();
                 ctx.shadowBlur = 0;
                 // Massive Sword
                 ctx.save();
                 ctx.translate(25, 0); 
                 let angle = 0.5;
                 if(this.isBerserk && this.attackTimer < 15) {
                     angle = -2.0 + (this.attackTimer/15)*3.0; // Spin/Slash
                     ctx.fillStyle = 'rgba(255,0,0,0.3)'; ctx.beginPath(); ctx.arc(-25, 0, 70, 0, 6.28); ctx.fill();
                 }
                 ctx.rotate(angle);
                 ctx.fillStyle = '#111'; ctx.fillRect(-5, -60, 14, 70); // Blade slab
                 ctx.fillStyle = '#444'; ctx.fillRect(-8, 5, 20, 5); // Guard
                 ctx.restore();
            }
            else if (this.type === 'vanguard') {
                 ctx.fillStyle = '#223';
                 ctx.fillRect(-12, 22, 10, 8); ctx.fillRect(2, 22, 10, 8);
                 ctx.fillStyle = this.canTaunt ? '#111' : '#445';
                 ctx.fillRect(-15, -15, 30, 40);
                 ctx.fillStyle = '#556';
                 ctx.beginPath(); ctx.arc(0, -18, 12, 0, 6.28); ctx.fill();
                 ctx.fillStyle = '#000'; ctx.fillRect(-8, -20, 16, 4); // Eye slit
                 ctx.fillStyle = this.canTaunt ? '#311' : '#556';
                 ctx.fillRect(-20, -10, 25, 50); // Covers left side mostly
                 ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.strokeRect(-20, -10, 25, 50);
                 ctx.save();
                 ctx.translate(20, 5); ctx.rotate(-0.5);
                 ctx.fillStyle = '#654321'; ctx.fillRect(-2, -20, 4, 25);
                 ctx.fillStyle = '#888'; ctx.beginPath(); ctx.arc(0, -22, 8, 0, 6.28); ctx.fill(); // Head
                 ctx.restore();
                 if(this.taunting) {
                     ctx.strokeStyle = '#ff003c'; ctx.lineWidth = 3;
                     ctx.beginPath(); ctx.arc(0,0, 60 + Math.sin(state.frames*0.5)*10, 0, 6.28); ctx.stroke();
                 }
            }
            else if (this.type === 'defender') {
                 ctx.fillStyle = '#777'; ctx.fillRect(-10, 15, 8, 12); ctx.fillRect(2, 15, 8, 12);
                 ctx.fillStyle = '#889'; ctx.fillRect(-12, -10, 24, 30);
                 ctx.fillStyle = '#fff'; ctx.fillRect(-5, -10, 10, 30); // Cross line
                 ctx.fillStyle = '#667';
                 ctx.beginPath(); ctx.arc(0, -15, 10, 3.14, 0); ctx.fill(); // Dome
                 ctx.fillRect(-12, -15, 24, 4); // Brim
                 ctx.fillStyle = this.canPush ? '#00f3ff' : '#334'; 
                 if(this.canPush) ctx.globalAlpha = 0.7; 
                 ctx.beginPath(); ctx.arc(10, 5, 16, 0, 6.28); ctx.fill();
                 ctx.strokeStyle = '#aaa'; ctx.lineWidth=3; ctx.stroke();
                 ctx.globalAlpha = 1;
            }
            else if (this.type === 'mage') {
                 let sway = Math.sin(state.frames * 0.1) * 3;
                 ctx.fillStyle = this.hasBeam ? '#4b0082' : '#800080'; // Dark Purple vs Purple
                 ctx.beginPath(); ctx.moveTo(0, -20);
                 ctx.bezierCurveTo(-15, 0, -20+sway, 25, 0, 30); ctx.bezierCurveTo(20+sway, 25, 15, 0, 0, -20); ctx.fill();
                 ctx.strokeStyle = '#ffd700'; ctx.lineWidth = 1; ctx.stroke();
                 ctx.fillStyle = this.hasBeam ? '#eee' : '#d000ff';
                 ctx.beginPath(); ctx.arc(0, -20, 8, 0, 6.28); ctx.fill();
                 ctx.fillStyle = '#222';
                 ctx.beginPath(); ctx.moveTo(-10, -24); ctx.lineTo(10, -24); ctx.lineTo(0, -40); ctx.fill();
                 let bookBob = Math.sin(state.frames * 0.15) * 5;
                 ctx.fillStyle = '#8B4513'; ctx.fillRect(15, -10 + bookBob, 12, 16);
                 ctx.fillStyle = '#fff'; ctx.fillRect(17, -8 + bookBob, 8, 12); // Pages
                 if(this.hasBeam) {
                     ctx.strokeStyle = '#d000ff'; ctx.lineWidth = 1;
                     ctx.beginPath(); ctx.arc(0, 0, 35, state.frames*0.1, state.frames*0.1+4); ctx.stroke();
                 }
            }

            ctx.fillStyle = 'red'; ctx.fillRect(-20, -45, 40, 4);
            ctx.fillStyle = '#0f0'; ctx.fillRect(-20, -45, 40 * (this.durability/this.maxDurability), 4);
            ctx.restore();
        }
    }
    
    class Crate {
        constructor(x, y, type='standard') {
            this.x = x; this.y = y;
            this.bob = 0;
            this.radius = 30;
            this.type = type; // 'standard', 'musical', 'tezina_reward'
        }
        update() {
            this.bob += 0.1;
            const dx = player.x - this.x, dy = player.y - this.y;
            if(Math.hypot(dx, dy) < player.radius + this.radius) {
                triggerCrateOpening(this.type);
                return true; // Collected
            }
            return false;
        }
        draw(cX, cY) {
            let yOff = Math.sin(this.bob) * 5;
            let icon = 'üì¶';
            if(this.type === 'musical') icon = 'üéµ';
            if(this.type === 'tezina_reward') icon = 'üëë';
            
            let color = '#fecb00';
            if(this.type === 'musical') color = '#00f3ff';
            if(this.type === 'tezina_reward') color = '#e5e4e2';

            ctx.font = "40px Arial"; ctx.textAlign="center"; ctx.textBaseline="middle";
            ctx.fillText(icon, this.x - cX, this.y - cY + yOff);
            // Glow
            ctx.beginPath(); ctx.arc(this.x - cX, this.y - cY + yOff + 5, 25, 0, 6.28);
            ctx.strokeStyle = `rgba(${this.type==='musical'?'0,243,255':(this.type==='tezina_reward'?'229,228,226':'254,203,0')}, ${0.5 + Math.sin(this.bob)*0.3})`;
            ctx.lineWidth = 3; ctx.stroke();
        }
    }

    class Perk {
        constructor(x,y,type){
            this.x=x; this.y=y; this.type=type; this.bob=0;
            if(type==='health') this.icon='‚ù§Ô∏è';
            else if(type==='magnet') this.icon='üß≤';
            else if(type==='nuke') this.icon='‚ò¢Ô∏è';
            else if(type==='freeze') this.icon='‚ùÑÔ∏è';
        }
        update(){
            this.bob+=0.1; 
            const dx=player.x-this.x, dy=player.y-this.y, dist=Math.sqrt(dx*dx+dy*dy);
            if(dist < player.radius + 30){
                if(this.type==='health'){ player.hp = Math.min(player.maxHp, player.hp+50); spawnDamageText(player.x,player.y-50,"HEALED",'normal'); for(let i=0;i<10;i++)createParticle(this.x,this.y,'#f00','spark');}
                if(this.type==='magnet'){ state.gems.forEach(g=>g.vacuum=true); spawnDamageText(player.x,player.y-50,"MAGNETIC",'normal');}
                if(this.type==='nuke'){ 
                    addShake(30); state.flashAlpha=0.8;
                    state.enemies.forEach(e=>{ 
                        if(!e.dead && !e.type.includes('BOSS') && e.type !== 'BRAXTON' && e.type !== 'POLYRHYTHM' && e.type !== 'TEZINA'){ e.takeDamage(9999, true); } 
                        else if(e.type.includes('BOSS') || e.type === 'BRAXTON' || e.type === 'POLYRHYTHM' || e.type === 'TEZINA') { spawnDamageText(e.x, e.y-50, "IMMUNE", 'normal'); }
                    }); 
                    spawnDamageText(player.x,player.y-50,"NUKE",'normal'); for(let i=0;i<50;i++)createParticle(player.x,player.y,'#ffaa00','fire',5); 
                }
                if(this.type==='freeze'){ 
                    state.enemies.forEach(e=>{ 
                        if(!e.type.includes('BOSS') && e.type !== 'BRAXTON' && e.type !== 'POLYRHYTHM' && e.type !== 'TEZINA') e.frozen=300; 
                        else spawnDamageText(e.x, e.y-50, "IMMUNE", 'normal');
                    }); 
                    spawnDamageText(player.x,player.y-50,"FROZEN",'normal'); for(let i=0;i<20;i++)createParticle(player.x,player.y,'#00ffff','spark',2); 
                }
                updateHud();
                return true; 
            }
            return false;
        }
        draw(cX,cY){
            let yOff = Math.sin(this.bob)*5;
            ctx.font="30px Arial"; ctx.textAlign="center"; ctx.textBaseline="middle"; 
            ctx.fillText(this.icon, this.x-cX, this.y-cY + yOff);
            ctx.beginPath(); ctx.arc(this.x-cX, this.y-cY+yOff, 20, 0, 6.28);
            ctx.strokeStyle=`rgba(255,255,255,${0.5+Math.sin(this.bob)*0.3})`; ctx.lineWidth=2; ctx.stroke();
        }
    }

    class Gem {
        constructor(x,y, val=0){this.x=x;this.y=y;this.value=val>0?val:(5+(state.level*0.8));this.wobble=Math.random()*6.28;this.vacuum=false;this.size=val>100?10:4;this.color=val>100?'#00f3ff':'#fecb00';}
        update(){
            this.wobble+=0.1; const dx=player.x-this.x, dy=player.y-this.y, dist=Math.sqrt(dx*dx+dy*dy);
            if(this.vacuum || dist<player.magnetRadius){
                let speed = this.vacuum ? 25 : 18;
                this.x+=(dx/dist)*speed;this.y+=(dy/dist)*speed;
            }
            if(dist<player.radius+20){state.xp+=this.value * state.xpMult; checkLevelUp();updateHud();return true;} return false;
        }
        draw(cX,cY){
            ctx.fillStyle=this.color; 
            ctx.beginPath();
            ctx.translate(this.x-cX, this.y-cY);
            ctx.rotate(this.wobble);
            ctx.rect(-this.size/2, -this.size/2, this.size, this.size);
            ctx.fill(); 
            ctx.rotate(-this.wobble); ctx.translate(-(this.x-cX), -(this.y-cY));
        }
    }

    class Beam {
        constructor(x, y, angle, type='default') {
            this.x = x; this.y = y; this.angle = angle; this.type=type;
            this.life = 15; this.maxLife = 15; this.length = 1200;
            if(type === 'heal') { this.length = 200; this.life = 5; this.maxLife = 5; } // Shorter beam for medic
            if(type === 'judgment') { this.length = 2000; this.life = 180; this.maxLife = 180; } // 3 seconds for Te≈æina
        }
        update() { this.life--; return this.life > 0; }
        draw(cX, cY) {
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            
            if(this.type === 'judgment') {
                const p = this.life / this.maxLife;
                const width = 120 + Math.sin(state.frames * 0.5) * 20; // Massive
                
                // Create holy gradient
                let grad = ctx.createLinearGradient(this.x - cX, this.y - cY, (this.x - cX) + Math.cos(this.angle) * this.length, (this.y - cY) + Math.sin(this.angle) * this.length);
                grad.addColorStop(0, '#fff');
                grad.addColorStop(0.5, '#ffd700'); // Gold
                grad.addColorStop(1, 'rgba(255, 255, 255, 0)');
                
                ctx.strokeStyle = grad;
                ctx.lineWidth = width * (p > 0.8 ? (1-p)*5 : 1); // Fade in/out
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(this.x - cX, this.y - cY);
                ctx.lineTo((this.x - cX) + Math.cos(this.angle) * this.length, (this.y - cY) + Math.sin(this.angle) * this.length);
                ctx.stroke();

                ctx.strokeStyle = '#fff';
                ctx.lineWidth = width * 0.3;
                ctx.stroke();
                
                ctx.restore();
                return;
            }

            const opacity = this.life / this.maxLife;
            
            if(this.type === 'heal') {
                ctx.strokeStyle = `rgba(0, 255, 65, ${opacity})`;
                ctx.lineWidth = 5 * opacity;
                ctx.beginPath();
                ctx.moveTo(this.x - cX, this.y - cY);
                // Draw to length or target if we had one, assume length for now
                ctx.lineTo((this.x - cX) + Math.cos(this.angle) * this.length, (this.y - cY) + Math.sin(this.angle) * this.length);
                ctx.stroke();
                ctx.restore();
                return;
            }

            ctx.strokeStyle = `rgba(255, 255, 255, ${opacity})`;
            ctx.lineWidth = 40 * opacity;
            ctx.beginPath();
            ctx.moveTo(this.x - cX, this.y - cY);
            ctx.lineTo((this.x - cX) + Math.cos(this.angle) * this.length, (this.y - cY) + Math.sin(this.angle) * this.length);
            ctx.stroke();
            ctx.strokeStyle = `rgba(255, 100, 0, ${opacity*0.5})`;
            ctx.lineWidth = 120 * opacity;
            ctx.stroke();
            ctx.restore();
        }
    }

    class Projectile {
        constructor(x,y,target,type){
            this.x=x;this.y=y;this.type=type;this.life=150;this.rotation=0;
            this.pierceHitList = [];
            this.overrideDamage = 0;
            this.hitCooldowns = []; // For Warsaw logic
            this.hitTimer = 0; // Simple timer for Warsaw

            // Rhythmic Buff scaling
            this.scale = 1.0;
            if(player.items.rhythmic_buff > 0 && state.rhythmicBuffTimer > 1080) {
                this.scale = 1.4;
            }

            if(type === 'boss_missile' || type === 'sniper_shot' || type === 'warsaw' || type === 'bosnian_flag') {
                let a = 0;
                if(target) a = Math.atan2(target.y-y, target.x-x);
                this.speed = 12; 
                
                if(type === 'sniper_shot') this.speed = 18;
                if(type === 'warsaw') { this.speed = 10; this.life = 100; }
                if(type === 'bosnian_flag') {
                    this.speed = 0; 
                    this.vx = (Math.random()-0.5)*4; 
                    this.vy = -12 - Math.random()*5; 
                    this.gravity = 0.6;
                    this.life = 120;
                    this.pierce = true;
                    return;
                }

                this.radius = 15;
                if(type === 'sniper_shot') this.radius = 5;
                this.vx = Math.cos(a)*this.speed;
                this.vy = Math.sin(a)*this.speed;
                return;
            }

            let a=target?Math.atan2(target.y-y,target.x-x):Math.random()*6.28;
            if(type==='cevapi'){this.speed=14;this.radius=8;}
            else if(type==='cevapi_hot'){this.speed=14;this.radius=10;} 
            else if(type==='ajvar'){this.speed=8;this.radius=10;}
            else if(type==='rakija'){this.speed=10;this.radius=8;} 
            else if(type==='pyramid'){this.speed=7;this.radius=25;this.life=300;this.pierce=true;}
            this.vx=Math.cos(a)*this.speed; this.vy=Math.sin(a)*this.speed;
        }
        update(){
            if(this.type === 'bosnian_flag') {
                this.vy += this.gravity;
                this.x += this.vx; this.y += this.vy;
                this.rotation = Math.atan2(this.vy, this.vx);
                this.life--;
                if(this.y > player.y + 1000) this.life = 0; // Cull if falls too far
                return;
            }

            this.x+=this.vx;this.y+=this.vy;this.life--;this.rotation+=0.15;
            
            if(this.type === 'boss_missile') {
                 createParticle(this.x, this.y, '#ff003c', 'spark', 0.5);
                 return;
            }
            if(this.type === 'sniper_shot') {
                 createParticle(this.x, this.y, '#ff0000', 'spark', 0.2);
                 return;
            }
            if(this.type === 'warsaw') {
                 createParticle(this.x, this.y, '#fff', 'spark', 0.2);
                 if(this.hitTimer > 0) this.hitTimer--;
                 return;
            }

            if(state.frames%2===0){ 
                if(this.type==='pyramid')createParticle(this.x,this.y,'#2ecc71','spark',0.1); 
                if(this.type==='cevapi')createParticle(this.x,this.y,'#8b4513','smoke',0.2); 
                if(this.type==='cevapi_hot')createParticle(this.x,this.y,'#ff4500','smoke',0.4); 
            }
            if(this.type==='ajvar'||this.type==='rakija'){ this.vx*=0.96;this.vy*=0.96;this.rotation=this.vx*0.2; if(this.life<100 && Math.abs(this.vx)<1)this.explode(); }
        }
        explode(){
            this.life=0; 
            if(this.type==='ajvar'){ 
                addShake(15); 
                let dmg=calcDamage(player.weapons.ajvar.damage); 
                state.enemies.forEach(e=>{if(Math.hypot(e.x-this.x,e.y-this.y)<150)e.takeDamage(dmg.d, dmg.c)}); 
                for(let i=0;i<40;i++)createParticle(this.x,this.y,'#ff4500','fire',2.5); 
                state.zones.push(new Zone(this.x, this.y, 'blast', 20));
            }
            if(this.type==='rakija'){ state.zones.push(new Zone(this.x,this.y,'fire',player.weapons.rakija.duration)); for(let i=0;i<20;i++)createParticle(this.x,this.y,'#00ffff','fire',1.5); }
        }
        draw(cX,cY){
            ctx.save(); ctx.translate(this.x-cX,this.y-cY); 
            ctx.scale(this.scale, this.scale); // Scale for Buff
            ctx.rotate(this.rotation);
            if(this.type === 'bosnian_flag') {
                ctx.rotate(1.57); // Adjust for falling
                ctx.fillStyle = '#002395'; ctx.fillRect(-10, -15, 20, 30); // Blue
                ctx.fillStyle = '#fecb00'; ctx.beginPath(); ctx.moveTo(10, -15); ctx.lineTo(-10, -15); ctx.lineTo(10, 15); ctx.fill(); // Triangle
                ctx.restore();
                return;
            }
            
            if(this.type==='boss_missile'){
                 ctx.fillStyle='#000'; ctx.beginPath(); ctx.arc(0,0,8,0,6.28); ctx.fill();
                 ctx.strokeStyle='#ff003c'; ctx.lineWidth=4; ctx.beginPath(); ctx.arc(0,0,8,0,6.28); ctx.stroke();
            }
            else if(this.type==='sniper_shot'){
                 ctx.fillStyle='#ff0000'; ctx.beginPath(); ctx.arc(0,0,4,0,6.28); ctx.fill();
            }
            else if(this.type==='warsaw'){
                 ctx.fillStyle='#fff'; ctx.fillRect(-6, -4, 12, 4);
                 ctx.fillStyle='#f00'; ctx.fillRect(-6, 0, 12, 4);
            }
            else if(this.type==='cevapi'){ 
                for(let i=-1;i<=1;i++) {
                    ctx.fillStyle='#6d4c41'; ctx.beginPath(); ctx.roundRect(-8, i*5-2, 16, 4, 2); ctx.fill();
                    ctx.fillStyle='#3e2723'; ctx.fillRect(-4, i*5-2, 2, 4); ctx.fillRect(2, i*5-2, 2, 4);
                }
            }
            else if(this.type==='cevapi_hot'){ 
                for(let i=-1;i<=1;i++) {
                    ctx.fillStyle='#800000'; ctx.beginPath(); ctx.roundRect(-8, i*5-2, 16, 4, 2); ctx.fill();
                    ctx.fillStyle='#ff4500'; ctx.fillRect(-4, i*5-2, 2, 4); ctx.fillRect(2, i*5-2, 2, 4);
                }
                ctx.shadowColor = '#f00'; ctx.shadowBlur = 10;
            }
            else if(this.type==='ajvar'){ 
                ctx.fillStyle='#c0392b';ctx.beginPath();ctx.arc(0,0,10,0,6.28);ctx.fill();
                ctx.fillStyle='#f1c40f';ctx.beginPath();ctx.arc(0,-6,6,0,6.28);ctx.fill();
                ctx.fillStyle='white';ctx.font="10px Arial";ctx.textAlign="center";ctx.textBaseline="middle";ctx.fillText("HOT",0,2);
            }
            else if(this.type==='rakija'){ 
                ctx.rotate(-this.rotation); ctx.rotate(Math.sin(state.frames*0.2)*0.5); 
                ctx.fillStyle='rgba(200,240,255,0.6)'; ctx.beginPath(); ctx.rect(-5,-10,10,20); ctx.fill();
                ctx.fillStyle='#002395'; ctx.fillRect(-5, -5, 10, 8); 
                ctx.fillStyle='#aaa'; ctx.fillRect(-3, -14, 6, 4); 
            }
            else if(this.type==='pyramid'){ 
                ctx.fillStyle='#00ff00';
                ctx.beginPath();ctx.moveTo(0,-20);ctx.lineTo(15,15);ctx.lineTo(-15,15);ctx.fill();
                ctx.fillStyle='#fff';ctx.globalCompositeOperation='lighter';
                ctx.beginPath();ctx.arc(0,0,5,0,6.28);ctx.fill();
            }
            ctx.restore();
        }
    }
    class Zone {
        constructor(x,y,type,dur,overrideDamage=0){this.x=x;this.y=y;this.life=dur;this.maxLife=dur;this.radius=90;this.type=type;this.overrideDamage=overrideDamage;if(type==='blast') this.radius=120; if(type==='valk_swing') this.radius=160; if(type==='flame_trail') this.radius=50; if(type==='spike_burst') this.radius=30; if(type==='taco_blaster') this.radius=40; if(type==='tempo_wave') this.radius=10; if(type==='piano_warning' || type==='piano_impact') this.radius=360; if(type==='musical_blast') this.radius=80; if(type==='judgment_beam') this.radius=120; }
        update(){ 
            this.life--; 
            if(this.type==='blast' || this.type==='valk_swing' || this.type==='shield_push' || this.type==='taunt_ring' || this.type==='spike_burst' || this.type==='musical_blast' || this.type==='piano_impact') return this.life<=0;

            // Damage Scaling for Zone Attacks
            let timeMinutes = state.gameTime / 60;
            let damageMultiplier = 1.0;
            if(timeMinutes > 10) {
                damageMultiplier = 1 + (timeMinutes - 10) * 0.05;
            }

            if(this.type==='tempo_wave') {
                this.radius += 15; // Buffed: 3x faster expansion (was 5)
                const maxRad = 800; // Buffed: 2x Larger (was ~300)
                
                if(this.radius > maxRad) return true; // End when too big

                if(Math.hypot(player.x - this.x, player.y - this.y) < this.radius + player.radius && 
                   Math.hypot(player.x - this.x, player.y - this.y) > this.radius - 40) { // Thicker wall (40px)
                     // Inside ring
                     let moving = keys['w']||keys['a']||keys['s']||keys['d']||keys['arrowup']||keys['arrowleft']||keys['arrowdown']||keys['arrowright'];
                     // Must move to avoid damage? No, just contact damage.
                     if(!godMode && player.invincible <= 0) {
                         let scaledDmg = 45 * damageMultiplier; // Buffed damage
                         player.hp -= scaledDmg;
                         spawnDamageText(player.x, player.y-60, Math.floor(scaledDmg), 'player');
                         player.invincible = 20;
                         if(player.hp <= 0) triggerDeath(); // FIX: KILL PLAYER
                     }
                }
                return this.life <= 0;
            }

            if(this.type==='judgment_beam') {
                if(this.life % 5 === 0) { // Damage ticks
                    let d = this.overrideDamage; // {aimAngle, damageVal}
                    let len = 3000;
                    let ex = this.x + Math.cos(d.aimAngle) * len;
                    let ey = this.y + Math.sin(d.aimAngle) * len;
                    
                    if(lineCircleCollide(player.x, player.y, this.x, this.y, ex, ey, this.radius)) {
                         if(!godMode && player.invincible <= 0) {
                             let tickDmg = d.damageVal / 10; // Distribute stored damage
                             if(tickDmg < 50) tickDmg = 50; // Minimum damage
                             
                             player.hp -= tickDmg; 
                             spawnDamageText(player.x, player.y-50, Math.floor(tickDmg), 'player');
                             addShake(15);
                             if(player.hp <= 0) triggerDeath();
                         }
                    }
                    
                    // Kill friendly units instantly
                    state.friendlyUnits.forEach(u => {
                        if(!u.dead && lineCircleCollide(u.x, u.y, this.x, this.y, ex, ey, this.radius)) {
                            u.takeDamage(9999);
                            spawnDamageText(u.x, u.y-50, "JUDGED", 'crit');
                        }
                    });
                }
                return this.life<=0;
            }

            if(this.type==='piano_warning') {
                if(this.life <= 0) {
                    state.zones.push(new Zone(this.x, this.y, 'piano_impact', 20));
                    // Deal damage
                    if(Math.hypot(player.x - this.x, player.y - this.y) < this.radius && !godMode && player.invincible <= 0) {
                         player.hp -= 60; // Piano is heavy flat damage, arguably shouldn't scale OR scale heavily. Scaling it:
                         spawnDamageText(player.x, player.y-60, "CRUSHED", 'player');
                         addShake(30);
                         player.invincible = 30;
                         if(player.hp <= 0) triggerDeath(); // FIX: KILL PLAYER
                    }
                    state.friendlyUnits.forEach(u => {
                        if(!u.dead && Math.hypot(u.x - this.x, u.y - this.y) < this.radius) {
                             u.takeDamage(10);
                        }
                    });
                    // Player version does damage to enemies
                    if(this.overrideDamage === 'player') {
                        let dmg = 100 + state.level;
                         state.enemies.forEach(e => {
                             if(Math.hypot(e.x - this.x, e.y - this.y) < this.radius) {
                                 e.takeDamage(dmg, true, 'piano');
                                 // Knockback
                                 let ang = Math.atan2(e.y - this.y, e.x - this.x);
                                 e.pushX = Math.cos(ang) * 20;
                                 e.pushY = Math.sin(ang) * 20;
                             }
                         });
                    }
                    return true;
                }
                return false;
            }
            if(this.type==='musical_blast') {
                 // Damage to player if spawned by Wraith
                 if(Math.hypot(player.x - this.x, player.y - this.y) < this.radius && !godMode && player.invincible <= 0) {
                     let scaledDmg = 10 * damageMultiplier;
                     player.hp -= scaledDmg;
                     spawnDamageText(player.x, player.y-40, Math.floor(scaledDmg), 'player');
                     player.invincible = 30;
                     if(player.hp <= 0) triggerDeath(); // FIX
                 }
                 return this.life <= 0;
            }

            if(this.type==='taco_blaster') {
                if(this.life < 60) { 
                    if(this.life % 5 === 0) { // Damage ticks
                        let d = this.overrideDamage; // {aimAngle}
                        let len = 3000;
                        let ex = this.x + Math.cos(d.aimAngle) * len;
                        let ey = this.y + Math.sin(d.aimAngle) * len;
                        
                        if(lineCircleCollide(player.x, player.y, this.x, this.y, ex, ey, 40)) {
                             if(!godMode && player.invincible <= 0) {
                                 let scaledDmg = 20 * damageMultiplier;
                                 player.hp -= scaledDmg; 
                                 spawnDamageText(player.x, player.y-50, Math.floor(scaledDmg), 'player');
                                 addShake(5);
                                 if(player.hp <= 0) triggerDeath();
                             }
                        }
                    }
                }
                return this.life<=0;
            }

            if(this.type==='berserk_spin') {
                if(this.life % 10 === 0) { 
                    let dmg = this.overrideDamage;
                    state.enemies.forEach(e => {
                         if(Math.hypot(e.x - this.x, e.y - this.y) < 160) {
                             e.takeDamage(dmg, true, 'berserk');
                             createParticle(e.x, e.y, '#f00', 'blood', 1);
                         }
                    });
                }
                let unit = state.friendlyUnits.find(u => u.isBerserk);
                if(unit) { this.x = unit.x; this.y = unit.y; }
                return this.life<=0;
            }

            if(this.type==='flame_trail') {
                 if(state.frames % 10 === 0) {
                     state.enemies.forEach(e => {
                         if(Math.hypot(e.x-this.x, e.y-this.y) < this.radius) {
                             let baseDmg = player.weapons.burek.damage * 0.25; 
                             let dmg = calcDamage(Math.max(1, baseDmg));
                             e.takeDamage(dmg.d, false, 'flame_trail');
                             createParticle(e.x, e.y, '#ff5e00', 'spark', 0.5);
                         }
                     });
                 }
                 if(state.frames % 5 === 0) createParticle(this.x + (Math.random()-0.5)*40, this.y + (Math.random()-0.5)*40, '#ff5e00', 'fire', 1.0);
            }
            else if(this.type==='fire' && state.frames%10===0) state.enemies.forEach(e=>{if(Math.hypot(e.x-this.x,e.y-this.y)<this.radius){
                let dmg = calcDamage(player.weapons.rakija.damage);
                e.takeDamage(dmg.d, false, 'zone');
                createParticle(e.x,e.y,'#00ffff','fire',0.5);
            }}); 
            return this.life<=0;
        }
        draw(cX,cY){ 
            if(this.type === 'tempo_wave') {
                ctx.save(); ctx.translate(this.x-cX, this.y-cY);
                ctx.strokeStyle = '#00f3ff'; ctx.lineWidth = 15; // Buffed Thickness
                ctx.beginPath(); ctx.arc(0,0, this.radius, 0, 6.28); ctx.stroke();
                ctx.globalAlpha = 0.1; ctx.fillStyle = '#00f3ff'; ctx.fill();
                ctx.restore();
                return;
            }
            if(this.type === 'judgment_beam') {
                let d = this.overrideDamage; 
                ctx.save(); ctx.translate(this.x - cX, this.y - cY); ctx.rotate(d.aimAngle);
                
                let width = this.radius * 2;
                let grad = ctx.createLinearGradient(0, -width/2, 0, width/2);
                grad.addColorStop(0, 'rgba(255,215,0,0)');
                grad.addColorStop(0.2, 'rgba(255,215,0,0.5)');
                grad.addColorStop(0.5, '#fff');
                grad.addColorStop(0.8, 'rgba(255,215,0,0.5)');
                grad.addColorStop(1, 'rgba(255,215,0,0)');

                ctx.fillStyle = grad;
                ctx.fillRect(0, -width/2, 3000, width);
                
                // Intense central core
                ctx.fillStyle = 'rgba(255,255,255,0.8)';
                ctx.fillRect(0, -width/4, 3000, width/2);

                ctx.restore();
                return;
            }
            if(this.type === 'piano_warning') {
                ctx.save(); ctx.translate(this.x-cX, this.y-cY);
                ctx.globalAlpha = 0.5;
                ctx.fillStyle = '#ff003c'; 
                let p = 1 - (this.life/this.maxLife);
                ctx.beginPath(); ctx.arc(0,0, this.radius * p, 0, 6.28); ctx.fill();
                ctx.strokeStyle = '#ff003c'; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.arc(0,0, this.radius, 0, 6.28); ctx.stroke();
                
                // Falling Piano Visual
                let dropH = this.life * 10; 
                ctx.font = (this.radius/2)+"px Arial"; ctx.textAlign="center"; ctx.textBaseline="middle";
                ctx.fillStyle = '#fff';
                ctx.fillText("üéπ", 0, -dropH);
                ctx.restore();
                return;
            }
            if(this.type === 'piano_impact' || this.type === 'musical_blast') {
                ctx.save(); ctx.translate(this.x-cX, this.y-cY);
                ctx.globalCompositeOperation = 'lighter';
                ctx.fillStyle = this.type==='musical_blast'?'#00f3ff':'#ff003c';
                let s = this.type==='musical_blast' ? (1-this.life/20) : 1;
                ctx.beginPath(); ctx.arc(0,0, this.radius * s, 0, 6.28); ctx.fill();
                ctx.restore();
                return;
            }
            if(this.type === 'taco_blaster') {
                let d = this.overrideDamage; // {aimAngle}
                ctx.save(); ctx.translate(this.x - cX, this.y - cY); ctx.rotate(d.aimAngle);
                
                ctx.save();
                let shake = (this.life > 60) ? Math.random()*2 : 0;
                ctx.translate(shake, shake);
                ctx.fillStyle = '#e67e22'; ctx.beginPath(); ctx.arc(0, 0, 30, Math.PI*0.5, Math.PI*1.5); ctx.fill();
                ctx.fillStyle = '#27ae60'; ctx.fillRect(-5, -25, 5, 50); 
                ctx.fillStyle = '#c0392b'; ctx.fillRect(-2, -20, 5, 40); 
                ctx.restore();

                if(this.life > 60) {
                    ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)'; ctx.lineWidth = 2; ctx.setLineDash([10, 10]);
                    ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(3000, 0); ctx.stroke();
                } else {
                    let beamWidth = 60 * Math.sin((60-this.life)/60 * Math.PI); // Pulse
                    ctx.strokeStyle = '#fff'; ctx.lineWidth = beamWidth;
                    ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(3000, 0); ctx.stroke();
                    ctx.strokeStyle = '#2ecc71'; ctx.lineWidth = beamWidth * 1.5;
                    ctx.globalAlpha = 0.5;
                    ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(3000, 0); ctx.stroke();
                    ctx.globalAlpha = 1;
                }
                ctx.restore();
                return;
            }
            if(this.type === 'spike_burst') {
                ctx.save(); ctx.translate(this.x-cX, this.y-cY);
                let p = this.life/this.maxLife;
                ctx.scale(1.5, 1.5); 
                let grad = ctx.createLinearGradient(0, 10, 0, -50);
                grad.addColorStop(0, '#555');
                grad.addColorStop(0.5, '#aaa');
                grad.addColorStop(1, '#ff003c');
                ctx.fillStyle = grad;
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(0, -50 * p); ctx.lineTo(8, 0); ctx.lineTo(-8, 0);
                ctx.moveTo(-15, -40 * p); ctx.lineTo(-5, 5); ctx.lineTo(-25, 5);
                ctx.moveTo(15, -40 * p); ctx.lineTo(25, 5); ctx.lineTo(5, 5);
                ctx.fill();
                ctx.stroke();
                ctx.restore();
                return;
            }
            if(this.type === 'flame_trail') {
                ctx.save(); ctx.translate(this.x-cX, this.y-cY);
                let p = this.life/this.maxLife;
                ctx.globalAlpha = p;
                let g = ctx.createRadialGradient(0,0,10,0,0,this.radius);
                g.addColorStop(0, '#ffcc00'); g.addColorStop(1, 'rgba(255,0,0,0)');
                ctx.fillStyle = g;
                ctx.beginPath(); ctx.arc(0,0,this.radius,0,6.28); ctx.fill();
                ctx.restore();
                return;
            }
            if(this.type === 'shield_push') {
                ctx.save(); ctx.translate(this.x-cX, this.y-cY);
                let p = 1 - (this.life/this.maxLife);
                ctx.strokeStyle = `rgba(255, 255, 255, ${1-p})`;
                ctx.lineWidth = 10;
                ctx.beginPath(); ctx.arc(0,0, player.weapons.harmonika.range * 1.5 * p, 0, 6.28); ctx.stroke();
                ctx.restore();
                return;
            }
            if(this.type === 'taunt_ring') {
                 return;
            }
            if(this.type === 'valk_swing' || this.type === 'berserk_spin') {
                 ctx.save(); 
                 ctx.translate(this.x-cX, this.y-cY);
                 
                 let progress = 1 - (this.life / this.maxLife); 
                 if(this.type === 'berserk_spin') progress = (state.frames * 0.5) % 6.28; 
                 else progress = progress * Math.PI * 2;
                 
                 let angle = progress;
                 if(this.type === 'valk_swing') {
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius, angle - 1, angle, false);
                    ctx.lineWidth = 40;
                    ctx.strokeStyle = `rgba(255, 255, 255, ${0.5 * (this.life/this.maxLife)})`;
                    ctx.stroke();
                 }

                 ctx.rotate(angle);
                 ctx.translate(20, 0); 
                 
                 let grad = ctx.createLinearGradient(0,0, 100, 0);
                 grad.addColorStop(0, '#aaa'); grad.addColorStop(1, '#fff');
                 ctx.fillStyle = grad;
                 ctx.beginPath(); ctx.moveTo(0, -5); ctx.lineTo(120, 0); ctx.lineTo(0, 5); ctx.fill();
                 ctx.fillStyle = '#444'; ctx.fillRect(-5, -15, 10, 30);
                 ctx.fillStyle = '#654321'; ctx.fillRect(-25, -4, 20, 8);

                 ctx.restore();
                 return;
            }
            if(this.type === 'blast') {
                 ctx.save(); ctx.translate(this.x-cX, this.y-cY);
                 ctx.globalCompositeOperation = 'lighter';
                 ctx.fillStyle = `rgba(255, 100, 0, ${this.life/20})`;
                 ctx.beginPath(); ctx.arc(0,0,this.radius*(1-this.life/20), 0, 6.28); ctx.fill();
                 ctx.restore();
                 return;
            }
            ctx.save();ctx.translate(this.x-cX,this.y-cY); let p=1+Math.sin(state.frames*0.1)*0.1; ctx.scale(p,p); 
            let g=ctx.createRadialGradient(0,0,10,0,0,this.radius);
            g.addColorStop(0,'rgba(0,255,255,0.4)');g.addColorStop(1,'rgba(0,50,255,0)');
            ctx.globalCompositeOperation='lighter';ctx.fillStyle=g;ctx.beginPath();ctx.arc(0,0,this.radius,0,6.28);ctx.fill();ctx.restore();
        }
    }
    
    class Enemy {
        constructor(overrideType=null, x=null, y=null){
            if(overrideType === 'BOSS' || overrideType === 'MINI_BOSS' || overrideType === 'BRAXTON' || overrideType === 'POLYRHYTHM' || overrideType === 'TEZINA') {
                 this.type = overrideType;
                 let a=Math.random()*6.28, d=(Math.max(W,H)/2)+200; 
                 if(x!==null && y!==null) { this.x=x; this.y=y; }
                 else { this.x=player.x+Math.cos(a)*d; this.y=player.y+Math.sin(a)*d; }
            } else {
                 if(x !== null && y !== null) {
                     this.x = x; this.y = y;
                 } else {
                     let a=Math.random()*6.28, d=(Math.max(W,H)/2)+150; 
                     this.x=player.x+Math.cos(a)*d; this.y=player.y+Math.sin(a)*d;
                 }
                 this.type = overrideType || 'promaja';
            }
            
            if (this.type === 'BOSS' || this.type === 'WARLORD_CLONE') {
                this.maxHp = 5000;
                this.hp = 5000;
            } else if (this.type === 'BRAXTON') {
                this.maxHp = 15000;
                this.hp = 15000;
            } else if (this.type === 'POLYRHYTHM') {
                this.maxHp = 12000; 
                this.hp = 12000;
            } else if (this.type === 'TEZINA') {
                this.maxHp = 25000; // Fixed 25k HP
                this.hp = this.maxHp;
            } else {
                let baseHp = 40;
                if(this.type==='promaja') baseHp = 25 + state.level*1; 
                else if(this.type==='yugo') baseHp = 180 + state.level*8;
                else if(this.type==='hornet') baseHp = 20 + state.level*1;
                else if(this.type==='snajper') baseHp = 10 + state.level*1; 
                else if(this.type==='medic') baseHp = 300 + state.level*5; 
                else if(this.type==='lovac') baseHp = 500 + state.level*10; 
                else if(this.type==='NOLAN') baseHp = 600; 
                else if(this.type==='MINI_BOSS') baseHp = 800 + state.level*100;
                else if(this.type==='RHYTHM_WRAITH') baseHp = 50; // Increased to ensure they survive spawn

                const minutes = state.gameTime / 60;
                
                if (minutes < 5) {
                    this.maxHp = baseHp + (minutes * 8);
                } else if (minutes < 10) {
                    let hardBase = baseHp * 1.5;
                    this.maxHp = hardBase * (1 + minutes * 0.25);
                } else {
                    this.maxHp = baseHp * (1 + Math.pow(minutes, 0.9) * 0.3);
                }
                this.hp = this.maxHp;
            }
            
            this.baseSpeed = 2;
            this.radius = 20;
            this.frozen = 0;
            this.hitFlash = 0;
            this.pushX = 0; this.pushY = 0;
            this.burnTimer = 0; 
            this.burekHitTimer = 0;
            this.percentBurnLeft = 0; 
            
            // Death Animation State
            this.dying = false;
            this.deathTimer = 0;

            if(this.type==='BOSS' || this.type==='WARLORD_CLONE') {
                this.baseSpeed=2.5; this.radius=60; 
                this.attackTimer = 150; this.damageCooldown = 0;
            } 
            else if(this.type==='BRAXTON') {
                this.baseSpeed=1.8; this.radius=80;
                this.attackTimer = 300; 
                this.summonTimer = 600; 
                this.damageCooldown = 0;
            }
            else if(this.type==='POLYRHYTHM') {
                this.baseSpeed=4.0; this.radius=50; // Fast
                this.attackTimer = 180;
                this.shieldTimer = 0;
                this.hasHealed = false;
                this.phase2 = false;
                this.abilityCycle = 0;
            }
            else if(this.type==='TEZINA') {
                this.baseSpeed=2.2; this.radius=70;
                this.attackTimer = 180; 
                this.damageCooldown = 0;
                this.storedDamage = 0;
                this.judgmentPhase = 0; 
                this.judgmentThresholds = [0.7, 0.4, 0.1];
                this.isAbsorbing = false;
                this.absorbTimer = 0;
                this.isFiring = false;
                this.fireTimer = 0;
                this.isCharging = false;
                this.chargeTimer = 0;
                this.isDashing = false;
                this.dashTimer = 0;
            }
            else if(this.type==='MINI_BOSS') {
                this.baseSpeed=2.2; this.radius=45;
                this.attackTimer = 200; this.damageCooldown = 0;
            }
            else if(this.type==='promaja'){this.baseSpeed=1.8+Math.random();this.radius=22;} 
            else if(this.type==='yugo'){this.baseSpeed=1.4;this.radius=35;this.angle=0;} 
            else if(this.type==='hornet'){this.baseSpeed=4.2;this.radius=15;}
            else if(this.type==='medic'){this.baseSpeed=1.5;this.radius=25;}
            else if(this.type==='lovac'){
                this.baseSpeed=3.8; this.radius=25; 
                this.isPhased = false; 
                this.phaseCD = 0; 
                this.phaseTimer = 0;
                this.attackAnim = 0;
            }
            else if(this.type==='NOLAN'){this.baseSpeed=5.0; this.radius=20; this.attackTimer = 120;}
            else if(this.type==='snajper'){
                this.baseSpeed=1.5; this.radius=15; 
                this.state = 'move'; this.snajperTimer = 0;
                this.targetX = 0; this.targetY = 0;
            }
            else if(this.type==='RHYTHM_WRAITH'){ this.baseSpeed=3.0; this.radius=15; }

            this.speed = this.baseSpeed;
        }
        update(){
            if(this.dying) {
                this.deathTimer--;
                if(this.deathTimer % 5 === 0) createParticle(this.x, this.y, '#fff', 'spark', 2);
                if(this.deathTimer <= 0) {
                    this.dead = true; // Actually remove from game
                    // Drop loot
                    state.tezinaActive = false;
                    state.crates.push(new Crate(this.x, this.y, 'tezina_reward')); 
                }
                return; // Stop logic
            }
            if(this.dead) { 
                if(this.type === 'BOSS' || this.type === 'BRAXTON' || this.type === 'POLYRHYTHM' || this.type === 'TEZINA') {
                    document.getElementById('boss-hud').style.display = 'none';
                }
                return;
            } 

            // GLOBAL UPDATES
            if(this.hitFlash > 0) this.hitFlash--;
            this.pushX*=0.9; this.pushY*=0.9;

            if(this.type === 'BOSS' || this.type === 'BRAXTON' || this.type === 'POLYRHYTHM' || this.type === 'TEZINA') {
                document.getElementById('boss-hud').style.display = 'flex';
                document.getElementById('boss-bar-fill').style.width = (this.hp/this.maxHp*100)+'%';
            }
            if(this.type === 'BOSS') document.getElementById('boss-name').innerText = "TURBO FOLK WARLORD";
            if(this.type === 'BRAXTON') document.getElementById('boss-name').innerText = "BRAXTON-INITE";
            if(this.type === 'POLYRHYTHM') document.getElementById('boss-name').innerText = "THE POLYRHYTHM";
            if(this.type === 'TEZINA') document.getElementById('boss-name').innerText = "TE≈ΩINA PRESUDE";
            
            if(this.burekHitTimer > 0) this.burekHitTimer--;

            if(this.burnTimer > 0) {
                this.burnTimer--;
                if(state.frames % 15 === 0) {
                    this.takeDamage(5, false, 'burn'); 
                    createParticle(this.x, this.y, '#ff5e00', 'fire', 0.5);
                }
            }

            if(this.percentBurnLeft > 0) {
                 if(state.frames % 10 === 0) {
                     this.percentBurnLeft--;
                     let p = (this.type.includes('BOSS')||this.type==='BRAXTON'||this.type==='POLYRHYTHM'||this.type==='TEZINA') ? 0.001 : 0.01;
                     let dmg = Math.max(1, this.maxHp * p);
                     this.takeDamage(dmg, false, 'burn_percent');
                     createParticle(this.x, this.y, '#ff0000', 'smoke', 0.5);
                 }
            }

            // --- BOSS BEHAVIORS ---
            if((this.type === 'BOSS' || this.type === 'MINI_BOSS' || this.type === 'WARLORD_CLONE')) {
                if(this.damageCooldown > 0) this.damageCooldown--;
                this.attackTimer--;
                if(this.attackTimer === 30) {
                     spawnDamageText(this.x, this.y - 80, "!!!", 'normal');
                     createParticle(this.x, this.y, '#f00', 'plasma', 5);
                }
                if(this.attackTimer <= 0) {
                    this.attackTimer = this.type.includes('BOSS') ? 150 : 200; 
                    state.projectiles.push(new Projectile(this.x, this.y, player, 'boss_missile'));
                }
            }

            if(this.type === 'BRAXTON') {
                let dist = Math.hypot(player.x - this.x, player.y - this.y);
                if(dist > 900) {
                    let angle = Math.random() * 6.28;
                    this.x = player.x + Math.cos(angle) * 400;
                    this.y = player.y + Math.sin(angle) * 400;
                    spawnDamageText(this.x, this.y-80, "TOO FAR!", 'normal');
                }

                this.summonTimer--;
                if(this.summonTimer <= 0) {
                    this.summonTimer = 600; 
                    state.enemies.push(new Enemy('NOLAN', this.x + 50, this.y));
                    spawnDamageText(this.x, this.y-100, "SUMMON!", 'normal');
                }

                this.attackTimer--;
                if(this.attackTimer <= 0) {
                    this.attackTimer = 300; 
                    let randAng = Math.random() * 6.28;
                    let tx = player.x + Math.cos(randAng) * 250;
                    let ty = player.y + Math.sin(randAng) * 250;
                    let aimAng = Math.atan2(player.y - ty, player.x - tx);
                    state.zones.push(new Zone(tx, ty, 'taco_blaster', 120, {aimAngle: aimAng}));
                }

                if(this.damageCooldown > 0) this.damageCooldown--;
            }

            if(this.type === 'POLYRHYTHM') {
                // Shield Logic
                if(this.shieldTimer > 0) this.shieldTimer--;

                // Heal Logic
                if(!this.hasHealed && this.hp < (this.maxHp * 0.6)) {
                    this.hasHealed = true;
                    this.hp = Math.min(this.maxHp, this.hp + (this.maxHp * 0.7));
                    this.shieldTimer = 1800; // 30 seconds
                    spawnDamageText(this.x, this.y - 100, "RHYTHMIC HEAL", 'crit');
                    createParticle(this.x, this.y, '#00f3ff', 'plasma', 10);
                }

                // Phase 2 Logic
                if(this.hp < (this.maxHp * 0.5) && !this.phase2) {
                    this.phase2 = true;
                    this.shieldTimer = 2700; // Gain shield again for 45s
                    spawnDamageText(this.x, this.y - 100, "SHIELD RESTORED", 'crit');
                    const cap = document.getElementById('boss-caption');
                    cap.innerText = "I FEEL THE MUSIC BEATING IN MY HEART!";
                    cap.style.opacity = '1';
                    setTimeout(() => cap.style.opacity = '0', 4000);
                }

                // Spawn Wraiths in Phase 2 - FIX: Increased spawn distance, ensured it runs
                if(this.phase2 && state.frames % 180 === 0) {
                    let randAng = Math.random() * 6.28;
                    let dist = 300; // Keep them away from boss collision
                    state.enemies.push(new Enemy('RHYTHM_WRAITH', this.x + Math.cos(randAng)*dist, this.y + Math.sin(randAng)*dist));
                }

                // Abilities
                this.attackTimer--;
                if(this.attackTimer <= 0) {
                    this.attackTimer = 180;
                    this.abilityCycle = (this.abilityCycle + 1) % 2;

                    if(this.abilityCycle === 0) {
                        // Tempo Wave - BUFFED in Zone class
                        state.zones.push(new Zone(this.x, this.y, 'tempo_wave', 240));
                        spawnDamageText(this.x, this.y - 80, "TEMPO WAVE!", 'normal');
                    } else {
                        // Piano Smash
                        state.zones.push(new Zone(player.x, player.y, 'piano_warning', 150)); // 2.5s warning
                    }
                }
                
                // Dodging Movement
                if(state.frames % 60 === 0) {
                    let randA = Math.random() * 6.28;
                    this.pushX += Math.cos(randA) * 15;
                    this.pushY += Math.sin(randA) * 15;
                }
                
                if(this.damageCooldown > 0) this.damageCooldown--;
            }

            if(this.type === 'TEZINA') {
                if(this.damageCooldown > 0) this.damageCooldown--;

                // JUDGMENT LOGIC
                if(this.judgmentThresholds.length > 0) {
                    let nextThresh = this.judgmentThresholds[0];
                    if(this.hp / this.maxHp <= nextThresh && !this.isAbsorbing && !this.isFiring) {
                        this.judgmentThresholds.shift();
                        this.isAbsorbing = true;
                        this.absorbTimer = 300; // 5 seconds
                        this.storedDamage = 0;
                        spawnDamageText(this.x, this.y-100, "JUDGMENT!", 'crit');
                        const cap = document.getElementById('boss-caption');
                        cap.innerText = "JUDGMENT HAS BEGUN";
                        cap.style.opacity = '1';
                        setTimeout(() => cap.style.opacity = '0', 3000);
                        createParticle(this.x, this.y, '#fff', 'plasma', 20);
                    }
                }

                if(this.isAbsorbing) {
                    this.absorbTimer--;
                    if(this.absorbTimer <= 0) {
                        this.isAbsorbing = false;
                        this.isFiring = true;
                        this.fireTimer = 180; // 3 seconds beam
                        let aimAng = Math.atan2(player.y - this.y, player.x - this.x);
                        // Damage val min 500, max is stored
                        let dmg = Math.max(500, this.storedDamage);
                        state.zones.push(new Zone(this.x, this.y, 'judgment_beam', 180, {aimAngle: aimAng, damageVal: dmg}));
                        spawnDamageText(this.x, this.y-100, "VERDICT: GUILTY", 'crit');
                    }
                    return; // IMMOBILE
                }

                if(this.isFiring) {
                    this.fireTimer--;
                    if(this.fireTimer <= 0) this.isFiring = false;
                    return; // IMMOBILE
                }

                // SWORD OF VERDICT LOGIC
                if(!this.isCharging && !this.isDashing && Math.random() < 0.005) {
                    this.isCharging = true;
                    this.chargeTimer = 90; // 1.5s
                    this.chargeTarget = {x: player.x, y: player.y};
                    spawnDamageText(this.x, this.y-80, "VERDICT...", 'normal');
                }

                if(this.isCharging) {
                    this.chargeTimer--;
                    if(this.chargeTimer <= 0) {
                        this.isCharging = false;
                        this.isDashing = true;
                        this.dashTimer = 60; // 1s dash
                        let ang = Math.atan2(this.chargeTarget.y - this.y, this.chargeTarget.x - this.x);
                        this.dashVel = {x: Math.cos(ang)*15, y: Math.sin(ang)*15}; // Fast
                        // White flash
                        state.flashAlpha = 0.5;
                    }
                    return; // IMMOBILE
                }

                if(this.isDashing) {
                    this.dashTimer--;
                    this.x += this.dashVel.x;
                    this.y += this.dashVel.y;
                    if(state.frames % 5 === 0) state.zones.push(new Zone(this.x, this.y, 'valk_swing', 10, 150)); // Sword swings
                    if(this.dashTimer <= 0) this.isDashing = false;
                    return;
                }

                // SUMMON WARLORD
                let warlords = state.enemies.filter(e => e.type === 'WARLORD_CLONE').length;
                if(warlords === 0 && Math.random() < 0.002) {
                     state.enemies.push(new Enemy('WARLORD_CLONE', this.x + 100, this.y));
                     spawnDamageText(this.x, this.y-80, "WITNESS SUMMONED", 'normal');
                }
                
                // Speed debuff if Warlord exists
                if(warlords > 0) this.speed = this.baseSpeed * 0.7;
                else this.speed = this.baseSpeed;

            }

            if(this.type === 'medic') {
                if(state.frames % 60 === 0) { 
                    let healCount = 0;
                    state.enemies.forEach(e => {
                        if(e !== this && e.type !== 'medic' && e.hp < e.maxHp && Math.hypot(e.x - this.x, e.y - this.y) < 200) {
                            e.hp = Math.min(e.maxHp, e.hp + 50);
                            createParticle(e.x, e.y, '#00ff41', 'heal', 2);
                            let ang = Math.atan2(e.y - this.y, e.x - this.x);
                            state.beams.push(new Beam(this.x, this.y, ang, 'heal')); // VISUAL BEAM
                            healCount++;
                        }
                    });
                    if(healCount > 0) spawnDamageText(this.x, this.y-40, "HEAL", 'normal');
                }
            }

            if(this.type === 'lovac') {
                if(this.attackAnim > 0) this.attackAnim--;

                // Phase Logic
                if(this.phaseCD > 0) this.phaseCD--;
                if(this.isPhased) {
                    this.phaseTimer--;
                    if(this.phaseTimer <= 0) {
                        this.isPhased = false;
                        spawnDamageText(this.x, this.y-40, "VISIBLE", 'normal');
                    }
                } else {
                    let d = Math.hypot(player.x - this.x, player.y - this.y);
                    if(d < 250 && this.phaseCD <= 0) {
                        this.isPhased = true;
                        this.phaseTimer = 120; // 2 seconds
                        this.phaseCD = 420; // 7 seconds
                        spawnDamageText(this.x, this.y-40, "PHASED", 'normal');
                        createParticle(this.x, this.y, '#fff', 'smoke', 5);
                    }
                }
            }

            if(this.frozen > 0 && this.type !== 'TEZINA') { // Te≈æina immune to freeze
                this.frozen--; 
                if(state.frames%20===0) createParticle(this.x,this.y,'#0ff','spark');
                return;
            }
            
            if(this.type === 'NOLAN') {
                this.attackTimer--;
                if(this.attackTimer <= 0) {
                    this.attackTimer = 120; 
                    state.projectiles.push(new Projectile(this.x, this.y, player, 'warsaw'));
                }
            }

            if(this.type === 'snajper') {
                let dist = Math.hypot(player.x - this.x, player.y - this.y);
                if(this.state === 'move') {
                    if(dist < 400) { this.state = 'charge'; this.snajperTimer = 60; } 
                    else {
                        let ang = Math.atan2(player.y - this.y, player.x - this.x);
                        this.x += Math.cos(ang) * this.speed + this.pushX;
                        this.y += Math.sin(ang) * this.speed + this.pushY;
                    }
                } else if(this.state === 'charge') {
                    this.snajperTimer--;
                    if(this.snajperTimer <= 0) { this.state = 'fire'; }
                } else if(this.state === 'fire') {
                    state.projectiles.push(new Projectile(this.x, this.y, player, 'sniper_shot'));
                    this.state = 'cooldown'; this.snajperTimer = 120;
                } else if(this.state === 'cooldown') {
                    this.snajperTimer--;
                    let ang = Math.atan2(player.y - this.y, player.x - this.x);
                    this.x -= Math.cos(ang) * 1.0; this.y -= Math.sin(ang) * 1.0;
                    if(this.snajperTimer <= 0) this.state = 'move';
                }
                return; 
            }

            let targetX = player.x, targetY = player.y;
            let taunter = state.friendlyUnits.find(u => u.taunting && !u.dead);
            if(taunter) { targetX = taunter.x; targetY = taunter.y; } 
            else {
                let closestFriendly = null; let minFD = 999;
                state.friendlyUnits.forEach(u => {
                    if(!u.dead) {
                        if(u.type === 'mage' && u.invisibleTimer > 0) return;
                        let d = Math.hypot(u.x - this.x, u.y - this.y);
                        if(d < minFD) { minFD = d; closestFriendly = u; }
                    }
                });
                if(closestFriendly) {
                    let dPlayer = Math.hypot(player.x - this.x, player.y - this.y);
                    if(minFD < dPlayer && dPlayer > 120) { targetX = closestFriendly.x; targetY = closestFriendly.y; }
                    if(minFD < closestFriendly.radius + this.radius) {
                        let ang = Math.atan2(this.y - closestFriendly.y, this.x - closestFriendly.x);
                        this.x = closestFriendly.x + Math.cos(ang) * (closestFriendly.radius + this.radius);
                        this.y = closestFriendly.y + Math.sin(ang) * (closestFriendly.radius + this.radius);
                    }
                }
            }

            let dx=targetX-this.x, dy=targetY-this.y, dist=Math.sqrt(dx*dx+dy*dy); this.angle=Math.atan2(dy,dx);
            let px=0,py=0; 
            if(this.type !== 'BOSS' && this.type !== 'MINI_BOSS' && this.type !== 'BRAXTON' && this.type !== 'POLYRHYTHM' && this.type !== 'TEZINA') {
                state.enemies.forEach(o=>{if(o!==this){let ox=this.x-o.x,oy=this.y-o.y,od=Math.sqrt(ox*ox+oy*oy);if(od<this.radius+o.radius){px+=ox/od;py+=oy/od;}}});
            }
            this.x+=(Math.cos(this.angle)*this.speed+px*0.5)+this.pushX; this.y+=(Math.sin(this.angle)*this.speed+py*0.5)+this.pushY; 
            
            if(this.type==='yugo'&&state.frames%5===0)createParticle(this.x-Math.cos(this.angle)*35,this.y-Math.sin(this.angle)*35,'#333','smoke', 0.5);
        }
        
        takeDamage(a, crit, source){
            if(this.isPhased) return; // IMMUNE WHEN PHASED

            if(this.type === 'TEZINA') {
                if(this.isAbsorbing) {
                    this.storedDamage += a;
                    spawnDamageText(this.x, this.y-50, "ABSORBED", false);
                    return;
                }
                if(this.dying) return; // Already dying
            }

            if(this.type === 'BOSS' || this.type === 'MINI_BOSS' || this.type === 'BRAXTON' || this.type === 'POLYRHYTHM' || this.type === 'TEZINA' || this.type === 'WARLORD_CLONE') {
                if(this.damageCooldown > 0 && source !== 'burn_percent') return; 
                if(source !== 'burn_percent') this.damageCooldown = 5; 
                
                // Polyrhythm Shield
                if(this.type === 'POLYRHYTHM' && this.shieldTimer > 0) {
                    a *= 0.15; // Reduce by 85%
                    spawnDamageText(this.x, this.y-50, "SHIELDED", false);
                }
            }
            this.hp-=a; 
            if(source !== 'burn_percent') this.hitFlash=5; 
            spawnDamageText(this.x,this.y-30,a,crit); 
            let c='#880000';
            if(this.type==='yugo') c='#000';
            if(this.type==='hornet') c='#bfff00';
            if(this.type==='BOSS' || this.type==='MINI_BOSS') c='#ff00ff';
            if(this.type==='BRAXTON') c='#2ecc71';
            if(this.type==='snajper') c='#ff0000';
            if(this.type==='medic') c='#fff';
            if(this.type==='lovac') c='#000';
            if(this.type==='NOLAN') c='#fff';
            if(this.type==='POLYRHYTHM') c='#00f3ff';
            if(this.type==='TEZINA') c='#ffd700';
            if(source !== 'burn_percent') for(let i=0;i<3;i++)createParticle(this.x,this.y,c,'spark');
            
            if(this.hp<=0){ 
                if(this.type === 'TEZINA') {
                    // Trigger Dying Animation
                    this.dying = true;
                    this.deathTimer = 120; // 2 seconds of animation
                    document.getElementById('boss-hud').style.display='none';
                    spawnDamageText(this.x, this.y-100, "JUDGMENT... PASSED?", 'crit');
                    return; // Wait for animation
                }

                this.dead=true; if(this.type !== 'WARLORD_CLONE') state.score++; 
                if(this.type==='BOSS' || this.type==='BRAXTON' || this.type==='POLYRHYTHM'){
                     state.bossActive = false;
                     document.getElementById('boss-hud').style.display='none';
                     addShake(50); state.flashAlpha=1;
                     spawnDamageText(this.x, this.y-100, "BOSS DEFEATED", 'crit');
                     
                     if(this.type === 'BRAXTON') { 
                         state.braxtonActive = false;
                         state.crates.push(new Crate(this.x, this.y));
                     } else if (this.type === 'POLYRHYTHM') {
                         state.polyrhythmActive = false;
                         state.crates.push(new Crate(this.x, this.y, 'musical')); 
                     } else {
                         for(let i=0; i<50; i++) state.gems.push(new Gem(this.x + (Math.random()-0.5)*200, this.y + (Math.random()-0.5)*200, 150));
                     }
                } 
                else if(this.type==='MINI_BOSS') {
                     spawnDamageText(this.x, this.y-80, "MINI BOSS DOWN", 'crit');
                     for(let i=0; i<10; i++) state.gems.push(new Gem(this.x + (Math.random()-0.5)*100, this.y + (Math.random()-0.5)*100, 100));
                }
                else if(this.type==='RHYTHM_WRAITH') {
                    state.zones.push(new Zone(this.x, this.y, 'musical_blast', 20));
                    createParticle(this.x, this.y, '#00f3ff', 'spark', 5);
                }
                else if(this.type==='WARLORD_CLONE') {
                    spawnDamageText(this.x, this.y-80, "WITNESS SILENCED", 'normal');
                }
                else { state.gems.push(new Gem(this.x,this.y)); }
                for(let i=0;i<8;i++)createParticle(this.x,this.y,c,'blood',1.5); 
                if(this.type==='yugo' || this.type==='BOSS'){addShake(5);for(let i=0;i<15;i++)createParticle(this.x,this.y,'#f39c12','fire',2);} 
            }
        }
        draw(cX,cY){
            if(this.dead) return; 
            ctx.save(); ctx.translate(this.x-cX,this.y-cY);
            
            if(this.dying) {
                // Death Animation
                let shake = Math.random() * 10;
                ctx.translate(shake - 5, shake - 5);
                let scale = this.deathTimer / 120; // shrink
                ctx.scale(scale, scale);
                ctx.globalCompositeOperation = 'lighter';
                ctx.fillStyle = '#fff';
                ctx.beginPath(); ctx.arc(0,0, 50, 0, 6.28); ctx.fill();
                ctx.restore();
                return;
            }

            if(this.hitFlash>0){ 
                ctx.globalCompositeOperation='lighter'; ctx.fillStyle='#fff';
                ctx.beginPath();ctx.arc(0,0,this.radius,0,6.28);ctx.fill();
            } else {
                if(this.type==='BOSS' || this.type==='MINI_BOSS' || this.type==='WARLORD_CLONE'){
                    ctx.rotate(state.frames*0.02); let scale = this.type==='MINI_BOSS' ? 0.6 : 1;
                    ctx.scale(scale, scale);
                    ctx.strokeStyle= this.type==='WARLORD_CLONE' ? '#777' : '#ff003c'; ctx.lineWidth=4;
                    ctx.beginPath(); ctx.moveTo(-30,-30); ctx.lineTo(30,-30); ctx.lineTo(0,30); ctx.closePath(); ctx.stroke();
                    ctx.fillStyle='#300'; ctx.fill();
                    ctx.fillStyle= this.type==='WARLORD_CLONE' ? '#777' : '#f00'; ctx.beginPath(); ctx.arc(0,0,10,0,6.28); ctx.fill();
                }
                else if(this.type==='BRAXTON'){
                    ctx.fillStyle = '#ff5e00'; ctx.beginPath(); ctx.moveTo(0, -20); ctx.lineTo(40, 40); ctx.lineTo(-40, 40); ctx.fill();
                    ctx.fillStyle = '#2ecc71'; ctx.fillRect(-20, 0, 40, 5);
                    ctx.fillStyle = '#fff'; ctx.fillRect(-30, 20, 60, 5);
                    ctx.fillStyle = '#e67e22'; ctx.beginPath(); ctx.ellipse(0, -20, 60, 15, 0, 0, 6.28); ctx.fill(); 
                    ctx.beginPath(); ctx.ellipse(0, -35, 20, 20, 0, 0, 6.28); ctx.fill(); 
                    ctx.strokeStyle = '#f1c40f'; ctx.lineWidth=3; ctx.stroke();
                }
                else if(this.type==='POLYRHYTHM'){
                    let s = 1 + Math.sin(state.frames * 0.2) * 0.1;
                    ctx.scale(s, s);
                    
                    // Core
                    ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(0,0,25,0,6.28); ctx.fill();
                    
                    // Equalizer bars rotating
                    ctx.strokeStyle = '#00f3ff'; ctx.lineWidth = 4;
                    for(let i=0; i<8; i++) {
                         let h = 10 + Math.sin(state.frames*0.5 + i)*15;
                         ctx.save(); ctx.rotate((state.frames*0.05) + (i * (Math.PI/4)));
                         ctx.beginPath(); ctx.moveTo(35, -5); ctx.lineTo(35, 5); ctx.stroke();
                         ctx.fillStyle = '#00f3ff'; ctx.fillRect(40, -h/2, 5, h);
                         ctx.restore();
                    }
                    
                    if(this.shieldTimer > 0) {
                        ctx.strokeStyle = 'rgba(0, 243, 255, 0.6)'; ctx.lineWidth = 5;
                        ctx.beginPath(); ctx.arc(0,0, 55, 0, 6.28); ctx.stroke();
                    }
                }
                else if(this.type === 'TEZINA') {
                    // Judgment Model
                    let bob = Math.sin(state.frames * 0.05) * 5;
                    ctx.translate(0, bob);
                    
                    if(this.isAbsorbing) {
                        ctx.strokeStyle = '#fff'; ctx.lineWidth = 3;
                        ctx.beginPath(); ctx.arc(0,0, 80 + Math.sin(state.frames*0.2)*10, 0, 6.28); ctx.stroke();
                        ctx.fillStyle = 'rgba(255,255,255,0.2)'; ctx.fill();
                    }
                    
                    // Cloak
                    ctx.fillStyle = '#1a1a1a';
                    ctx.beginPath(); ctx.moveTo(0, -50); ctx.lineTo(40, 60); ctx.lineTo(-40, 60); ctx.fill();
                    
                    // Hood
                    ctx.fillStyle = '#333';
                    ctx.beginPath(); ctx.arc(0, -40, 20, 3.14, 0); ctx.lineTo(20, -20); ctx.lineTo(-20, -20); ctx.fill();
                    
                    // Void Face
                    ctx.fillStyle = '#000';
                    ctx.beginPath(); ctx.arc(0, -35, 12, 0, 6.28); ctx.fill();
                    // Glowing eyes
                    ctx.fillStyle = '#ffd700'; ctx.shadowColor='#ffd700'; ctx.shadowBlur=10;
                    ctx.fillRect(-6, -38, 4, 4); ctx.fillRect(2, -38, 4, 4);
                    ctx.shadowBlur=0;
                    
                    // Scales (Left Hand)
                    ctx.save(); ctx.translate(-50, 0); 
                    ctx.fillStyle = '#b8860b'; ctx.fillRect(-2, -30, 4, 30); // pole
                    ctx.fillRect(-20, -30, 40, 4); // beam
                    ctx.beginPath(); ctx.arc(-20, 0, 10, 0, 3.14); ctx.stroke(); // pans
                    ctx.beginPath(); ctx.arc(20, 0, 10, 0, 3.14); ctx.stroke();
                    ctx.restore();
                    
                    // Sword (Right Hand) - Drawn if charging/dashing
                    if(this.isCharging || this.isDashing) {
                        ctx.save(); ctx.translate(40, -10); ctx.rotate(-0.5);
                        ctx.fillStyle = '#fff'; ctx.shadowColor='#fff'; ctx.shadowBlur=15;
                        ctx.fillRect(-5, -60, 10, 70); 
                        ctx.shadowBlur=0;
                        ctx.fillStyle='#b8860b'; ctx.fillRect(-15, 0, 30, 5);
                        ctx.restore();
                    } else {
                        // Resting arm
                         ctx.fillStyle = '#1a1a1a'; ctx.fillRect(20, -20, 10, 40);
                    }
                }
                else if(this.type==='NOLAN'){
                    ctx.beginPath(); ctx.arc(0, 0, 20, 0, 6.28); ctx.clip();
                    ctx.fillStyle = '#fff'; ctx.fillRect(-20, -20, 40, 20);
                    ctx.fillStyle = '#f00'; ctx.fillRect(-20, 0, 40, 20);
                    ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(-8, -5, 3, 0, 6.28); ctx.arc(8, -5, 3, 0, 6.28); ctx.fill();
                }
                else if(this.type==='snajper'){
                    // NEW SNIPER MODEL
                    let aim = Math.atan2(player.y - this.y, player.x - this.x);
                    ctx.rotate(aim);
                    ctx.fillStyle = '#343'; ctx.beginPath(); ctx.arc(0, 0, 12, 0, 6.28); ctx.fill(); // Body
                    ctx.fillStyle = '#111'; ctx.fillRect(0, -3, 22, 6); // Gun barrel
                    ctx.strokeStyle = '#555'; ctx.lineWidth = 2; ctx.strokeRect(-5, -3, 10, 6); // Gun body
                    if(this.state === 'charge') {
                        ctx.fillStyle = '#f00'; ctx.beginPath(); ctx.arc(0, 0, 2, 0, 6.28); ctx.fill(); // Laser eye
                        // Laser sight
                        ctx.save(); ctx.globalCompositeOperation = 'lighter';
                        ctx.strokeStyle = `rgba(255, 0, 0, ${0.3 + Math.random()*0.4})`; ctx.lineWidth = 1;
                        ctx.beginPath(); ctx.moveTo(0,0);
                        let dx = player.x - this.x; let dy = player.y - this.y;
                        let dist = Math.sqrt(dx*dx+dy*dy);
                        ctx.lineTo(dist, 0); ctx.stroke(); ctx.restore();
                        ctx.fillStyle = '#fff'; ctx.fillRect(-15, -20, 30 * (1 - this.snajperTimer/60), 3); // Charge bar
                    }
                }
                else if(this.type==='lovac'){
                    ctx.rotate(this.angle + 1.57);
                    if(this.isPhased) ctx.globalAlpha = 0.3;
                    
                    // Cloak
                    ctx.fillStyle = '#800000';
                    ctx.beginPath();
                    ctx.moveTo(0, -25);
                    ctx.quadraticCurveTo(20, 0, 15, 25);
                    ctx.quadraticCurveTo(0, 20, -15, 25);
                    ctx.quadraticCurveTo(-20, 0, 0, -25);
                    ctx.fill();
                    
                    // Hood
                    ctx.fillStyle = '#500';
                    ctx.beginPath(); ctx.arc(0, -10, 12, 0, Math.PI, true); ctx.fill();
                    
                    // Eyes (Only visible when not phased or very faint)
                    ctx.fillStyle = '#f00';
                    ctx.shadowColor = '#f00'; ctx.shadowBlur = 10;
                    ctx.beginPath(); ctx.arc(-5, -12, 2, 0, 6.28); ctx.arc(5, -12, 2, 0, 6.28); ctx.fill();
                    ctx.shadowBlur = 0;

                    // Knife Hand
                    ctx.save();
                    ctx.translate(15, 0);
                    if(this.attackAnim > 0) {
                        // Swing animation
                        let swing = (this.attackAnim / 20) * Math.PI;
                        ctx.rotate(-swing);
                    }
                    ctx.fillStyle = '#ccc';
                    ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(5, -20); ctx.lineTo(-5, -20); ctx.fill(); // Blade
                    ctx.fillStyle = '#333'; ctx.fillRect(-3, 0, 6, 5); // Handle
                    ctx.restore();
                    
                    ctx.globalAlpha = 1;
                }
                else if(this.type==='medic'){
                    ctx.rotate(this.angle + 1.57);
                    ctx.fillStyle = '#eee'; ctx.beginPath(); ctx.arc(0, 0, 14, 0, 6.28); ctx.fill(); // Body
                    ctx.fillStyle = '#0f0'; ctx.font="bold 16px Arial"; ctx.fillText('+', -5, 5); // Cross
                    ctx.fillStyle = '#ccc'; ctx.fillRect(8, -5, 8, 10); // Healing Gun
                    ctx.fillStyle = '#0f0'; ctx.fillRect(16, -2, 4, 4); // Gun Tip
                }
                else if(this.type==='promaja'){ 
                    ctx.rotate(state.frames*0.2); ctx.shadowBlur = 10; ctx.shadowColor = 'rgba(200, 255, 255, 0.5)';
                    ctx.strokeStyle = 'rgba(220, 240, 255, 0.8)'; ctx.lineWidth = 2;
                    ctx.beginPath(); ctx.arc(0, 0, 8, 0, 5); ctx.stroke();
                    ctx.rotate(2); ctx.beginPath(); ctx.arc(0, 0, 16, 0, 4.5); ctx.stroke();
                    ctx.rotate(2); ctx.strokeStyle = 'rgba(220, 240, 255, 0.4)'; ctx.beginPath(); ctx.arc(0, 0, 24, 0, 3); ctx.stroke();
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)'; ctx.beginPath(); ctx.arc(0,0,4,0,6.28); ctx.fill();
                }
                else if(this.type==='yugo'){ 
                    ctx.rotate(this.angle); ctx.fillStyle='#800000'; ctx.fillRect(-20,-15,40,30);
                    ctx.fillStyle='#300000'; ctx.fillRect(-5,-13,20,26);
                    ctx.globalCompositeOperation = 'lighter'; ctx.fillStyle='rgba(255, 255, 200, 0.4)';
                    ctx.beginPath(); ctx.moveTo(20,-10); ctx.lineTo(120,-30); ctx.lineTo(120,30); ctx.lineTo(20,10); ctx.fill();
                    ctx.fillStyle='#ff0'; ctx.fillRect(18,-12,4,6); ctx.fillRect(18,6,4,6);
                }
                else if(this.type==='RHYTHM_WRAITH'){
                    ctx.fillStyle = '#00f3ff'; ctx.beginPath(); ctx.moveTo(0, -10); ctx.lineTo(10, 10); ctx.lineTo(-10, 10); ctx.fill();
                }
                else{ 
                    // HORNET
                    ctx.rotate(this.angle+1.57); ctx.fillStyle='rgba(255,255,255,0.6)'; 
                    let flap = Math.sin(state.frames*0.8)*5;
                    ctx.beginPath(); ctx.ellipse(8+flap, -5, 5, 12, 0.5, 0, 6.28); ctx.fill(); // Wing 1
                    ctx.beginPath(); ctx.ellipse(-8-flap, -5, 5, 12, -0.5, 0, 6.28); ctx.fill(); // Wing 2
                    ctx.fillStyle='#f1c40f'; ctx.beginPath(); ctx.ellipse(0, 0, 8, 14, 0, 0, 6.28); ctx.fill();
                    ctx.fillStyle='#000'; ctx.fillRect(-6, -2, 12, 2); ctx.fillRect(-6, 4, 12, 2);
                    ctx.fillStyle='#f00'; ctx.beginPath(); ctx.moveTo(0,14); ctx.lineTo(2,20); ctx.lineTo(-2,20); ctx.fill();
                }
            } 
            if(this.frozen>0){ ctx.fillStyle='rgba(0,255,255,0.4)';ctx.beginPath();ctx.arc(0,0,this.radius+5,0,6.28);ctx.fill();}
            if(this.burnTimer>0) { ctx.fillStyle='rgba(255, 100, 0, 0.5)'; ctx.beginPath(); ctx.arc(0,0,this.radius+5,0,6.28); ctx.fill(); }
            if(this.percentBurnLeft>0) {
                 ctx.strokeStyle = '#ff4500'; ctx.lineWidth = 2;
                 ctx.beginPath(); ctx.arc(0,0, this.radius+2, 0, 6.28); ctx.stroke();
            }
            ctx.restore();
        }
    }

    function triggerCrateOpening(type='standard') {
        if(document.getElementById('crate-screen').style.display === 'flex') return;
        isPaused = true;
        
        const screen = document.getElementById('crate-screen');
        const anim = document.getElementById('crate-anim');
        const cardsDiv = document.getElementById('crate-cards');
        const btn = document.getElementById('crate-claim-btn');
        const title = document.getElementById('crate-title');
        const flash = document.getElementById('white-flash');
        
        cardsDiv.innerHTML = '';
        btn.style.opacity = '0';
        title.style.opacity = '0';
        anim.style.display = 'block';
        anim.style.transform = 'scale(1)';
        
        screen.style.display = 'flex';
        
        // Animation Sequence
        anim.className = 'crate-drop';
        anim.innerText = type === 'musical' ? 'üéµ' : (type === 'tezina_reward' ? 'üëë' : 'üì¶');
        
        setTimeout(() => {
            anim.className = 'crate-shake';
            setTimeout(() => {
                flash.style.opacity = '1';
                setTimeout(() => { flash.style.opacity = '0'; }, 500);
                anim.style.display = 'none';
                title.style.opacity = '1';
                btn.style.opacity = '1';
                if(type === 'musical') generateMusicalLoot();
                else if(type === 'tezina_reward') generateTezinaLoot();
                else generateCrateLoot();
            }, 1000); 
        }, 500); 
    }

    function generateCrateLoot() {
        crateRewards = [];
        let available = [];
        UPGRADES.forEach(u => {
            let currentLvl = 0;
            if(player.weapons[u.id]) currentLvl = player.weapons[u.id].level;
            else if(player.items[u.id] !== undefined) currentLvl = player.items[u.id];
            
            if(currentLvl < (u.max || 10)) {
                available.push(u);
            }
        });
        
        for(let i=0; i<3; i++) {
            if(available.length > 0) {
                let r = Math.floor(Math.random() * available.length);
                crateRewards.push(available[r]);
            }
        }
        renderCrateCards(crateRewards);
    }

    function generateMusicalLoot() {
        crateRewards = SPECIAL_REWARDS;
        renderCrateCards(crateRewards);
    }

    function generateTezinaLoot() {
        crateRewards = [];
        // 3 Guaranteed Rares (Upgrades or Evolutions)
        let rares = [...UPGRADES, ...EVOLUTIONS].filter(u => u.tier === 'rare');
        
        // Shuffle to get unique
        for (let i = rares.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [rares[i], rares[j]] = [rares[j], rares[i]];
        }
        
        for(let i=0; i<3; i++) {
            if(i < rares.length) crateRewards.push(rares[i]);
        }

        // 2 Random Cards (Common/Rare/Legendary)
        let all = [...UPGRADES, ...EVOLUTIONS];
        for(let i=0; i<2; i++) {
             crateRewards.push(all[Math.floor(Math.random() * all.length)]);
        }

        renderCrateCards(crateRewards);
    }

    function renderCrateCards(list) {
        const container = document.getElementById('crate-cards');
        list.forEach(o => {
            const el=document.createElement('div'); el.className='card'; 
            if(o.tier === 'legendary') el.classList.add('legendary');
            if(o.tier === 'rare') el.classList.add('rare');
            
            let lvlText = '';
            if(player.weapons[o.id]) lvlText = 'Lvl ' + (player.weapons[o.id].level + 1);
            else if(player.items[o.id] !== undefined) lvlText = 'Lvl ' + (player.items[o.id] + 1);
            
            el.innerHTML=`<div class="card-level">${lvlText}</div><div class="card-icon">${o.icon}</div><div class="card-name">${o.name}</div><div class="card-desc">${o.desc}</div>`;
            el.onclick = () => { if(crateRewards === SPECIAL_REWARDS) { applyUpgrade(o.id); document.getElementById('crate-screen').style.display='none'; isPaused=false; } };
            container.appendChild(el);
        });
        if(crateRewards === SPECIAL_REWARDS) document.getElementById('crate-claim-btn').style.display = 'none';
        else document.getElementById('crate-claim-btn').style.display = 'block';
    }

    function claimCrateRewards() {
        crateRewards.forEach(r => {
            applyUpgrade(r.id);
        });
        document.getElementById('crate-screen').style.display = 'none';
        state.crates = []; 
        isPaused = false;
    }
</script>
</body>
</html>
