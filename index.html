<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Bosnian Survivors: INFERNO UPDATE</title>
<style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@500;700&display=swap');
    :root { 
        --bosnia-blue:#002395; 
        --bosnia-yellow:#fecb00; 
        --neon-cyan:#00f3ff; 
        --rare-blue:#4d80ff; 
        --supercharge:#ff2a2a; 
        --legendary:#d000ff; 
        --danger:#ff003c; 
        --dark:#050510; 
        --fire-orange:#ff5e00;
    }
    body { margin:0; overflow:hidden; background-color:var(--dark); font-family:'Rajdhani', sans-serif; color:white; user-select:none; }
    
    #crt-overlay {
        position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 9999;
        background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.1) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.03), rgba(0, 255, 0, 0.01), rgba(0, 0, 255, 0.03));
        background-size: 100% 4px, 6px 100%;
    }

    #ui-layer { position:fixed; top:0; left:0; width:100%; height:100%; pointer-events:none; padding:20px; box-sizing:border-box; display:flex; flex-direction:column; z-index:50; }
    .hud-top { display:flex; justify-content:space-between; align-items:flex-start; pointer-events: none; width: 100%; }
    
    .stat-box { 
        background:rgba(0, 10, 30, 0.6); 
        backdrop-filter:blur(4px); 
        border:1px solid rgba(0, 243, 255, 0.2); 
        border-bottom:3px solid var(--bosnia-yellow); 
        padding:8px 25px; 
        transform: skewX(-15deg);
        display:flex; flex-direction:column; align-items:center; 
    }
    .stat-content { transform: skewX(15deg); text-align: center; }

    .label { font-size:10px; color:var(--neon-cyan); text-transform:uppercase; letter-spacing:2px; font-family:'Orbitron'; margin-bottom:2px; opacity: 0.8; }
    .value { font-size:24px; font-weight:700; color:#fff; text-shadow:0 0 5px var(--neon-cyan); }
    
    /* TIMER */
    #timer-box {
        position: absolute; top: 10px; left: 50%; transform: translateX(-50%) skewX(-15deg);
        background:rgba(0, 0, 0, 0.8); border:1px solid var(--bosnia-yellow);
        padding: 5px 30px; z-index: 60;
    }
    #timer-display {
        font-family: 'Orbitron'; font-size: 32px; color: var(--bosnia-yellow); transform: skewX(15deg); letter-spacing: 3px;
    }

    /* HP BAR */
    #hp-container {
        position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
        width: 500px; text-align: center; pointer-events: none;
    }
    #hp-bar-frame {
        width:100%; height:16px; background:rgba(0,0,0,0.8); 
        transform: skewX(-20deg); border:1px solid #555; overflow: hidden; position: relative;
    }
    #hp-fill { height:100%; width:100%; background:linear-gradient(90deg, #ff003c, #ff5e00); transition:width 0.1s linear; }

    /* BOSS BAR */
    #boss-hud { display:none; position:fixed; top:80px; left:50%; transform:translateX(-50%); width:600px; z-index:60; flex-direction:column; align-items:center; }
    #boss-name { font-family:'Orbitron'; font-size:28px; color:var(--danger); margin-bottom:5px; letter-spacing:8px; font-weight:900; }
    #boss-bar-bg { width:100%; height:12px; background:rgba(0,0,0,0.8); border:1px solid var(--danger); transform: skewX(-20deg); overflow:hidden; }
    #boss-bar-fill { width:100%; height:100%; background:linear-gradient(90deg, #800000, #ff003c); transition:width 0.1s; }

    #pause-btn { pointer-events: auto; background:rgba(0,0,0,0.5); border:1px solid var(--neon-cyan); color:var(--neon-cyan); width:40px; height:40px; border-radius:0; transform: skewX(-10deg); font-family:'Orbitron'; font-weight:bold; cursor:pointer; margin-left:10px; display:flex; align-items:center; justify-content:center; transition:0.2s; }
    #pause-btn:hover { background:var(--neon-cyan); color:black; }

    .xp-container { position:fixed; top:0; left:0; width:100%; height:4px; background:#000; z-index:100; pointer-events: none; }
    #xp-fill { height:100%; width:0%; background:linear-gradient(90deg, var(--bosnia-blue), var(--neon-cyan)); transition:width 0.2s; }
    
    .screen-overlay { display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(5, 5, 10, 0.95); z-index:2000; flex-direction:column; align-items:center; justify-content:center; pointer-events:auto; overflow-y:auto;}
    
    #main-menu { display:flex; background: linear-gradient(rgba(0,0,0,0.5), rgba(0,0,0,0.9)), url('https://img.freepik.com/free-vector/blue-futuristic-networking-technology-background-vector_53876-114068.jpg'); background-size:cover; background-position: center; }
    .title-glitch { font-family:'Orbitron'; font-size:70px; color:white; text-shadow:2px 2px var(--bosnia-blue), -2px -2px var(--danger); text-align:center; }
    
    .menu-btn { 
        background:linear-gradient(90deg, rgba(0,0,0,0.5), rgba(0, 35, 149, 0.4)); 
        border:1px solid var(--bosnia-blue); 
        border-left: 4px solid var(--bosnia-yellow);
        color:white; padding:15px 50px; margin:10px; font-size:20px; font-family:'Orbitron'; 
        cursor:pointer; text-transform:uppercase; letter-spacing:4px; width:320px; 
        transition:0.2s; 
        clip-path: polygon(10px 0, 100% 0, 100% calc(100% - 10px), calc(100% - 10px) 100%, 0 100%, 0 10px);
        position: relative; overflow: hidden;
    }
    .menu-btn:hover { background:var(--bosnia-yellow); color:black; border-color:white; font-weight: 800; }

    #admin-panel { display:none; border:2px solid var(--danger); background:rgba(0,0,0,0.95); box-shadow: 0 0 50px rgba(255,0,0,0.2); flex-direction: column; align-items: center;}
    .admin-grid { display:grid; grid-template-columns: 1fr 1fr; gap:10px; width:600px; padding:20px; }
    .admin-btn { background:#111; border:1px solid #555; color:white; padding:15px; cursor:pointer; font-family:'Orbitron'; text-transform:uppercase; transition:0.2s; font-size: 14px; }
    .admin-btn:hover { background:var(--danger); color:white; border-color:white; box-shadow: 0 0 10px var(--danger); }
    .admin-header { font-family:'Orbitron'; color:var(--danger); font-size:30px; margin:20px 0; text-shadow:0 0 10px red; letter-spacing: 5px; text-align: center; width: 100%; border-bottom: 1px solid #333; padding-bottom: 10px;}
    #admin-augment-select { background: #000; color: var(--neon-cyan); border: 1px solid var(--neon-cyan); padding: 10px; width: 100%; font-family: 'Rajdhani'; font-size: 16px; margin-bottom: 10px; }

    /* Pause Stats */
    #pause-stats { 
        display: grid; grid-template-columns: 1fr 1fr; gap: 10px; 
        width: 80%; max-width: 600px; margin-bottom: 20px;
        max-height: 400px; overflow-y: auto;
    }
    .pause-item { 
        background: rgba(255,255,255,0.05); padding: 10px; border: 1px solid #333;
        display: flex; justify-content: space-between; align-items: center;
    }
    .pause-item span { font-family: 'Rajdhani'; font-size: 18px; color: var(--bosnia-yellow); }

    /* Evolution Overlay Styles */
    #evolution-overlay { display:none; background: #000; z-index: 3000; flex-direction: column; align-items: center; justify-content: center; }
    
    .evo-text {
        font-family: 'Orbitron'; font-weight: 900; font-size: 80px; text-align: center;
        color: var(--legendary); text-shadow: 0 0 20px var(--legendary);
        animation: glitch-text 0.5s infinite;
    }

    @keyframes glitch-text {
        0% { transform: translate(0); }
        20% { transform: translate(-2px, 2px); }
        40% { transform: translate(-2px, -2px); }
        60% { transform: translate(2px, 2px); }
        80% { transform: translate(2px, -2px); }
        100% { transform: translate(0); }
    }

    .info-grid { display:grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap:20px; max-width:1100px; width:90%; padding:20px; }
    .info-card { background:rgba(255,255,255,0.03); border:1px solid rgba(255,255,255,0.1); padding:20px; border-radius:4px; display:flex; align-items:center; gap:15px; position:relative; overflow:hidden;}
    .info-card.rare { border: 1px solid var(--rare-blue); box-shadow: inset 0 0 20px rgba(77, 128, 255, 0.1); }
    .info-card.legendary { border: 1px solid var(--legendary); box-shadow: inset 0 0 20px rgba(208, 0, 255, 0.1); }
    
    .info-icon { font-size:30px; min-width:60px; height: 60px; display: flex; align-items: center; justify-content: center; background: rgba(0,0,0,0.3); border-radius: 50%; border:1px solid rgba(255,255,255,0.1); }
    .info-text h3 { margin:0 0 5px 0; color:var(--bosnia-yellow); font-family:'Orbitron'; font-size:16px; letter-spacing: 1px; }
    .info-text p { margin:0; color:#aaa; font-size:13px; line-height:1.4; }
    .close-btn { position:absolute; top:30px; right:30px; background:none; border:none; color:white; font-size:40px; cursor:pointer; font-family: 'Rajdhani'; line-height: 20px;}
    .close-btn:hover { color:var(--danger); }

    .cards-container { display:flex; gap:25px; margin-top:30px; flex-wrap:wrap; justify-content:center; max-width:1200px;perspective: 1000px; }
    
    .card { 
        background:linear-gradient(170deg, #0a0a15 0%, #101025 100%); 
        border:1px solid #333; 
        width:220px; height:380px; 
        border-radius:2px; padding:20px; 
        cursor:pointer; transition:0.3s; 
        display:flex; flex-direction:column; align-items:center; text-align:center; 
        box-shadow:0 10px 30px rgba(0,0,0,0.8); 
        position:relative; overflow:hidden; 
        clip-path: polygon(20px 0, 100% 0, 100% calc(100% - 20px), calc(100% - 20px) 100%, 0 100%, 0 20px);
    }
    .card:hover { transform:translateY(-10px); border-color:var(--bosnia-yellow); z-index: 10; }
    .card:hover .card-icon { transform: scale(1.1); }
    .card::after { content:''; position: absolute; top:0; left:0; width:100%; height:4px; background: var(--bosnia-yellow); }
    
    .card.rare { border-color: var(--rare-blue); background:linear-gradient(170deg, #051025 0%, #001530 100%); }
    .card.rare::after { background: var(--rare-blue); }
    .card.rare .card-name { color: var(--rare-blue); }
    
    .card.legendary { border-color: var(--legendary); background:linear-gradient(170deg, #1a0025 0%, #100020 100%); }
    .card.legendary::after { background: var(--legendary); }
    .card.legendary .card-name { color: var(--legendary); text-shadow: 0 0 5px var(--legendary); }

    .card-icon { font-size:60px; margin: 30px 0; transition: 0.3s; filter: drop-shadow(0 0 5px rgba(255,255,255,0.2)); }
    .card-name { font-family:'Orbitron'; font-weight:900; color:#fff; margin-bottom:10px; font-size:18px; text-transform:uppercase; letter-spacing: 1px;}
    .card-desc { font-size:13px; color:#99a; line-height:1.5; border-top: 1px solid rgba(255,255,255,0.1); padding-top: 10px; width: 100%; }
    .card-level { position:absolute; top:10px; right:10px; font-size:10px; color:#555; font-family:'Orbitron'; font-weight: bold; }

    .restart-btn { background: var(--danger); color:white; border:none; padding:20px 60px; font-size:24px; font-weight:900; cursor:pointer; font-family:'Orbitron'; clip-path:polygon(10px 0, 100% 0, 100% calc(100% - 10px), calc(100% - 10px) 100%, 0 100%, 0 10px); transition:0.2s; box-shadow:0 0 15px var(--danger); margin-top:30px; text-transform:uppercase; letter-spacing: 2px; }
    .restart-btn:hover { transform:scale(1.05); background: white; color: var(--danger); }
    
    canvas { display:block; position:absolute; top:0; left:0; z-index:1; }
</style>
</head>
<body>

<div id="crt-overlay"></div>
<div class="xp-container"><div id="xp-fill"></div></div>

<!-- BOSS HUD -->
<div id="boss-hud">
    <div id="boss-name">TURBO FOLK WARLORD</div>
    <div id="boss-bar-bg"><div id="boss-bar-fill"></div></div>
</div>

<!-- MAIN MENU -->
<div id="main-menu" class="screen-overlay" style="display:flex;">
    <h1 class="title-glitch">BOSNIAN<br><span style="color:var(--bosnia-yellow)">SURVIVORS</span></h1>
    <h3 style="font-family:'Rajdhani'; letter-spacing:5px; color:var(--neon-cyan); margin-top:-20px;">INFERNO UPDATE</h3>
    <div style="height:40px;"></div>
    <button class="menu-btn" onclick="startGame()">DEPLOY</button>
    <button class="menu-btn" onclick="openInfo('armory')">ARMORY</button>
    <button class="menu-btn" onclick="openInfo('intel')">INTEL</button>
</div>

<!-- INFO MODAL -->
<div id="info-modal" class="screen-overlay">
    <button class="close-btn" onclick="closeInfo()">√ó</button>
    <h1 id="info-title" style="font-family:'Orbitron'; color:var(--bosnia-yellow); margin-top:50px; font-size: 40px; text-shadow: 0 0 10px var(--bosnia-yellow);">DATA</h1>
    <div id="info-content" class="info-grid"></div>
</div>

<!-- ADMIN PANEL -->
<div id="admin-panel" class="screen-overlay">
    <div class="admin-header">/// DEBUG CONTROL ///</div>
    <div class="admin-grid" style="grid-template-columns: 1fr 1fr; width: 400px; margin-bottom: 20px;">
        <label style="color:white; font-family:'Orbitron'; font-size:12px;">FORCE AUGMENTATION</label>
        <div style="display:flex; gap:10px;">
            <select id="admin-augment-select"></select>
            <button class="admin-btn" style="padding:10px;" onclick="adminForceUpgrade()">ADD</button>
        </div>
    </div>
    <div class="admin-grid">
        <button class="admin-btn" onclick="toggleGodMode()">Toggle God Mode</button>
        <button class="admin-btn" onclick="adminLevelUp()">+1 Level</button>
        <button class="admin-btn" onclick="adminKillAll()">Kill All Enemies</button>
        <button class="admin-btn" onclick="spawnBoss()">Force Boss Spawn</button>
        <button class="admin-btn" onclick="adminCycleLuck()">CYCLE LUCK: <span id="admin-luck-val">1x</span></button>
        <button class="admin-btn" onclick="adminHeal()">Full Heal</button>
    </div>
    <button class="menu-btn" style="width:200px; margin-top:20px;" onclick="closeAdmin()">RESUME</button>
</div>

<!-- PAUSE MENU -->
<div id="pause-screen" class="screen-overlay">
    <h1 style="font-family:'Orbitron'; font-size:60px; color:var(--neon-cyan);">PAUSED</h1>
    <div id="pause-stats"></div>
    <button class="menu-btn" onclick="togglePause()">RESUME</button>
    <button class="menu-btn" onclick="quitGame()">MAIN MENU</button>
</div>

<!-- EVOLUTION OVERLAY -->
<div id="evolution-overlay" class="screen-overlay"></div>

<!-- GAME UI -->
<div id="ui-layer" style="display:none;">
    <div id="timer-box">
        <div id="timer-display">00:00</div>
    </div>
    
    <div class="hud-top">
        <div class="stat-box">
            <div class="stat-content">
                <div class="label">Threat Level</div>
                <div class="value" style="color:var(--bosnia-yellow)" id="lvl-display">1</div>
            </div>
        </div>
        <div style="display:flex;">
            <div class="stat-box">
                <div class="stat-content">
                    <div class="label">Kills</div>
                    <div class="value" style="color:#fff" id="score-display">0</div>
                </div>
            </div>
            <button id="pause-btn" onclick="togglePause()">||</button>
        </div>
    </div>

    <div id="hp-container">
        <div id="hp-bar-frame">
            <div id="hp-fill"></div>
        </div>
        <div style="font-size: 10px; color: #888; margin-top: 5px; font-family: 'Orbitron'; letter-spacing: 2px;">VITAL SYSTEMS</div>
    </div>

    <div id="god-mode-indicator" style="display:none; position:fixed; bottom:20px; left:20px; color:var(--danger); font-family:'Orbitron'; font-size:20px; text-shadow:0 0 10px red;">GOD MODE ACTIVE</div>
</div>

<div id="levelup-screen" class="screen-overlay">
    <h1 style="font-family:'Orbitron'; font-size:50px; color:var(--bosnia-yellow); margin-bottom:5px; text-shadow:0 0 15px var(--bosnia-yellow); letter-spacing: 5px;">SYSTEM UPGRADE</h1>
    <p style="color:var(--neon-cyan); margin-bottom:30px; font-size:18px; font-family: 'Rajdhani'; letter-spacing: 2px;">SELECT AUGMENTATION</p>
    <div class="cards-container" id="cards-box"></div>
</div>

<div id="game-over" class="screen-overlay">
    <h1 style="color:var(--danger); font-family:'Orbitron'; font-size:100px; margin:0; text-shadow:0 0 20px red; letter-spacing:10px;">MIA</h1>
    <p style="font-size:24px; color:white; font-family: 'Rajdhani'; letter-spacing: 2px;">FINAL SCORE: <span id="final-score" style="color:var(--bosnia-yellow); font-weight:bold;">0</span></p>
    <button class="restart-btn" onclick="resetGame()">RESPAWN</button>
    <button class="menu-btn" style="margin-top:20px; font-size:16px;" onclick="quitGame()">EXIT TO MENU</button>
</div>

<canvas id="game"></canvas>

<script>
    const canvas = document.getElementById('game'), ctx = canvas.getContext('2d', { alpha: false });
    let W, H;
    
    // ADMIN VARS
    const CHEAT_CODE = "Roblox13_isme";
    let inputBuffer = "";
    let godMode = false;

    // ASSETS
    const UPGRADES=[
        {id:'burek',name:'Golden Burek',icon:'ü•ê',desc:'Spawns rotating pastry shields that damage enemies.', tier:'common', max:8},
        {id:'cevapi',name:'Rapid Cevapi',icon:'üå≠',desc:'Fires delicious grilled meat missiles.', tier:'common', max:10},
        {id:'ajvar',name:'Nuclear Ajvar',icon:'üå∂Ô∏è',desc:'Throws explosive jars of pepper paste.', tier:'common', max:10},
        {id:'rakija',name:'Holy Rakija',icon:'üçæ',desc:'Smashes bottles creating purifying fire zones.', tier:'common', max:10},
        {id:'pyramid',name:'Visoko Beam',icon:'‚õ∞Ô∏è',desc:'Fires a high-energy piercing triangle beam.', tier:'common', max:6},
        
        {id:'spike', name:'Impaler Spikes', icon:'üî©', desc:'Summons spikes under the 3 strongest enemies. (Dmg scales with Player Level)', tier:'common', max:10},
        {id:'sword', name:'Dull Bosnian Sword', icon:'üó°Ô∏è', desc:'+10% Damage for ALL attacks. (Additive Stack)', tier:'common', max:10},
        
        {id:'harmonika',name:'Harmonika Aura',icon:'üéπ',desc:'Slows all enemies within range. (30% Base, +10% per level, Max 80%)', tier:'rare', max:8},
        {id:'xp_boost',name:'Poor Jewelry',icon:'üíç',desc:'+50% EXP Gain (Stacks)', tier:'rare', max:10},
        {id:'cracked_jewelry', name:'Cracked Jewelry', icon:'üìø', desc:'+25% EXP Gain (Stacks with Poor Jewelry).', tier:'common', max:10},
        
        {id:'serbian',name:'Serbian Warrior',icon:'‚öîÔ∏è',desc:'Summons a Friendly Unit. Targets Hordes. 30s Respawn.', tier:'legendary', max:1},
        
        {id:'speed',name:'Turbo Folk Speed',icon:'‚ö°',desc:'Increases Movement Speed by 20%.', tier:'common', max:10},
        {id:'magnet',name:'Super Magnet',icon:'üß≤',desc:'Increases Item Pickup Range by 50%.', tier:'common', max:10},
        {id:'armor',name:'Kevlar Vest',icon:'üõ°Ô∏è',desc:'Reduces incoming damage.', tier:'common', max:10},
        {id:'heal',name:'Grandma Soup',icon:'üç≤',desc:'Instantly restores 50 HP.', tier:'common', max:10},
        {id:'coffee',name:'Bosnian Coffee',icon:'‚òï',desc:'Reduces all weapon cooldowns by 10%.', tier:'common', max:10},
        {id:'lily',name:'Golden Lily',icon:'‚öúÔ∏è',desc:'Increases Critical Hit Chance by 10%.', tier:'common', max:10},
        {id:'vrelo',name:'Vrelo Bosne',icon:'üèûÔ∏è',desc:'Regenerates 2 HP per second.', tier:'common', max:10}
    ];

    const EVOLUTIONS = [
        {id:'burek_evo',base:'burek',name:'RING OF FIRE',icon:'üî•',desc:'EVOLUTION: Massive permanent fire zone. 2x Radius. Burns ALL enemies constantly.', tier:'rare'},
        {id:'pyramid_evo',base:'pyramid',name:'SOLAR FLARE',icon:'‚òÄÔ∏è',desc:'EVOLUTION: Instantly blasts enemies with a massive laser beam.', tier:'rare'},
        
        {id:'serbian_p1', base:'serbian', name:'PATH 1: TITAN SWORD', icon:'üó°Ô∏è', desc:'LVL 2: Bigger Sword. Higher Damage. Same AI.', tier:'legendary', req:'serbian'},
        {id:'serbian_p2', base:'serbian', name:'PATH 2: TACTICAL SQUAD', icon:'üë•', desc:'LVL 2: Splits into 3 Units: Soldier, Defender, Mage.', tier:'legendary', req:'serbian'},
        {id:'serbian_p3', base:'serbian', name:'PATH 3: VANGUARD', icon:'üõ°Ô∏è', desc:'LVL 2: Sword & Shield Unit. 20 Durability. Tanky.', tier:'legendary', req:'serbian'},
        
        {id:'serbian_p1_evo', base:'serbian_p1', name:'BERSERKER', icon:'üå™Ô∏è', desc:'LVL 3: 1.5x Size/Dmg. Spin Attack (3 hits). 4s Cooldown.', tier:'legendary', req:'serbian_p1'},
        {id:'serbian_p2_evo', base:'serbian_p2', name:'ELITE SQUAD', icon:'‚ú®', desc:'LVL 3: Shield gets Pushback. Mage gets Visoko Beam.', tier:'legendary', req:'serbian_p2'},
        {id:'serbian_p3_evo', base:'serbian_p3', name:'WARLORD TANK', icon:'üí¢', desc:'LVL 3: 30 Durability. Taunts enemies every 20s.', tier:'legendary', req:'serbian_p3'}
    ];
    
    const SUPERCHARGES = [
        {id:'supercharge_burek', name:'SUPERCHARGE: MAGMA', icon:'üåã', desc:'Increases Burn Damage.', tier:'legendary'},
        {id:'supercharge_pyramid', name:'SUPERCHARGE: SOLAR', icon:'üî•', desc:'+20% Damage for Solar Flare.', tier:'legendary'}
    ];

    const ENEMY_INFO = [
        {name:'Promaja', icon:'üí®', desc:'The silent killer. A swirling vortex of cold air.'},
        {name:'Yugo 45', icon:'üöó', desc:'Tanky unit. Hard to destroy, hits like a truck.'},
        {name:'Hornet', icon:'üêù', desc:'Swarm unit. Fast, aggressive, attacks in groups.'},
        {name:'WARLORD', icon:'üëπ', desc:'The Final Boss. Immune to Nuke/Freeze. 5000 HP.'}
    ];

    let gameActive = false;
    let isPaused = false;
    
    let state = { 
        frames:0, gameTime:0, score:0, level:1, xp:0, nextLevelXp:20, xpMult:1, shake:0, 
        enemies:[], particles:[], projectiles:[], beams:[], zones:[], texts:[], gems:[], perks:[], backgroundStars:[], 
        bossActive:false, bossSpawnedOnce:false, flashAlpha:0,
        friendlyUnits: [] 
    };
    let player = { 
        x:0, y:0, hp:100, maxHp:100, speed:6, radius:20, magnetRadius:140, armor:0, regen:0, critChance:0.05, cdr:1.0, facing:0, 
        luck: 1.0, visible: true,
        weapons:{},
        items:{} 
    };

    function resize(){ W=canvas.width=window.innerWidth; H=canvas.height=window.innerHeight; }
    window.addEventListener('resize', resize); resize();

    const keys = {};
    window.addEventListener('keydown', e=>{
        keys[e.key.toLowerCase()]=true;
        if(e.key === "Escape" && gameActive) togglePause();
        
        if(e.key.length === 1) {
            inputBuffer += e.key;
            if(inputBuffer.length > CHEAT_CODE.length) inputBuffer = inputBuffer.slice(-CHEAT_CODE.length);
            if(inputBuffer === CHEAT_CODE){
                openAdmin();
            }
        }
    }); 
    window.addEventListener('keyup', e=>keys[e.key.toLowerCase()]=false);

    function openAdmin(){
        if(!gameActive) return;
        populateAdminSelect();
        document.getElementById('admin-panel').style.display='flex';
        if(!isPaused) togglePause();
    }
    
    function populateAdminSelect() {
        const sel = document.getElementById('admin-augment-select');
        sel.innerHTML = "";
        const all = [...UPGRADES, ...EVOLUTIONS, ...SUPERCHARGES];
        all.forEach(u => {
            let opt = document.createElement('option');
            opt.value = u.id;
            opt.innerText = u.name;
            sel.appendChild(opt);
        });
    }
    
    function adminForceUpgrade() {
        const val = document.getElementById('admin-augment-select').value;
        applyUpgrade(val);
        spawnDamageText(player.x, player.y-80, "ADMIN UPGRADE", true);
        closeAdmin();
    }

    function adminCycleLuck() {
        if(player.luck === 1.0) player.luck = 2.0;
        else if(player.luck === 2.0) player.luck = 5.0;
        else if(player.luck === 5.0) player.luck = 10.0;
        else player.luck = 1.0;
        document.getElementById('admin-luck-val').innerText = player.luck + "x";
    }

    function closeAdmin(){
        document.getElementById('admin-panel').style.display='none';
        if(isPaused) togglePause();
    }
    function toggleGodMode(){
        godMode = !godMode;
        document.getElementById('god-mode-indicator').style.display = godMode ? 'block' : 'none';
        spawnDamageText(player.x, player.y-60, godMode ? "GOD MODE ON" : "GOD MODE OFF", true);
    }
    function adminLevelUp(){
        state.xp = state.nextLevelXp;
        checkLevelUp();
    }
    function adminKillAll(){
        state.enemies.forEach(e => {
            if(e.type !== 'BOSS') e.takeDamage(99999, true);
        });
    }
    function adminHeal(){
        player.hp = player.maxHp;
        updateHud();
    }

    function openInfo(type){
        document.getElementById('info-modal').style.display='flex';
        const content = document.getElementById('info-content');
        const title = document.getElementById('info-title');
        content.innerHTML = '';
        
        if(type === 'armory'){
            title.innerText = "ARMORY PROTOCOLS";
            const allItems = [...UPGRADES, ...EVOLUTIONS].filter(u => !u.id.includes('serbian_p'));

            allItems.forEach(u => {
                let extraClass = '';
                if(u.tier === 'rare') extraClass = 'rare';
                if(u.tier === 'legendary') extraClass = 'legendary';
                content.innerHTML += `
                <div class="info-card ${extraClass}">
                    <div class="info-icon">${u.icon}</div>
                    <div class="info-text"><h3>${u.name}</h3><p>${u.desc}</p></div>
                </div>`;
            });
        } else {
            title.innerText = "THREAT INTEL";
            ENEMY_INFO.forEach(e => {
                content.innerHTML += `
                <div class="info-card">
                    <div class="info-icon">${e.icon}</div>
                    <div class="info-text"><h3>${e.name}</h3><p>${e.desc}</p></div>
                </div>`;
            });
        }
    }

    function closeInfo(){ document.getElementById('info-modal').style.display='none'; }
    
    function startGame(){
        document.getElementById('main-menu').style.display='none';
        resetGame();
    }
    
    function quitGame(){
        gameActive = false;
        document.getElementById('game-over').style.display='none';
        document.getElementById('pause-screen').style.display='none';
        document.getElementById('ui-layer').style.display='none';
        document.getElementById('boss-hud').style.display='none';
        document.getElementById('admin-panel').style.display='none';
        document.getElementById('evolution-overlay').style.display='none';
        document.getElementById('main-menu').style.display='flex';
    }

    function togglePause(){
        if(!gameActive) return;
        if(document.getElementById('levelup-screen').style.display === 'flex') return;
        if(document.getElementById('evolution-overlay').style.display === 'flex') return;
        isPaused = !isPaused;
        document.getElementById('pause-screen').style.display = isPaused ? 'flex' : 'none';
        
        if(isPaused) {
            const statsBox = document.getElementById('pause-stats');
            statsBox.innerHTML = '';
            
            let allAbilities = [];
            for (const [key, val] of Object.entries(player.weapons)) {
                if (val.level > 0) {
                    let info = UPGRADES.find(u => u.id === key);
                    let name = info ? info.name : key;
                    if(key === 'serbian') name = "Serbian Warrior";
                    let displayLvl = val.evolved ? "EVOLVED" : val.level;
                    allAbilities.push({ name: name, lvl: displayLvl });
                }
            }
            for (const [key, val] of Object.entries(player.items)) {
                if (val > 0) {
                    let info = UPGRADES.find(u => u.id === key);
                    let name = info ? info.name : key;
                    allAbilities.push({ name: name, lvl: val });
                }
            }
            if(allAbilities.length === 0) statsBox.innerHTML = '<div style="color:#777; font-family:Rajdhani">No Augmentations</div>';

            allAbilities.forEach(ab => {
                 let row = document.createElement('div');
                 row.className = 'pause-item';
                 row.innerHTML = `<span>${ab.name}</span><span style="color:var(--neon-cyan)">${ab.lvl}</span>`;
                 statsBox.appendChild(row);
            });
        }
    }

    function initBackground() {
        state.backgroundStars = [];
        for(let i=0; i<60; i++) { 
            state.backgroundStars.push({
                x: Math.random() * W,
                y: Math.random() * H,
                size: Math.random() * 2 + 1,
                alpha: Math.random() * 0.5 + 0.1
            });
        }
    }

    function resetGame(){
        gameActive = true;
        isPaused = false;
        godMode = false;
        document.getElementById('god-mode-indicator').style.display='none';
        state = { 
            frames:0, gameTime:0, score:0, level:1, xp:0, nextLevelXp:20, xpMult:1, shake:0, 
            enemies:[], particles:[], projectiles:[], beams:[], zones:[], texts:[], gems:[], perks:[], backgroundStars:[],
            bossActive:false, bossSpawnedOnce:false, flashAlpha:0,
            friendlyUnits: []
        };
        initBackground();
        
        player = { 
            x:W/2, y:H/2, hp:100, maxHp:100, speed:6, radius:20, magnetRadius:140, armor:0, regen:0, critChance:0.05, cdr:1.0, facing:0, 
            luck: 1.0, visible: true,
            weapons:{
                burek: { level:1, count:1, damage:10, dist:100, speed:0.02, evolved:false, orbs:[], trailTimer:0 },
                cevapi: { level:1, cooldown:30, baseCool:30, timer:0, damage:15 }, 
                ajvar: { level:0, cooldown:140, baseCool:140, timer:0, damage:80 },
                rakija: { level:0, cooldown:190, baseCool:190, timer:0, damage:4, duration:300 }, 
                pyramid: { level:0, cooldown:110, baseCool:110, timer:0, damage:50, evolved:false },
                spike: { level:0, cooldown:180, baseCool:180, timer:0, damage:60 }, // COOLDOWN 3 SECONDS
                harmonika: { level:0, range:240, slow:0.30 },
                serbian: { level:0, path: 0, evolved: false }
            },
            items: {
                speed:0, magnet:0, armor:0, heal:0, coffee:0, lily:0, vrelo:0, xp_boost:0,
                sword:0, cracked_jewelry:0
            }
        };

        document.getElementById('game-over').style.display='none';
        document.getElementById('levelup-screen').style.display='none';
        document.getElementById('pause-screen').style.display='none';
        document.getElementById('boss-hud').style.display='none';
        document.getElementById('admin-panel').style.display='none';
        document.getElementById('evolution-overlay').style.display='none';
        document.getElementById('ui-layer').style.display='flex';
        updateHud();
    }

    function createParticle(x,y,color,type,speedM=1) {
        if(state.particles.length>250) return; 
        const p={x:x,y:y,vx:(Math.random()-0.5)*8*speedM,vy:(Math.random()-0.5)*8*speedM,life:1,decay:0.015+Math.random()*0.03,color:color,size:Math.random()*6+2,type:type};
        if(type==='fire'){p.vy-=2;p.decay=0.04;p.size*=1.5;} 
        if(type==='spark'){p.decay=0.06;p.size=2;p.life=0.8;} 
        if(type==='smoke'){p.vx*=0.3;p.vy*=0.3;p.size=12;p.decay=0.01;p.color='#555';} 
        if(type==='plasma'){p.decay=0.08;p.size=Math.random()*12+4;}
        if(type==='note'){p.decay=0.02;p.size=10;p.vx*=0.5;p.vy=-2;p.char='üéµ';}
        if(type==='blood'){p.decay=0.03;p.size=Math.random()*5+2;p.color='#aa0000';}
        state.particles.push(p);
    }
    
    function spawnDamageText(x,y,dmg,isCrit){ 
        let v = (typeof dmg === 'string') ? dmg : Math.floor(dmg);
        state.texts.push({x:x+(Math.random()-0.5)*30,y:y,val:v,life:1,color:isCrit?'#00f3ff':'#fff',scale:isCrit?2:1.2, vy:-2}); 
    }
    
    function addShake(amt){ state.shake=Math.min(state.shake+amt,30); }
    
    function calcDamage(base){ 
        let levelBonus = Math.max(0, state.level - 1); 
        let totalBase = base + (levelBonus * 0.5);
        if(player.items.sword > 0) totalBase *= (1 + (player.items.sword * 0.1));
        let isCrit = Math.random() < player.critChance; 
        let dmg = totalBase * (isCrit ? 2.0 : 1.0); 
        return {d:dmg, c:isCrit}; 
    }

    // --- FRIENDLY UNIT SYSTEM ---
    class FriendlyUnit {
        constructor(type, x, y) {
            this.type = type;
            this.x = x; this.y = y;
            
            this.maxDurability = 10;
            this.baseDamage = 50;
            this.radius = 25;
            this.attackRange = 100;
            this.attackSpeed = 180;
            this.moveSpeed = 3.5;
            this.respawnTime = 30 * 60;
            
            this.durability = this.maxDurability;
            this.attackTimer = 0;
            this.immuneTimer = 0;
            this.dead = false;
            this.respawnTimer = 0;
            this.magnetRadius = 250;
            this.taunting = false;
            this.tauntTimer = 0;
            this.tauntCooldown = 0;
            this.invisibleTimer = 0; // NEW for Mage

            if(type === 'soldier') { this.maxDurability = 10; }
            if(type === 'titan') { this.baseDamage = 75; }
            if(type === 'vanguard') { this.maxDurability = 20; }
            if(type === 'defender') { this.maxDurability = 15; this.baseDamage = 0; }
            if(type === 'mage') { this.maxDurability = 3; this.attackRange = 400; }

            const tech = player.weapons.serbian;
            if(tech.path === 2 && type === 'soldier') this.maxDurability = 5;
            
            if(tech.path === 3 && tech.evolved) { this.maxDurability = 30; this.canTaunt = true; }
            if(tech.path === 1 && tech.evolved) { this.radius *= 1.5; this.baseDamage *= 1.5; this.attackSpeed = 240; this.isBerserk = true; }
            if(tech.path === 2 && tech.evolved) {
                if(type === 'defender') { this.maxDurability = 10; this.canPush = true; this.pushTimer = 0; }
                if(type === 'mage') { this.hasBeam = true; }
            }
            this.durability = this.maxDurability;
        }

        update() {
            if(this.dead) {
                this.respawnTimer--;
                if(this.respawnTimer <= 0) {
                    this.dead = false;
                    this.durability = this.maxDurability;
                    this.immuneTimer = 180;
                    this.x = player.x; this.y = player.y;
                    spawnDamageText(this.x, this.y-50, "UNIT READY", true);
                    createParticle(this.x, this.y, '#fff', 'plasma', 5);
                }
                return;
            }
            if(this.immuneTimer > 0) this.immuneTimer--;
            if(this.invisibleTimer > 0) this.invisibleTimer--;

            state.gems.forEach(g => {
                if(!g.vacuum) {
                    let d = Math.hypot(g.x - this.x, g.y - this.y);
                    if(d < this.magnetRadius) g.vacuum = true;
                }
            });

            // AI MOVEMENT
            let target = null;
            let minDist = 9999;
            let enemiesNearby = 0;

            state.enemies.forEach(e => {
                let d = Math.hypot(e.x - this.x, e.y - this.y);
                if(d < 150) enemiesNearby++;
                if(d < minDist) { minDist = d; target = e; }
            });

            let moveX = 0, moveY = 0;
            let distToPlayer = Math.hypot(player.x - this.x, player.y - this.y);
            
            if(distToPlayer > 800) {
                 let ang = Math.atan2(player.y - this.y, player.x - this.x);
                 moveX = Math.cos(ang) * 2;
                 moveY = Math.sin(ang) * 2;
            } else {
                if(this.type === 'mage') {
                    let protectTarget = state.friendlyUnits.find(u => u.type === 'defender' && !u.dead) || player;
                    let dProt = Math.hypot(protectTarget.x - this.x, protectTarget.y - this.y);
                    if(minDist < 200) { 
                         let ang = Math.atan2(target.y - this.y, target.x - this.x);
                         moveX = -Math.cos(ang); moveY = -Math.sin(ang);
                    } else if(dProt > 100) { 
                         let ang = Math.atan2(protectTarget.y - this.y, protectTarget.x - this.x);
                         moveX = Math.cos(ang); moveY = Math.sin(ang);
                    }
                } 
                else if (this.type === 'defender') {
                     if(target) {
                         let ang = Math.atan2(target.y - player.y, target.x - player.x);
                         let blockX = player.x + Math.cos(ang) * 60;
                         let blockY = player.y + Math.sin(ang) * 60;
                         let dBlock = Math.hypot(blockX - this.x, blockY - this.y);
                         if(dBlock > 10) {
                             let angM = Math.atan2(blockY - this.y, blockX - this.x);
                             moveX = Math.cos(angM); moveY = Math.sin(angM);
                         }
                     } else {
                         let dP = Math.hypot(player.x - this.x, player.y - this.y);
                         if(dP > 60) {
                             let ang = Math.atan2(player.y - this.y, player.x - this.x);
                             moveX = Math.cos(ang); moveY = Math.sin(ang);
                         }
                     }
                }
                else { 
                    if(enemiesNearby >= 5) { moveX = 0; moveY = 0; } 
                    else {
                        if(target) {
                            let d = Math.hypot(target.x - this.x, target.y - this.y);
                            if(d > 40) {
                                 let ang = Math.atan2(target.y - this.y, target.x - this.x);
                                 moveX = Math.cos(ang); moveY = Math.sin(ang);
                            }
                        } else {
                            let dP = Math.hypot(player.x - this.x, player.y - this.y);
                             if(dP > 100) {
                                 let ang = Math.atan2(player.y - this.y, player.x - this.x);
                                 moveX = Math.cos(ang); moveY = Math.sin(ang);
                             }
                        }
                    }
                }
            }

            this.x += moveX * this.moveSpeed;
            this.y += moveY * this.moveSpeed;

            if(this.canTaunt) {
                if(this.tauntCooldown > 0) this.tauntCooldown--;
                if(this.taunting) {
                    this.tauntTimer--;
                    if(this.tauntTimer <= 0) {
                        this.taunting = false;
                        this.tauntCooldown = 1200; 
                    }
                } else if(this.tauntCooldown <= 0 && enemiesNearby > 0) {
                    this.taunting = true;
                    this.tauntTimer = 300; 
                    spawnDamageText(this.x, this.y-60, "TAUNTING!", true);
                    state.zones.push(new Zone(this.x, this.y, 'taunt_ring', 300));
                }
            }

            if(this.canPush) {
                 this.pushTimer++;
                 if(this.pushTimer > 900) { 
                     this.pushTimer = 0;
                     state.zones.push(new Zone(this.x, this.y, 'shield_push', 20)); 
                     let range = player.weapons.harmonika.range * 1.5;
                     state.enemies.forEach(e => {
                         let d = Math.hypot(e.x - this.x, e.y - this.y);
                         if(d < range) {
                             let ang = Math.atan2(e.y - this.y, e.x - this.x);
                             e.pushX = Math.cos(ang) * 25;
                             e.pushY = Math.sin(ang) * 25;
                         }
                     });
                     spawnDamageText(this.x, this.y-60, "PUSHBACK", true);
                 }
            }

            this.attackTimer++;
            if(this.attackTimer > this.attackSpeed) {
                if(this.type === 'mage') {
                    if(target) {
                        this.attackTimer = 0;
                        let pLevel = Math.max(1, player.weapons.cevapi.level);
                        let p = new Projectile(this.x, this.y, target, 'cevapi');
                        p.overrideDamage = 15 + (pLevel * 10) + (state.level * 1);
                        state.projectiles.push(p);

                        if(this.hasBeam) {
                             let beamLvl = Math.max(1, player.weapons.pyramid.level);
                             let ang = Math.atan2(target.y - this.y, target.x - this.x);
                             state.beams.push(new Beam(this.x, this.y, ang));
                             state.enemies.forEach(e => {
                                 let d = Math.hypot(e.x - this.x, e.y - this.y); 
                                 if(d < 600 && Math.abs(Math.atan2(e.y-this.y, e.x-this.x) - ang) < 0.2) {
                                     e.takeDamage(50 * beamLvl, false, 'friendly_beam');
                                 }
                             });
                        }
                    }
                }
                else if(this.type === 'defender') { }
                else {
                    this.attackTimer = 0;
                    addShake(5);
                    let damageCalc = this.baseDamage + (state.level * 5);
                    if(this.isBerserk) {
                        state.zones.push(new Zone(this.x, this.y, 'berserk_spin', 45, damageCalc)); 
                    } else {
                        state.zones.push(new Zone(this.x, this.y, 'valk_swing', 15, damageCalc));
                        state.enemies.forEach(e => {
                            if(Math.hypot(e.x - this.x, e.y - this.y) < 160) {
                                e.takeDamage(damageCalc, true, 'friendly');
                            }
                        });
                    }
                }
            }
        }

        takeDamage(amt) {
            if(this.immuneTimer > 0) return;
            if(this.invisibleTimer > 0) return; // Mage invisible, no damage

            // MAGE SPECIAL ABILITY: Invisibility on hit
            if(this.type === 'mage') {
                this.invisibleTimer = 180; // 3 seconds
                spawnDamageText(this.x, this.y - 40, "PHASE SHIFT", true);
                return; // NO DURABILITY LOSS
            }

            this.durability--;
            this.immuneTimer = 300; 
            spawnDamageText(this.x, this.y - 30, "-1 DUR", true);
            createParticle(this.x, this.y, '#00f3ff', 'plasma', 3);

            if(this.durability <= 0) {
                this.dead = true;
                this.respawnTimer = this.respawnTime;
                spawnDamageText(this.x, this.y-50, "UNIT DOWN", true);
            }
        }

        draw(cX, cY) {
            if(this.dead) {
                let sec = Math.ceil(this.respawnTimer / 60);
                ctx.fillStyle = '#555'; ctx.font='12px Orbitron'; ctx.fillText(`RESPAWN: ${sec}s`, this.x - cX, this.y - cY);
                return;
            }
            ctx.save(); ctx.translate(this.x - cX, this.y - cY);
            
            // INVISIBILITY VISUAL FOR MAGE
            if(this.invisibleTimer > 0) ctx.globalAlpha = 0.3;

            if(this.immuneTimer > 0) {
                 ctx.save();
                 ctx.globalAlpha = (this.invisibleTimer > 0 ? 0.3 : 1) * (0.4 + Math.sin(state.frames*0.5)*0.2);
                 ctx.fillStyle = '#00f3ff';
                 ctx.beginPath(); ctx.arc(0,0, 35, 0, 6.28); ctx.fill();
                 ctx.strokeStyle = '#fff'; ctx.lineWidth=2; ctx.stroke();
                 ctx.restore();
            }
            if(this.taunting) {
                ctx.strokeStyle = '#ff003c'; ctx.lineWidth = 3;
                ctx.beginPath(); ctx.arc(0,0, 40 + Math.sin(state.frames*0.5)*10, 0, 6.28); ctx.stroke();
            }
            if(this.type === 'soldier' || this.type === 'titan' || this.type === 'vanguard') {
                 ctx.fillStyle = '#eee'; ctx.beginPath(); ctx.arc(0,0,15,0,6.28); ctx.fill();
                 ctx.fillStyle = '#00f'; ctx.fillRect(-10, 5, 20, 15); 
                 let swordSize = this.type==='titan' || this.isBerserk ? 30 : 20;
                 ctx.fillStyle = '#aaa'; ctx.beginPath(); ctx.moveTo(10,0); ctx.lineTo(10+swordSize, -5); ctx.lineTo(10+swordSize, 5); ctx.fill();
                 if(this.type === 'vanguard') { ctx.fillStyle = '#448'; ctx.fillRect(-20, -10, 8, 20); }
            }
            else if (this.type === 'defender') {
                 ctx.fillStyle = '#889'; ctx.beginPath(); ctx.arc(0,0,18,0,6.28); ctx.fill();
                 ctx.fillStyle = '#224'; ctx.fillRect(-15, -20, 30, 40); 
                 ctx.strokeStyle = '#fff'; ctx.strokeRect(-15, -20, 30, 40);
            }
            else if (this.type === 'mage') {
                 ctx.fillStyle = '#d000ff'; ctx.beginPath(); ctx.moveTo(0,-20); ctx.lineTo(-15,10); ctx.lineTo(15,10); ctx.fill();
                 ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(0,-25, 5, 0, 6.28); ctx.fill();
            }
            ctx.fillStyle = 'red'; ctx.fillRect(-20, -35, 40, 6);
            ctx.fillStyle = '#0f0'; ctx.fillRect(-20, -35, 40 * (this.durability/this.maxDurability), 6);
            ctx.fillStyle = '#fff'; ctx.font='bold 10px Arial'; ctx.textAlign='center';
            ctx.fillText(this.durability + "/" + this.maxDurability, 0, -40);
            ctx.restore();
        }
    }

    class Perk {
        constructor(x,y,type){
            this.x=x; this.y=y; this.type=type; this.bob=0;
            if(type==='health') this.icon='‚ù§Ô∏è';
            else if(type==='magnet') this.icon='üß≤';
            else if(type==='nuke') this.icon='‚ò¢Ô∏è';
            else if(type==='freeze') this.icon='‚ùÑÔ∏è';
        }
        update(){
            this.bob+=0.1; 
            const dx=player.x-this.x, dy=player.y-this.y, dist=Math.sqrt(dx*dx+dy*dy);
            if(dist < player.radius + 30){
                if(this.type==='health'){ player.hp = Math.min(player.maxHp, player.hp+50); spawnDamageText(player.x,player.y-50,"HEALED",true); for(let i=0;i<10;i++)createParticle(this.x,this.y,'#f00','spark');}
                if(this.type==='magnet'){ state.gems.forEach(g=>g.vacuum=true); spawnDamageText(player.x,player.y-50,"MAGNETIC",true);}
                if(this.type==='nuke'){ 
                    addShake(30); state.flashAlpha=0.8;
                    state.enemies.forEach(e=>{ 
                        if(!e.dead && e.type !== 'BOSS' && e.type !== 'MINI_BOSS'){ e.takeDamage(9999, true); } 
                        else if(e.type === 'BOSS') { spawnDamageText(e.x, e.y-50, "IMMUNE", false); }
                    }); 
                    spawnDamageText(player.x,player.y-50,"NUKE",true); for(let i=0;i<50;i++)createParticle(player.x,player.y,'#ffaa00','fire',5); 
                }
                if(this.type==='freeze'){ 
                    state.enemies.forEach(e=>{ 
                        if(e.type !== 'BOSS') e.frozen=300; 
                        else spawnDamageText(e.x, e.y-50, "IMMUNE", false);
                    }); 
                    spawnDamageText(player.x,player.y-50,"FROZEN",true); for(let i=0;i<20;i++)createParticle(player.x,player.y,'#00ffff','spark',2); 
                }
                updateHud();
                return true; 
            }
            return false;
        }
        draw(cX,cY){
            let yOff = Math.sin(this.bob)*5;
            ctx.font="30px Arial"; ctx.textAlign="center"; ctx.textBaseline="middle"; 
            ctx.fillText(this.icon, this.x-cX, this.y-cY + yOff);
            ctx.beginPath(); ctx.arc(this.x-cX, this.y-cY+yOff, 20, 0, 6.28);
            ctx.strokeStyle=`rgba(255,255,255,${0.5+Math.sin(this.bob)*0.3})`; ctx.lineWidth=2; ctx.stroke();
        }
    }

    class Gem {
        constructor(x,y, val=0){this.x=x;this.y=y;this.value=val>0?val:(5+(state.level*0.8));this.wobble=Math.random()*6.28;this.vacuum=false;this.size=val>100?10:4;this.color=val>100?'#00f3ff':'#fecb00';}
        update(){
            this.wobble+=0.1; const dx=player.x-this.x, dy=player.y-this.y, dist=Math.sqrt(dx*dx+dy*dy);
            if(this.vacuum || dist<player.magnetRadius){
                let speed = this.vacuum ? 25 : 18;
                this.x+=(dx/dist)*speed;this.y+=(dy/dist)*speed;
            }
            if(dist<player.radius+20){state.xp+=this.value * state.xpMult; checkLevelUp();updateHud();return true;} return false;
        }
        draw(cX,cY){
            ctx.fillStyle=this.color; 
            ctx.beginPath();
            ctx.translate(this.x-cX, this.y-cY);
            ctx.rotate(this.wobble);
            ctx.rect(-this.size/2, -this.size/2, this.size, this.size);
            ctx.fill(); 
            ctx.rotate(-this.wobble); ctx.translate(-(this.x-cX), -(this.y-cY));
        }
    }

    class Beam {
        constructor(x, y, angle) {
            this.x = x; this.y = y; this.angle = angle;
            this.life = 15; this.maxLife = 15; this.length = 1200;
        }
        update() { this.life--; return this.life > 0; }
        draw(cX, cY) {
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            const opacity = this.life / this.maxLife;
            ctx.strokeStyle = `rgba(255, 255, 255, ${opacity})`;
            ctx.lineWidth = 40 * opacity;
            ctx.beginPath();
            ctx.moveTo(this.x - cX, this.y - cY);
            ctx.lineTo((this.x - cX) + Math.cos(this.angle) * this.length, (this.y - cY) + Math.sin(this.angle) * this.length);
            ctx.stroke();
            ctx.strokeStyle = `rgba(255, 100, 0, ${opacity*0.5})`;
            ctx.lineWidth = 120 * opacity;
            ctx.stroke();
            ctx.restore();
        }
    }

    class Projectile {
        constructor(x,y,target,type){
            this.x=x;this.y=y;this.type=type;this.life=150;this.rotation=0;
            this.pierceHitList = [];
            this.overrideDamage = 0;

            if(type === 'boss_missile') {
                let a = Math.atan2(target.y-y, target.x-x);
                this.speed = 12; // Fast
                this.radius = 15;
                this.vx = Math.cos(a)*this.speed;
                this.vy = Math.sin(a)*this.speed;
                return;
            }

            let a=target?Math.atan2(target.y-y,target.x-x):Math.random()*6.28;
            if(type==='cevapi'){this.speed=14;this.radius=8;} 
            else if(type==='ajvar'){this.speed=8;this.radius=10;}
            else if(type==='rakija'){this.speed=10;this.radius=8;} 
            else if(type==='pyramid'){this.speed=7;this.radius=25;this.life=300;this.pierce=true;}
            this.vx=Math.cos(a)*this.speed; this.vy=Math.sin(a)*this.speed;
        }
        update(){
            this.x+=this.vx;this.y+=this.vy;this.life--;this.rotation+=0.15;
            
            if(this.type === 'boss_missile') {
                 createParticle(this.x, this.y, '#ff003c', 'spark', 0.5);
                 return;
            }

            if(state.frames%2===0){ 
                if(this.type==='pyramid')createParticle(this.x,this.y,'#2ecc71','spark',0.1); 
                if(this.type==='cevapi')createParticle(this.x,this.y,'#8b4513','smoke',0.2); 
            }
            if(this.type==='ajvar'||this.type==='rakija'){ this.vx*=0.96;this.vy*=0.96;this.rotation=this.vx*0.2; if(this.life<100 && Math.abs(this.vx)<1)this.explode(); }
        }
        explode(){
            this.life=0; 
            if(this.type==='ajvar'){ 
                addShake(15); 
                let dmg=calcDamage(player.weapons.ajvar.damage); 
                state.enemies.forEach(e=>{if(Math.hypot(e.x-this.x,e.y-this.y)<150)e.takeDamage(dmg.d, dmg.c)}); 
                for(let i=0;i<40;i++)createParticle(this.x,this.y,'#ff4500','fire',2.5); 
                state.zones.push(new Zone(this.x, this.y, 'blast', 20));
            }
            if(this.type==='rakija'){ state.zones.push(new Zone(this.x,this.y,'fire',player.weapons.rakija.duration)); for(let i=0;i<20;i++)createParticle(this.x,this.y,'#00ffff','fire',1.5); }
        }
        draw(cX,cY){
            ctx.save(); ctx.translate(this.x-cX,this.y-cY); ctx.rotate(this.rotation);
            if(this.type==='boss_missile'){
                 ctx.fillStyle='#000'; ctx.beginPath(); ctx.arc(0,0,8,0,6.28); ctx.fill();
                 ctx.strokeStyle='#ff003c'; ctx.lineWidth=4; ctx.beginPath(); ctx.arc(0,0,8,0,6.28); ctx.stroke();
            }
            else if(this.type==='cevapi'){ 
                for(let i=-1;i<=1;i++) {
                    ctx.fillStyle='#6d4c41'; ctx.beginPath(); ctx.roundRect(-8, i*5-2, 16, 4, 2); ctx.fill();
                    ctx.fillStyle='#3e2723'; ctx.fillRect(-4, i*5-2, 2, 4); ctx.fillRect(2, i*5-2, 2, 4);
                }
            }
            else if(this.type==='ajvar'){ 
                ctx.fillStyle='#c0392b';ctx.beginPath();ctx.arc(0,0,10,0,6.28);ctx.fill();
                ctx.fillStyle='#f1c40f';ctx.beginPath();ctx.arc(0,-6,6,0,6.28);ctx.fill();
                ctx.fillStyle='white';ctx.font="10px Arial";ctx.textAlign="center";ctx.textBaseline="middle";ctx.fillText("HOT",0,2);
            }
            else if(this.type==='rakija'){ 
                ctx.rotate(-this.rotation); ctx.rotate(Math.sin(state.frames*0.2)*0.5); 
                ctx.fillStyle='rgba(200,240,255,0.6)'; ctx.beginPath(); ctx.rect(-5,-10,10,20); ctx.fill();
                ctx.fillStyle='#002395'; ctx.fillRect(-5, -5, 10, 8); 
                ctx.fillStyle='#aaa'; ctx.fillRect(-3, -14, 6, 4); 
            }
            else if(this.type==='pyramid'){ 
                ctx.fillStyle='#00ff00';
                ctx.beginPath();ctx.moveTo(0,-20);ctx.lineTo(15,15);ctx.lineTo(-15,15);ctx.fill();
                ctx.fillStyle='#fff';ctx.globalCompositeOperation='lighter';
                ctx.beginPath();ctx.arc(0,0,5,0,6.28);ctx.fill();
            }
            ctx.restore();
        }
    }
    class Zone {
        constructor(x,y,type,dur,overrideDamage=0){this.x=x;this.y=y;this.life=dur;this.maxLife=dur;this.radius=90;this.type=type;this.overrideDamage=overrideDamage;if(type==='blast') this.radius=120; if(type==='valk_swing') this.radius=160; if(type==='flame_trail') this.radius=50; if(type==='spike_burst') this.radius=30;}
        update(){ 
            this.life--; 
            if(this.type==='blast' || this.type==='valk_swing' || this.type==='shield_push' || this.type==='taunt_ring' || this.type==='spike_burst') return this.life<=0;

            if(this.type==='berserk_spin') {
                if(this.life % 10 === 0) { 
                    let dmg = this.overrideDamage;
                    state.enemies.forEach(e => {
                         if(Math.hypot(e.x - this.x, e.y - this.y) < 160) {
                             e.takeDamage(dmg, true, 'berserk');
                             createParticle(e.x, e.y, '#f00', 'blood', 1);
                         }
                    });
                }
                let unit = state.friendlyUnits.find(u => u.isBerserk);
                if(unit) { this.x = unit.x; this.y = unit.y; }
                return this.life<=0;
            }

            if(this.type==='flame_trail') {
                 if(state.frames % 10 === 0) {
                     state.enemies.forEach(e => {
                         if(Math.hypot(e.x-this.x, e.y-this.y) < this.radius) {
                             let baseDmg = player.weapons.burek.damage * 0.25; 
                             let dmg = calcDamage(Math.max(1, baseDmg));
                             e.takeDamage(dmg.d, false, 'flame_trail');
                             createParticle(e.x, e.y, '#ff5e00', 'spark', 0.5);
                         }
                     });
                 }
                 if(state.frames % 5 === 0) createParticle(this.x + (Math.random()-0.5)*40, this.y + (Math.random()-0.5)*40, '#ff5e00', 'fire', 1.0);
            }
            else if(this.type==='fire' && state.frames%10===0) state.enemies.forEach(e=>{if(Math.hypot(e.x-this.x,e.y-this.y)<this.radius){
                let dmg = calcDamage(player.weapons.rakija.damage);
                e.takeDamage(dmg.d, false, 'zone');
                createParticle(e.x,e.y,'#00ffff','fire',0.5);
            }}); 
            return this.life<=0;
        }
        draw(cX,cY){ 
            if(this.type === 'spike_burst') {
                ctx.save(); ctx.translate(this.x-cX, this.y-cY);
                
                // VISIBILITY UPGRADE
                let p = this.life/this.maxLife;
                ctx.scale(1.5, 1.5); 
                
                let grad = ctx.createLinearGradient(0, 10, 0, -50);
                grad.addColorStop(0, '#555');
                grad.addColorStop(0.5, '#aaa');
                grad.addColorStop(1, '#ff003c'); // Blood red tip

                ctx.fillStyle = grad;
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1;

                ctx.beginPath();
                // Draw 3 Spikes, sharper
                ctx.moveTo(0, -50 * p); ctx.lineTo(8, 0); ctx.lineTo(-8, 0);
                ctx.moveTo(-15, -40 * p); ctx.lineTo(-5, 5); ctx.lineTo(-25, 5);
                ctx.moveTo(15, -40 * p); ctx.lineTo(25, 5); ctx.lineTo(5, 5);
                ctx.fill();
                ctx.stroke();

                ctx.restore();
                return;
            }
            if(this.type === 'flame_trail') {
                ctx.save(); ctx.translate(this.x-cX, this.y-cY);
                let p = this.life/this.maxLife;
                ctx.globalAlpha = p;
                let g = ctx.createRadialGradient(0,0,10,0,0,this.radius);
                g.addColorStop(0, '#ffcc00'); g.addColorStop(1, 'rgba(255,0,0,0)');
                ctx.fillStyle = g;
                ctx.beginPath(); ctx.arc(0,0,this.radius,0,6.28); ctx.fill();
                ctx.restore();
                return;
            }
            if(this.type === 'shield_push') {
                ctx.save(); ctx.translate(this.x-cX, this.y-cY);
                let p = 1 - (this.life/this.maxLife);
                ctx.strokeStyle = `rgba(255, 255, 255, ${1-p})`;
                ctx.lineWidth = 10;
                ctx.beginPath(); ctx.arc(0,0, player.weapons.harmonika.range * 1.5 * p, 0, 6.28); ctx.stroke();
                ctx.restore();
                return;
            }
            if(this.type === 'taunt_ring') {
                 return;
            }
            if(this.type === 'valk_swing' || this.type === 'berserk_spin') {
                 ctx.save(); 
                 ctx.translate(this.x-cX, this.y-cY);
                 
                 let progress = 1 - (this.life / this.maxLife); 
                 if(this.type === 'berserk_spin') progress = (state.frames * 0.5) % 6.28; 
                 else progress = progress * Math.PI * 2;
                 
                 let angle = progress;
                 if(this.type === 'valk_swing') {
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius, angle - 1, angle, false);
                    ctx.lineWidth = 40;
                    ctx.strokeStyle = `rgba(255, 255, 255, ${0.5 * (this.life/this.maxLife)})`;
                    ctx.stroke();
                 }

                 ctx.rotate(angle);
                 ctx.translate(20, 0); 
                 
                 let grad = ctx.createLinearGradient(0,0, 100, 0);
                 grad.addColorStop(0, '#aaa'); grad.addColorStop(1, '#fff');
                 ctx.fillStyle = grad;
                 ctx.beginPath(); ctx.moveTo(0, -5); ctx.lineTo(120, 0); ctx.lineTo(0, 5); ctx.fill();
                 ctx.fillStyle = '#444'; ctx.fillRect(-5, -15, 10, 30);
                 ctx.fillStyle = '#654321'; ctx.fillRect(-25, -4, 20, 8);

                 ctx.restore();
                 return;
            }
            if(this.type === 'blast') {
                 ctx.save(); ctx.translate(this.x-cX, this.y-cY);
                 ctx.globalCompositeOperation = 'lighter';
                 ctx.fillStyle = `rgba(255, 100, 0, ${this.life/20})`;
                 ctx.beginPath(); ctx.arc(0,0,this.radius*(1-this.life/20), 0, 6.28); ctx.fill();
                 ctx.restore();
                 return;
            }
            ctx.save();ctx.translate(this.x-cX,this.y-cY); let p=1+Math.sin(state.frames*0.1)*0.1; ctx.scale(p,p); 
            let g=ctx.createRadialGradient(0,0,10,0,0,this.radius);
            g.addColorStop(0,'rgba(0,255,255,0.4)');g.addColorStop(1,'rgba(0,50,255,0)');
            ctx.globalCompositeOperation='lighter';ctx.fillStyle=g;ctx.beginPath();ctx.arc(0,0,this.radius,0,6.28);ctx.fill();ctx.restore();
        }
    }
    
    class Enemy {
        constructor(overrideType=null, x=null, y=null){
            if(overrideType === 'BOSS' || overrideType === 'MINI_BOSS') {
                 this.type = overrideType;
                 let a=Math.random()*6.28, d=(Math.max(W,H)/2)+200; 
                 if(x!==null && y!==null) { this.x=x; this.y=y; }
                 else { this.x=player.x+Math.cos(a)*d; this.y=player.y+Math.sin(a)*d; }
            } else {
                 if(x !== null && y !== null) {
                     this.x = x; this.y = y;
                 } else {
                     let a=Math.random()*6.28, d=(Math.max(W,H)/2)+150; 
                     this.x=player.x+Math.cos(a)*d; this.y=player.y+Math.sin(a)*d;
                 }
                 this.type = overrideType || 'promaja';
            }
            
            // --- INFERNO UPDATE SCALING ---
            // BOSS HP FIXED AT 5000 NO MATTER WHAT
            if (this.type === 'BOSS') {
                this.maxHp = 5000;
                this.hp = 5000;
            } else {
                let baseHp = 40;
                // --- NERFED EARLY GAME HP ---
                // Promaja starts much weaker (25 instead of 40)
                if(this.type==='promaja') baseHp = 25 + state.level*1; 
                else if(this.type==='yugo') baseHp = 180 + state.level*8;
                else if(this.type==='hornet') baseHp = 20 + state.level*1;
                else if(this.type==='MINI_BOSS') baseHp = 800 + state.level*100;

                const minutes = state.gameTime / 60;
                
                if (minutes < 5) {
                    // NERFED SCALING: Only +8 HP per minute (was +25)
                    this.maxHp = baseHp + (minutes * 8);
                } else if (minutes < 10) {
                    // HARD MODE KICK IN: Jump to 1.5x
                    let hardBase = baseHp * 1.5;
                    this.maxHp = hardBase * (1 + minutes * 0.25);
                } else {
                    // INFERNO
                    this.maxHp = baseHp * (1 + Math.pow(minutes, 0.9) * 0.3);
                }
                this.hp = this.maxHp;
            }
            
            if(this.type==='BOSS') {
                this.baseSpeed=2.5; this.radius=60; 
                this.frozen=0; this.hitFlash=0; this.pushX=0; this.pushY=0;
                this.attackTimer = 150; this.damageCooldown = 0;
            } 
            else if(this.type==='MINI_BOSS') {
                this.baseSpeed=2.2; this.radius=45;
                this.frozen=0; this.hitFlash=0; this.pushX=0; this.pushY=0;
                this.attackTimer = 200; this.damageCooldown = 0;
            }
            else {
                // NERFED SPEED FOR EARLY ENEMIES
                if(this.type==='promaja'){this.baseSpeed=1.8+Math.random();this.radius=22;} 
                else if(this.type==='yugo'){this.baseSpeed=1.4;this.radius=35;this.angle=0;} 
                else if(this.type==='hornet'){this.baseSpeed=4.2;this.radius=15;}
                this.hitFlash=0; this.pushX=0; this.pushY=0; this.frozen=0;
            }
            this.speed = this.baseSpeed;
            this.burnTimer = 0; 
            this.burekHitTimer = 0;
        }
        update(){
            if(this.type === 'BOSS') {
                document.getElementById('boss-bar-fill').style.width = (this.hp/this.maxHp*100)+'%';
            }
            
            if(this.burekHitTimer > 0) this.burekHitTimer--;

            if(this.burnTimer > 0) {
                this.burnTimer--;
                if(state.frames % 15 === 0) {
                    this.takeDamage(5, false, 'burn'); 
                    createParticle(this.x, this.y, '#ff5e00', 'fire', 0.5);
                }
            }

            if((this.type === 'BOSS' || this.type === 'MINI_BOSS')) {
                if(this.damageCooldown > 0) this.damageCooldown--;
                this.attackTimer--;
                if(this.attackTimer === 30) {
                     spawnDamageText(this.x, this.y - 80, "!!!", false);
                     createParticle(this.x, this.y, '#f00', 'plasma', 5);
                }
                if(this.attackTimer <= 0) {
                    this.attackTimer = this.type==='BOSS' ? 150 : 200; 
                    state.projectiles.push(new Projectile(this.x, this.y, player, 'boss_missile'));
                }
            }

            if(this.frozen > 0) { 
                this.frozen--; 
                if(state.frames%20===0) createParticle(this.x,this.y,'#0ff','spark');
                return;
            }
            
            // TARGETING LOGIC
            let targetX = player.x, targetY = player.y;

            let taunter = state.friendlyUnits.find(u => u.taunting && !u.dead);
            if(taunter) {
                targetX = taunter.x; targetY = taunter.y;
            } else {
                let closestFriendly = null;
                let minFD = 999;
                state.friendlyUnits.forEach(u => {
                    if(!u.dead) {
                        // Mage is less visible when invisible
                        if(u.type === 'mage' && u.invisibleTimer > 0) return;

                        let d = Math.hypot(u.x - this.x, u.y - this.y);
                        if(d < minFD) { minFD = d; closestFriendly = u; }
                    }
                });

                if(closestFriendly) {
                    let dPlayer = Math.hypot(player.x - this.x, player.y - this.y);
                    if(minFD < dPlayer && dPlayer > 120) {
                        targetX = closestFriendly.x; targetY = closestFriendly.y;
                    }
                    if(minFD < closestFriendly.radius + this.radius) {
                        let ang = Math.atan2(this.y - closestFriendly.y, this.x - closestFriendly.x);
                        this.x = closestFriendly.x + Math.cos(ang) * (closestFriendly.radius + this.radius);
                        this.y = closestFriendly.y + Math.sin(ang) * (closestFriendly.radius + this.radius);
                    }
                }
            }

            let dx=targetX-this.x, dy=targetY-this.y, dist=Math.sqrt(dx*dx+dy*dy); this.angle=Math.atan2(dy,dx);
            
            let px=0,py=0; 
            if(this.type !== 'BOSS' && this.type !== 'MINI_BOSS') {
                state.enemies.forEach(o=>{if(o!==this){let ox=this.x-o.x,oy=this.y-o.y,od=Math.sqrt(ox*ox+oy*oy);if(od<this.radius+o.radius){px+=ox/od;py+=oy/od;}}});
            }

            this.x+=(Math.cos(this.angle)*this.speed+px*0.5)+this.pushX; this.y+=(Math.sin(this.angle)*this.speed+py*0.5)+this.pushY; 
            this.pushX*=0.9; this.pushY*=0.9; if(this.hitFlash>0)this.hitFlash--;
            if(this.type==='yugo'&&state.frames%5===0)createParticle(this.x-Math.cos(this.angle)*35,this.y-Math.sin(this.angle)*35,'#333','smoke', 0.5);
        }
        
        takeDamage(a, crit, source){
            if(this.type === 'BOSS' || this.type === 'MINI_BOSS') {
                if(this.damageCooldown > 0) return; 
                this.damageCooldown = 5; 
            }

            this.hp-=a; this.hitFlash=5; spawnDamageText(this.x,this.y-30,a,crit); 
            let c=(this.type==='yugo')?'#000':(this.type==='hornet'?'#bfff00':'#880000'); 
            if(this.type==='BOSS' || this.type==='MINI_BOSS') c='#ff00ff';
            for(let i=0;i<3;i++)createParticle(this.x,this.y,c,'spark');
            
            if(this.hp<=0){ 
                this.dead=true; state.score++; 
                if(this.type==='BOSS'){
                     state.bossActive = false;
                     document.getElementById('boss-hud').style.display='none';
                     addShake(50); state.flashAlpha=1;
                     spawnDamageText(this.x, this.y-100, "WARLORD DEFEATED", true);
                     for(let i=0; i<30; i++) state.gems.push(new Gem(this.x + (Math.random()-0.5)*200, this.y + (Math.random()-0.5)*200, 150));
                } 
                else if(this.type==='MINI_BOSS') {
                     spawnDamageText(this.x, this.y-80, "MINI BOSS DOWN", true);
                     for(let i=0; i<10; i++) state.gems.push(new Gem(this.x + (Math.random()-0.5)*100, this.y + (Math.random()-0.5)*100, 100));
                }
                else {
                     state.gems.push(new Gem(this.x,this.y)); 
                }
                for(let i=0;i<8;i++)createParticle(this.x,this.y,c,'blood',1.5); 
                if(this.type==='yugo' || this.type==='BOSS'){addShake(5);for(let i=0;i<15;i++)createParticle(this.x,this.y,'#f39c12','fire',2);} 
            }
        }
        draw(cX,cY){
            ctx.save(); ctx.translate(this.x-cX,this.y-cY);
            
            if(this.hitFlash>0){ 
                ctx.globalCompositeOperation='lighter'; ctx.fillStyle='#fff';
                ctx.beginPath();ctx.arc(0,0,this.radius,0,6.28);ctx.fill();
            } else {
                if(this.type==='BOSS' || this.type==='MINI_BOSS'){
                    ctx.rotate(state.frames*0.02);
                    let scale = this.type==='BOSS' ? 1 : 0.6;
                    ctx.scale(scale, scale);
                    ctx.strokeStyle='#ff003c'; ctx.lineWidth=4;
                    ctx.beginPath(); ctx.moveTo(-30,-30); ctx.lineTo(30,-30); ctx.lineTo(0,30); ctx.closePath(); ctx.stroke();
                    ctx.fillStyle='#300'; ctx.fill();
                    ctx.fillStyle='#f00'; ctx.beginPath(); ctx.arc(0,0,10,0,6.28); ctx.fill();
                }
                else if(this.type==='promaja'){ 
                    ctx.rotate(state.frames*0.2); 
                    ctx.shadowBlur = 10; ctx.shadowColor = 'rgba(200, 255, 255, 0.5)';
                    ctx.strokeStyle = 'rgba(220, 240, 255, 0.8)'; ctx.lineWidth = 2;
                    ctx.beginPath(); ctx.arc(0, 0, 8, 0, 5); ctx.stroke();
                    ctx.rotate(2); ctx.beginPath(); ctx.arc(0, 0, 16, 0, 4.5); ctx.stroke();
                    ctx.rotate(2); ctx.strokeStyle = 'rgba(220, 240, 255, 0.4)'; ctx.beginPath(); ctx.arc(0, 0, 24, 0, 3); ctx.stroke();
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)'; ctx.beginPath(); ctx.arc(0,0,4,0,6.28); ctx.fill();
                }
                else if(this.type==='yugo'){ 
                    ctx.rotate(this.angle);
                    ctx.fillStyle='#800000'; ctx.fillRect(-20,-15,40,30);
                    ctx.fillStyle='#300000'; ctx.fillRect(-5,-13,20,26);
                    ctx.globalCompositeOperation = 'lighter'; ctx.fillStyle='rgba(255, 255, 200, 0.4)';
                    ctx.beginPath(); ctx.moveTo(20,-10); ctx.lineTo(120,-30); ctx.lineTo(120,30); ctx.lineTo(20,10); ctx.fill();
                    ctx.fillStyle='#ff0'; ctx.fillRect(18,-12,4,6); ctx.fillRect(18,6,4,6);
                }
                else{ 
                    ctx.rotate(this.angle+1.57);
                    ctx.fillStyle='rgba(255,255,255,0.6)'; 
                    let flap = Math.sin(state.frames*0.8)*5;
                    ctx.beginPath(); ctx.ellipse(8+flap, -5, 5, 12, 0.5, 0, 6.28); ctx.fill();
                    ctx.beginPath(); ctx.ellipse(-8-flap, -5, 5, 12, -0.5, 0, 6.28); ctx.fill();
                    ctx.fillStyle='#f1c40f';
                    ctx.beginPath(); ctx.ellipse(0, 0, 8, 14, 0, 0, 6.28); ctx.fill();
                    ctx.fillStyle='#000'; ctx.fillRect(-6, -2, 12, 2); ctx.fillRect(-6, 4, 12, 2);
                    ctx.fillStyle='#f00'; ctx.beginPath(); ctx.moveTo(0,14); ctx.lineTo(2,20); ctx.lineTo(-2,20); ctx.fill();
                }
            } 
            if(this.frozen>0){ ctx.fillStyle='rgba(0,255,255,0.4)';ctx.beginPath();ctx.arc(0,0,this.radius+5,0,6.28);ctx.fill();}
            if(this.burnTimer>0) { ctx.fillStyle='rgba(255, 100, 0, 0.5)'; ctx.beginPath(); ctx.arc(0,0,this.radius+5,0,6.28); ctx.fill(); }
            ctx.restore();
        }
    }

    function checkLevelUp(){ 
        if(state.xp>=state.nextLevelXp){
            state.xp-=state.nextLevelXp;
            state.level++;
            player.maxHp += 10; player.hp += 10;
            spawnDamageText(player.x, player.y-60, "+10 HP", true);
            state.nextLevelXp = Math.floor(state.nextLevelXp + 50 + (state.level * 25));
            isPaused = true;
            generateCards();
        } 
    }
    
    function spawnBoss(){
        if(state.bossActive) return;
        state.bossActive = true;
        state.enemies = state.enemies.filter(e => e.type === 'MINI_BOSS'); 
        state.flashAlpha = 1.0;
        addShake(50);
        document.getElementById('boss-hud').style.display = 'flex';
        state.enemies.push(new Enemy('BOSS'));
    }

    function updateHud(){ 
        document.getElementById('lvl-display').innerText=state.level; 
        document.getElementById('score-display').innerText=state.score; 
        document.getElementById('xp-fill').style.width=Math.min(100,(state.xp/state.nextLevelXp*100))+'%'; 
        document.getElementById('hp-fill').style.width=Math.max(0,(player.hp/player.maxHp*100))+'%'; 
        
        let m = Math.floor(state.gameTime / 60);
        let s = Math.floor(state.gameTime % 60);
        document.getElementById('timer-display').innerText = 
            (m < 10 ? "0"+m : m) + ":" + (s < 10 ? "0"+s : s);
    }
    
    function gameLoop(){ 
        if(gameActive && !isPaused){ update(); draw(); } 
        else if(!gameActive) {
            ctx.fillStyle='#050510'; ctx.fillRect(0,0,W,H);
            state.backgroundStars.forEach(s => {
                s.x -= 0.2; if(s.x < 0) s.x = W;
                ctx.fillStyle = `rgba(255,255,255,${s.alpha})`; ctx.fillRect(s.x, s.y, s.size, s.size);
            });
        }
        requestAnimationFrame(gameLoop); 
    }
    
    function getClosestEnemy(){ let c=null,m=800; state.enemies.forEach(e=>{let d=Math.hypot(e.x-player.x,e.y-player.y);if(d<m){m=d;c=e;}}); return c; }

    function spawnPerk() {
        let chance = 0.0008 * player.luck;
        if(Math.random() > chance) return;
        const types = ['health', 'magnet', 'nuke', 'freeze'];
        let dist = 300 + Math.random() * 400; 
        let ang = Math.random() * 6.28;
        state.perks.push(new Perk(player.x+Math.cos(ang)*dist, player.y+Math.sin(ang)*dist, types[Math.floor(Math.random() * types.length)]));
    }

    function lineCircleCollide(px,py, ax,ay, bx,by, r) {
        const vX = bx-ax, vY = by-ay; const wX = px-ax, wY = py-ay;
        const c1 = wX*vX + wY*vY;
        if(c1 <= 0) return Math.hypot(px-ax, py-ay) < r;
        const c2 = vX*vX + vY*vY;
        if(c2 <= c1) return Math.hypot(px-bx, py-by) < r;
        const b = c1/c2; const projX = ax + b*vX, projY = ay + b*vY;
        return Math.hypot(px-projX, py-projY) < r;
    }

    function spawnCircle(type, count) {
        for(let i=0; i<count; i++){
            let angle = (i / count) * 6.28;
            let dist = 800;
            state.enemies.push(new Enemy(type, player.x + Math.cos(angle) * dist, player.y + Math.sin(angle) * dist));
        }
        spawnDamageText(player.x, player.y-100, "‚ö†Ô∏è SWARM DETECTED ‚ö†Ô∏è", false);
    }

    function handleWaves() {
        let t = state.gameTime;
        if(t < 300) {
            // NERFED SPAWN RATES FOR EARLY GAME
            if(t < 60) {
                // Was 50, now 90 (approx 1.5 seconds)
                if(state.frames % 90 === 0) state.enemies.push(new Enemy('promaja'));
            } 
            else if(t < 120) {
                // Was 40, now 60 (1 second)
                if(state.frames % 60 === 0) state.enemies.push(new Enemy('promaja'));
                if(state.frames % 90 === 0) state.enemies.push(new Enemy('hornet'));
            }
            else if(t < 180) {
                if(t === 120 && state.frames % 60 === 0) spawnCircle('promaja', 30);
                if(state.frames % 30 === 0) state.enemies.push(new Enemy('promaja'));
                if(state.frames % 60 === 0) state.enemies.push(new Enemy('hornet'));
                if(state.frames % 120 === 0) state.enemies.push(new Enemy('yugo'));
            }
            else if(t < 240) {
                if(state.frames % 20 === 0) state.enemies.push(new Enemy('promaja'));
                if(state.frames % 40 === 0) state.enemies.push(new Enemy('hornet'));
                if(state.frames % 90 === 0) state.enemies.push(new Enemy('yugo'));
            }
            else if(t < 300) {
                if(t === 240 && state.frames % 60 === 0) spawnCircle('yugo', 20);
                if(state.frames % 10 === 0) state.enemies.push(new Enemy(Math.random()<0.5?'promaja':'hornet'));
                if(state.frames % 60 === 0) state.enemies.push(new Enemy('yugo'));
            }
        } 
        else if (t >= 300) {
            if(!state.bossSpawnedOnce) {
                spawnBoss();
                state.bossSpawnedOnce = true;
            }
            if(state.bossActive) {
                if(state.frames % 100 === 0) state.enemies.push(new Enemy('promaja'));
                if(state.frames % 200 === 0) state.enemies.push(new Enemy('hornet'));
            } 
            else {
                if(state.frames % 15 === 0) state.enemies.push(new Enemy(Math.random()<0.5?'promaja':'hornet'));
                if(state.frames % 50 === 0) state.enemies.push(new Enemy('yugo'));
                if(state.frames % 600 === 0) {
                    if(Math.random() < 0.05) state.enemies.push(new Enemy('MINI_BOSS'));
                }
            }
        }
    }

    function update(){
        if(state.flashAlpha > 0) state.flashAlpha -= 0.02;

        let mx=0,my=0; if(keys['w']||keys['arrowup'])my=-1; if(keys['s']||keys['arrowdown'])my=1; if(keys['a']||keys['arrowleft'])mx=-1; if(keys['d']||keys['arrowright'])mx=1;
        if(mx!==0||my!==0){ 
            let l=Math.sqrt(mx*mx+my*my); 
            player.x+=(mx/l)*player.speed; 
            player.y+=(my/l)*player.speed; 
            player.facing = Math.atan2(my, mx); 
        }

        if(player.regen>0 && state.frames%60===0 && player.hp<player.maxHp){ player.hp=Math.min(player.maxHp, player.hp+player.regen); updateHud(); spawnDamageText(player.x,player.y-50,player.regen,true); }

        if(state.frames % 60 === 0) {
            state.gameTime++;
            updateHud();
        }

        handleWaves();
        spawnPerk();

        state.friendlyUnits.forEach(u => u.update());

        const wc=player.weapons.cevapi; if(wc.level>0){ wc.timer++; if(wc.timer>wc.cooldown){let t=getClosestEnemy();if(t){state.projectiles.push(new Projectile(player.x,player.y,t,'cevapi'));wc.timer=0;}} }
        const wa=player.weapons.ajvar; if(wa.level>0){ wa.timer++; if(wa.timer>wa.cooldown&&state.enemies.length>0){let ts=state.enemies.filter(e=>Math.hypot(e.x-player.x,e.y-player.y)<700);if(ts.length){state.projectiles.push(new Projectile(player.x,player.y,ts[Math.floor(Math.random()*ts.length)],'ajvar'));wa.timer=0;}} }
        const wr=player.weapons.rakija; if(wr.level>0){ wr.timer++; if(wr.timer>wr.cooldown){let t=getClosestEnemy();if(t){state.projectiles.push(new Projectile(player.x,player.y,t,'rakija'));wr.timer=0;}} }
        
        // --- IMPALER SPIKES: COOLDOWN 3 SECONDS (180 frames) ---
        const ws = player.weapons.spike;
        if(ws.level > 0) {
            ws.timer++;
            if(ws.timer > ws.cooldown && state.enemies.length > 0) {
                // Find 3 strongest
                let targets = state.enemies.sort((a,b) => b.hp - a.hp).slice(0, 3);
                targets.forEach(t => {
                    let baseDmg = 60 + (ws.level * 15) + (state.level * 2);
                    let dmg = calcDamage(baseDmg);
                    t.takeDamage(dmg.d, dmg.c, 'spike');
                    state.zones.push(new Zone(t.x, t.y, 'spike_burst', 20));
                });
                ws.timer = 0;
            }
        }

        const wp=player.weapons.pyramid; 
        if(wp.level>0){ 
            wp.timer++; 
            if(wp.timer>wp.cooldown){
                let t=getClosestEnemy();
                if(t) {
                    if(wp.evolved) {
                        addShake(15);
                        const angle = Math.atan2(t.y - player.y, t.x - player.x);
                        state.beams.push(new Beam(player.x, player.y, angle));
                        const endX = player.x + Math.cos(angle) * 1200;
                        const endY = player.y + Math.sin(angle) * 1200;
                        state.enemies.forEach(e => {
                            if(lineCircleCollide(e.x, e.y, player.x, player.y, endX, endY, e.radius + 100)) {
                                let dmg = calcDamage(wp.damage); 
                                e.takeDamage(dmg.d, dmg.c, 'beam');
                                createParticle(e.x, e.y, '#fecb00', 'spark', 1.5);
                            }
                        });
                        wp.timer = 0;
                    } else {
                        state.projectiles.push(new Projectile(player.x,player.y,t,'pyramid'));
                        wp.timer=0;
                    }
                }
            } 
        }

        const bur = player.weapons.burek;
        if(bur.evolved) {
             let fireDist = bur.dist * 2.0;
             if(state.frames % 15 === 0) { 
                 let baseTick = Math.max(1, bur.damage * 0.5);
                 state.enemies.forEach(e => {
                     if(Math.hypot(e.x - player.x, e.y - player.y) < fireDist) {
                         let dmg = calcDamage(baseTick);
                         e.takeDamage(dmg.d, false, 'fire_aura');
                         createParticle(e.x, e.y, '#ff5e00', 'fire', 0.5);
                     }
                 });
             }
             if(state.frames % 5 === 0) {
                  let rAng = Math.random() * 6.28;
                  let rDist = Math.random() * fireDist;
                  createParticle(player.x + Math.cos(rAng)*rDist, player.y + Math.sin(rAng)*rDist, 'rgba(255,100,0,0.3)', 'fire', 0.5);
             }
        }

        state.gems=state.gems.filter(g=>!g.update()); state.zones=state.zones.filter(z=>!z.update()); state.perks=state.perks.filter(p=>p.update());
        state.beams=state.beams.filter(b=>b.update());
        
        state.projectiles.forEach(p=>p.update()); 
        state.projectiles=state.projectiles.filter(p=>{
            if(p.type === 'boss_missile') {
                if(Math.hypot(p.x-player.x, p.y-player.y) < player.radius + 10) {
                    if(!godMode) {
                        player.hp -= 40; 
                    }
                    if(godMode) spawnDamageText(player.x, player.y-50, "BLOCKED", true);
                    
                    addShake(20);
                    updateHud();
                    return false; 
                }
                for(let u of state.friendlyUnits) {
                    if(!u.dead && Math.hypot(p.x - u.x, p.y - u.y) < u.radius + 10) {
                        u.takeDamage(40);
                        return false;
                    }
                }
                return p.life > 0;
            }

            if(p.type==='pyramid'&&p.life>0){
                state.enemies.forEach(e=>{
                    if(Math.hypot(e.x-p.x,e.y-p.y)<e.radius+p.radius){
                        if(!p.pierceHitList.includes(e)) {
                             let dmg=calcDamage(player.weapons.pyramid.damage); 
                             e.takeDamage(dmg.d, dmg.c, 'projectile');
                             createParticle(e.x,e.y,'#0f0','spark');
                             p.pierceHitList.push(e); 
                        }
                    }
                });
                return true;
            } 
            if(p.type==='cevapi') {
                for(let e of state.enemies) {
                    if(Math.hypot(e.x-p.x,e.y-p.y) < e.radius+15) {
                        let dmg = p.overrideDamage > 0 ? {d:p.overrideDamage, c:false} : calcDamage(player.weapons.cevapi.damage);
                        e.takeDamage(dmg.d, dmg.c, 'projectile');
                        p.life = 0;
                        return false;
                    }
                }
            }

            return p.life>0;
        });

        const harm = player.weapons.harmonika;

        state.enemies.forEach(e=>{
            e.speed = e.baseSpeed;
            if(harm.level > 0) {
                if(Math.hypot(e.x - player.x, e.y - player.y) < harm.range) {
                    let effectiveSlow = Math.min(harm.slow, 0.8);
                    e.speed = e.baseSpeed * (1 - effectiveSlow);
                    if(state.frames % 20 === 0) createParticle(e.x, e.y, '#00f3ff', 'spark', 0.2);
                }
            }

            e.update();
            let safeDist = player.radius + e.radius - 5;
            
            // COLLISION
            if(!e.frozen && Math.hypot(e.x-player.x,e.y-player.y)<safeDist){ 
                let dmgAmt = (e.type==='BOSS' || e.type==='MINI_BOSS') ? 2 : (Math.max(0.1,((e.type==='yugo'?1:0.4)-(player.armor*0.05))));
                if(!godMode) {
                    player.hp-=dmgAmt; 
                }
                
                addShake(2); updateHud(); 
                if(player.hp<=0){
                    document.getElementById('final-score').innerText=state.score;
                    document.getElementById('game-over').style.display='flex';
                    gameActive=false;
                } 
            }

            state.friendlyUnits.forEach(u => {
                if(!u.dead && !e.frozen && Math.hypot(e.x - u.x, e.y - u.y) < u.radius + e.radius) {
                    u.takeDamage(1);
                }
            });
            
            while(bur.orbs.length<bur.count)bur.orbs.push({timer:0});
            for(let b=0;b<bur.count;b++){
                if(bur.orbs[b].timer>0){ bur.orbs[b].timer--; continue; }
                const ang=(state.frames*bur.speed)+(b*6.28/bur.count), bx=player.x+Math.cos(ang)*bur.dist, by=player.y+Math.sin(ang)*bur.dist;
                
                let hitRadius = 45; 
                if(Math.hypot(e.x-bx,e.y-by) < hitRadius && e.burekHitTimer <= 0){
                    if(bur.evolved){ 
                        let dmg = calcDamage(bur.damage);
                        e.takeDamage(dmg.d, dmg.c, 'burek');
                        e.burnTimer = 60; 
                        createParticle(bx, by, '#ff5e00', 'fire', 1.0);
                        e.burekHitTimer = 30; 
                    }
                    else { 
                        let dmg=calcDamage(bur.damage); 
                        e.takeDamage(dmg.d, dmg.c, 'burek'); 
                        createParticle(e.x,e.y,'#e67e22','spark'); 
                        e.burekHitTimer = 30; 
                    }
                }
            }
        });
        state.enemies=state.enemies.filter(e=>!e.dead && Math.hypot(e.x-player.x,e.y-player.y)<2000);
        state.particles.forEach(p=>{p.x+=p.vx;p.y+=p.vy;p.life-=p.decay;p.vx*=0.95;p.vy*=0.95;}); state.particles=state.particles.filter(p=>p.life>0);
        state.texts.forEach(t=>{t.y+=t.vy; t.vy*=0.9; t.life-=0.02;}); state.texts=state.texts.filter(t=>t.life>0);
        if(state.shake>0)state.shake*=0.9; state.frames++;
    }

    function draw(){
        let cX=player.x-W/2, cY=player.y-H/2; 
        if(state.shake>0.5){cX+=(Math.random()-0.5)*state.shake;cY+=(Math.random()-0.5)*state.shake;}
        
        ctx.fillStyle='#050510'; ctx.fillRect(0,0,W,H); 
        
        state.backgroundStars.forEach(s => {
            let px = (s.x - cX * 0.1) % W; if(px<0) px+=W;
            let py = (s.y - cY * 0.1) % H; if(py<0) py+=H;
            ctx.fillStyle = `rgba(255,255,255,${s.alpha})`;
            ctx.fillRect(px, py, s.size, s.size);
        });

        ctx.strokeStyle='#1a1a2e'; ctx.lineWidth=1; ctx.beginPath();
        let ox=-cX%150, oy=-cY%150; 
        for(let i=ox;i<W;i+=150){ctx.moveTo(i,0);ctx.lineTo(i,H);} 
        for(let i=oy;i<H;i+=150){ctx.moveTo(0,i);ctx.lineTo(W,i);} 
        ctx.stroke();

        state.zones.forEach(z=>z.draw(cX,cY)); 
        state.gems.forEach(g=>g.draw(cX,cY)); 
        state.perks.forEach(p=>p.draw(cX,cY));
        
        state.friendlyUnits.forEach(u => u.draw(cX, cY));

        state.enemies.forEach(e=>e.draw(cX,cY)); 
        state.projectiles.forEach(p=>p.draw(cX,cY));
        state.beams.forEach(b=>b.draw(cX,cY));
        
        let pX=player.x-cX, pY=player.y-cY; 
        
        ctx.save(); 
        ctx.translate(pX,pY); 
        ctx.rotate(player.facing+1.57);
        
        ctx.globalCompositeOperation = 'overlay';
        let grad = ctx.createLinearGradient(0,0,0,-400);
        grad.addColorStop(0, 'rgba(255, 255, 200, 0.2)');
        grad.addColorStop(1, 'rgba(255, 255, 200, 0)');
        ctx.fillStyle = grad;
        ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(-60, -400); ctx.lineTo(60, -400); ctx.fill();
        ctx.globalCompositeOperation = 'source-over';

        ctx.shadowBlur=15; ctx.shadowColor='rgba(254,203,0,0.5)'; 
        ctx.fillStyle='#c0392b'; 
        ctx.beginPath(); ctx.moveTo(-10,0); ctx.lineTo(10,0); ctx.lineTo(15,35); ctx.lineTo(-15,35); ctx.fill();
        ctx.fillStyle='#fecb00';ctx.beginPath();ctx.ellipse(0,0,12,8,0,0,6.28);ctx.fill();
        ctx.fillStyle='#111'; ctx.beginPath(); ctx.arc(0,-2,10,0,6.28); ctx.fill(); 
        ctx.fillStyle='#555'; ctx.fillRect(-4,-2,8,3); 
        ctx.fillStyle='#333'; ctx.fillRect(8, -5, 6, 25);
        ctx.fillStyle='#111'; ctx.fillRect(10, -15, 4, 30);
        
        if(state.frames%5===0 && state.enemies.length>0) {
            ctx.fillStyle='#ffaa00'; ctx.beginPath(); ctx.arc(12, -18, 5, 0, 6.28); ctx.fill();
        }
        ctx.restore();

        const bur=player.weapons.burek;
        
        if(bur.evolved) {
             let range = bur.dist * 2.0;
             ctx.save(); ctx.translate(pX, pY);
             let fireGrad = ctx.createRadialGradient(0,0, 40, 0,0, range);
             fireGrad.addColorStop(0, 'rgba(255, 150, 0, 0.1)');
             fireGrad.addColorStop(0.8, 'rgba(255, 60, 0, 0.2)');
             fireGrad.addColorStop(1, 'rgba(255, 0, 0, 0)');
             
             ctx.fillStyle = fireGrad;
             ctx.beginPath(); ctx.arc(0,0, range, 0, 6.28); ctx.fill();
             
             ctx.strokeStyle = `rgba(255, 100, 0, ${0.3 + Math.sin(state.frames*0.1)*0.2})`;
             ctx.lineWidth = 2;
             ctx.beginPath(); ctx.arc(0,0, range, 0, 6.28); ctx.stroke();
             ctx.restore();
        }

        for(let i=0;i<bur.count;i++){
            if(!bur.orbs[i] || bur.orbs[i].timer>0) continue;
            let ang=(state.frames*bur.speed)+(i*6.28/bur.count), bx=pX+Math.cos(ang)*bur.dist, by=pY+Math.sin(ang)*bur.dist;
            ctx.save(); ctx.translate(bx,by);
            if(bur.evolved){ 
                ctx.globalCompositeOperation = 'lighter';
                ctx.fillStyle='#ffaa00'; ctx.beginPath(); ctx.arc(0,0,8,0,6.28); ctx.fill();
                let f = Math.sin(state.frames*0.5)*3;
                ctx.fillStyle='rgba(255, 50, 0, 0.6)'; ctx.beginPath(); ctx.arc(0,0,14+f,0,6.28); ctx.fill();
                if(state.frames % 5 === 0) createParticle(bx + cX, by + cY, '#ffaa00', 'fire', 0.5);
            } else { 
                ctx.rotate(ang*4);
                ctx.strokeStyle='#e67e22';ctx.lineWidth=4;
                ctx.beginPath();
                for(let j=0; j<20; j++) {
                    let r = j; let angle = j * 0.5;
                    ctx.lineTo(Math.cos(angle)*r, Math.sin(angle)*r);
                }
                ctx.stroke();
            } ctx.restore();
        }

        ctx.globalCompositeOperation='lighter'; 
        state.particles.forEach(p=>{
            ctx.globalAlpha=p.life;
            ctx.fillStyle=p.color;
            if(p.type==='note') { ctx.font="15px Arial"; ctx.fillText(p.char, p.x-cX, p.y-cY); }
            else { ctx.beginPath();ctx.arc(p.x-cX,p.y-cY,p.size,0,6.28);ctx.fill(); }
        });
        
        if(player.weapons.harmonika.level > 0){ 
            ctx.strokeStyle='rgba(0, 243, 255, 0.3)'; ctx.lineWidth=2;
            ctx.fillStyle='rgba(0, 243, 255, 0.05)';
            ctx.beginPath(); ctx.arc(pX,pY,player.weapons.harmonika.range,0,6.28); 
            ctx.fill(); ctx.stroke();
            
            ctx.strokeStyle='rgba(0, 243, 255, 0.1)';
            ctx.beginPath(); 
            ctx.arc(pX, pY, player.weapons.harmonika.range - 10, state.frames*0.02, state.frames*0.02 + 4);
            ctx.stroke();
        }
        
        ctx.globalCompositeOperation='source-over'; ctx.globalAlpha=1; ctx.shadowBlur=0;
        
        let lg=ctx.createRadialGradient(W/2,H/2,100,W/2,H/2,Math.max(W,H));
        lg.addColorStop(0,'rgba(0,0,0,0)');
        lg.addColorStop(0.6,'rgba(0,5,20,0.3)');
        lg.addColorStop(1,'rgba(0,0,0,0.9)');
        ctx.fillStyle=lg;ctx.fillRect(0,0,W,H);
        
        if(state.flashAlpha > 0){
            ctx.fillStyle=`rgba(255,255,255,${state.flashAlpha})`;
            ctx.fillRect(0,0,W,H);
        }

        state.texts.forEach(t=>{
            ctx.fillStyle=t.color;
            ctx.font=`bold ${18*t.scale}px Orbitron`;
            ctx.fillText(t.val,t.x-cX,t.y-cY);
        });
    }

    function generateCards(){
        const container = document.getElementById('cards-box'); 
        container.innerHTML=''; 
        document.getElementById('levelup-screen').style.display='flex';
        
        let available = [];

        UPGRADES.forEach(u => {
            let currentLvl = 0;
            if(player.weapons[u.id]) currentLvl = player.weapons[u.id].level;
            else if(player.items[u.id] !== undefined) currentLvl = player.items[u.id];

            if(currentLvl >= (u.max || 10)) return;

            // Evolution conditions
            if(u.id === 'burek' && player.weapons.burek.evolved) return;
            if(u.id === 'pyramid' && player.weapons.pyramid.evolved) return;
            if(u.id === 'serbian' && player.weapons.serbian.level >= 1) return; 

            available.push(u);
        });

        // Add Evolutions
        if(player.weapons.burek.level >= 8 && !player.weapons.burek.evolved) available.push(EVOLUTIONS.find(e=>e.id==='burek_evo'));
        if(player.weapons.pyramid.level >= 6 && !player.weapons.pyramid.evolved) available.push(EVOLUTIONS.find(e=>e.id==='pyramid_evo'));

        // Supercharges
        if(player.weapons.burek.evolved) available.push(SUPERCHARGES.find(s=>s.id==='supercharge_burek'));
        if(player.weapons.pyramid.evolved) available.push(SUPERCHARGES.find(s=>s.id==='supercharge_pyramid'));

        // SERBIAN PATH LOGIC
        if(player.weapons.serbian.level > 0 && !player.weapons.serbian.evolved) {
             if(player.weapons.serbian.path === 0) {
                 available.push({id:'serbian_selector', name:'UNIT EVOLUTION', icon:'‚ö°', tier:'legendary', desc:'Choose a specialization path for your unit.'});
             }
             else if (player.weapons.serbian.path === 1) available.push(EVOLUTIONS.find(e=>e.id==='serbian_p1_evo'));
             else if (player.weapons.serbian.path === 2) available.push(EVOLUTIONS.find(e=>e.id==='serbian_p2_evo'));
             else if (player.weapons.serbian.path === 3) available.push(EVOLUTIONS.find(e=>e.id==='serbian_p3_evo'));
        }

        let pools = {
            legendary: available.filter(u => u.tier === 'legendary'),
            rare: available.filter(u => u.tier === 'rare'),
            common: available.filter(u => u.tier === 'common')
        };

        let selectedCards = [];

        for(let i=0; i<3; i++) {
            let card = null;
            let safetyCounter = 0;
            
            while(card === null && safetyCounter < 10) {
                safetyCounter++;
                let rng = Math.random() * 100;
                let chosenTier = 'common';

                if (rng < (1 * player.luck)) chosenTier = 'legendary';
                else if (rng < (16 * player.luck)) chosenTier = 'rare'; // 1% + 15%
                else chosenTier = 'common';

                if(chosenTier === 'legendary' && pools.legendary.length === 0) chosenTier = 'rare';
                if(chosenTier === 'rare' && pools.rare.length === 0) chosenTier = 'common';
                
                let pool = pools[chosenTier];
                if(pool.length > 0) {
                    let candidate = pool[Math.floor(Math.random() * pool.length)];
                    if(!selectedCards.includes(candidate)) {
                        card = candidate;
                    }
                }
            }
            
            if(!card && pools.common.length > 0) card = pools.common[Math.floor(Math.random() * pools.common.length)];

            if(card && !selectedCards.includes(card)) selectedCards.push(card);
        }

        if(selectedCards.length < 3 && pools.common.length > 0) {
            pools.common.forEach(c => {
                 if(selectedCards.length < 3 && !selectedCards.includes(c)) selectedCards.push(c);
            });
        }

        selectedCards.forEach(o=>{
            const el=document.createElement('div'); el.className='card'; 
            if(o.tier === 'legendary') el.classList.add('legendary');
            if(o.tier === 'rare') el.classList.add('rare');
            
            let lvlText = '';
            if(player.weapons[o.id]) lvlText = 'Lvl ' + (player.weapons[o.id].level + 1);
            else if(player.items[o.id] !== undefined) lvlText = 'Lvl ' + (player.items[o.id] + 1);
            else if(o.base && player.weapons[o.base]) lvlText = 'EVO';

            el.innerHTML=`<div class="card-level">${lvlText}</div><div class="card-icon">${o.icon}</div><div class="card-name">${o.name}</div><div class="card-desc">${o.desc}</div>`;
            el.onclick=()=>{applyUpgrade(o.id);}; container.appendChild(el);
        });
    }

    function triggerPathSelection() {
        document.getElementById('levelup-screen').style.display='none';
        const overlay = document.getElementById('evolution-overlay');
        overlay.style.display = 'flex';
        
        // Step 1: Animation
        overlay.innerHTML = '<h1 class="evo-text">EVOLUTION<br>IMMINENT</h1>';
        
        setTimeout(() => {
            overlay.innerHTML = '<h1 style="color:var(--bosnia-yellow); margin-bottom:20px; font-family:Orbitron; font-size:40px;">CHOOSE YOUR PATH</h1><div id="evo-cards" class="cards-container"></div>';
            const container = document.getElementById('evo-cards');
            
            const paths = [
                EVOLUTIONS.find(e => e.id === 'serbian_p1'),
                EVOLUTIONS.find(e => e.id === 'serbian_p2'),
                EVOLUTIONS.find(e => e.id === 'serbian_p3')
            ];
            
            paths.forEach(o => {
                const el=document.createElement('div'); el.className='card legendary'; 
                el.innerHTML=`<div class="card-level">PATH SELECTION</div><div class="card-icon">${o.icon}</div><div class="card-name">${o.name}</div><div class="card-desc">${o.desc}</div>`;
                el.onclick=()=>{
                    applyUpgrade(o.id); 
                    overlay.style.display='none';
                    isPaused = false;
                }; 
                container.appendChild(el);
            });
        }, 2000);
    }

    function applyUpgrade(id){
        if(id==='serbian_selector') {
            triggerPathSelection();
            return;
        }

        if(id==='burek_evo'){
            player.weapons.burek.evolved=true;
            player.weapons.burek.count+=1; 
            player.weapons.burek.damage+=5;
        }
        if(id==='pyramid_evo'){player.weapons.pyramid.evolved=true;player.weapons.pyramid.damage=400;player.weapons.pyramid.baseCool=180;player.weapons.pyramid.timer=0;}
        
        if(id==='supercharge_burek'){ 
            player.weapons.burek.damage *= 1.2; 
            spawnDamageText(player.x, player.y-50, "MAGMA INTENSIFIES", true); 
        }
        if(id==='supercharge_pyramid'){ player.weapons.pyramid.damage *= 1.2; spawnDamageText(player.x, player.y-50, "POWER UP!", true); }

        if(id==='burek'){
            player.weapons.burek.count++;
            player.weapons.burek.level++;
            player.weapons.burek.speed+=0.005;
        }
        
        if(id==='cevapi'){
            player.weapons.cevapi.level++;
            if(player.weapons.cevapi.level === 2) { player.weapons.cevapi.damage = 25; player.weapons.cevapi.baseCool *= 0.85; } else { player.weapons.cevapi.damage += 10; player.weapons.cevapi.baseCool *= 0.85; }
        }

        if(id==='ajvar'){
            player.weapons.ajvar.level++;
            if(player.weapons.ajvar.level>1){player.weapons.ajvar.baseCool*=0.85;player.weapons.ajvar.damage+=20;}
        }
        if(id==='rakija'){
            player.weapons.rakija.level++;
            if(player.weapons.rakija.level>1){player.weapons.rakija.baseCool*=0.85;player.weapons.rakija.damage+=2;}
        }
        if(id==='pyramid'){
            player.weapons.pyramid.level++; 
            if(player.weapons.pyramid.level>1){player.weapons.pyramid.baseCool*=0.85;player.weapons.pyramid.damage+=15;}
        }
        if(id==='spike'){
            player.weapons.spike.level++;
        }
        if(id==='harmonika'){
            player.weapons.harmonika.level++;
            if(player.weapons.harmonika.level > 1) {
                player.weapons.harmonika.slow += 0.05; 
            }
        }

        // --- SERBIAN UPGRADE LOGIC ---
        if(id==='serbian'){
            player.weapons.serbian.level = 1;
            player.weapons.serbian.path = 0; // Basic
            state.friendlyUnits = [new FriendlyUnit('soldier', player.x, player.y)];
            spawnDamageText(player.x, player.y-80, "UNIT DEPLOYED", true);
        }
        
        if(id==='serbian_p1') {
            player.weapons.serbian.path = 1;
            state.friendlyUnits = [new FriendlyUnit('titan', player.x, player.y)];
            spawnDamageText(player.x, player.y-80, "TITAN UPGRADE", true);
        }
        if(id==='serbian_p1_evo') {
             player.weapons.serbian.evolved = true;
             state.friendlyUnits = [new FriendlyUnit('titan', player.x, player.y)]; // Re-spawn to apply evo logic
             spawnDamageText(player.x, player.y-80, "BERSERKER MODE", true);
        }

        if(id==='serbian_p2') {
            player.weapons.serbian.path = 2;
            state.friendlyUnits = [
                new FriendlyUnit('soldier', player.x + 20, player.y),
                new FriendlyUnit('defender', player.x - 20, player.y),
                new FriendlyUnit('mage', player.x, player.y - 20)
            ];
            spawnDamageText(player.x, player.y-80, "SQUAD DEPLOYED", true);
        }
        if(id==='serbian_p2_evo') {
             player.weapons.serbian.evolved = true;
             state.friendlyUnits = [
                new FriendlyUnit('soldier', player.x + 20, player.y),
                new FriendlyUnit('defender', player.x - 20, player.y),
                new FriendlyUnit('mage', player.x, player.y - 20)
            ];
             spawnDamageText(player.x, player.y-80, "ELITE SQUAD", true);
        }

        if(id==='serbian_p3') {
            player.weapons.serbian.path = 3;
            state.friendlyUnits = [new FriendlyUnit('vanguard', player.x, player.y)];
            spawnDamageText(player.x, player.y-80, "VANGUARD", true);
        }
        if(id==='serbian_p3_evo') {
             player.weapons.serbian.evolved = true;
             state.friendlyUnits = [new FriendlyUnit('vanguard', player.x, player.y)];
             spawnDamageText(player.x, player.y-80, "WARLORD TANK", true);
        }

        if(['speed','magnet','armor','heal','coffee','lily','vrelo','xp_boost','sword','cracked_jewelry'].includes(id)) {
            if(player.items[id] !== undefined) player.items[id]++;
        }

        if(id==='speed')player.speed*=1.15; if(id==='magnet')player.magnetRadius+=50; if(id==='armor')player.armor+=1.5; if(id==='heal')player.hp=Math.min(player.maxHp,player.hp+50);
        if(id==='coffee')player.cdr*=0.9; if(id==='lily')player.critChance+=0.10; if(id==='vrelo')player.regen+=2;
        
        if(id==='xp_boost') state.xpMult += 0.5;
        if(id==='cracked_jewelry') state.xpMult += 0.25;

        ['cevapi','ajvar','rakija','pyramid','spike'].forEach(w=>{ player.weapons[w].cooldown = player.weapons[w].baseCool * player.cdr; });
        
        let maxCoffee = player.items.coffee >= 10;
        
        if(player.weapons.cevapi.level >= 10) {
            let limit = maxCoffee ? 12 : 30; 
            player.weapons.cevapi.cooldown = limit;
        }

        if(player.weapons.pyramid.level >= 6) {
             let limit = maxCoffee ? 42 : 60; 
             player.weapons.pyramid.cooldown = limit;
        }

        if(document.getElementById('levelup-screen').style.display === 'flex'){
             document.getElementById('levelup-screen').style.display='none'; 
             updateHud(); 
             isPaused=false;
        }
    }
    gameLoop();
</script>
</body>
</html>
